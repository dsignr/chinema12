<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\obj\C11_Audio_New.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\obj\C11_Audio_New.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, RVCT3.0 [Build 951]: Last Updated: Wed Aug 11 15:00:51 2010
<BR><P>
<H3>Maximum Stack Usage =       1456 bytes + Unknown(Functions without stacksize,Cycles,Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
ASProcSetBalance -> GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e<P>
<H3>
Functions with no stack information
</H3><UL>
 <LI><a href="#[a66684]">Reset_Handler</a>
 <LI><a href="#[1180a04]">__scatterload</a>
 <LI><a href="#[1180934]">__scatterload_rt2</a>
 <LI><a href="#[1180984]">__scatterload_null</a>
 <LI><a href="#[1181160]">__decompress</a>
 <LI><a href="#[1181110]">__decompress1</a>
 <LI><a href="#[1180454]">__scatterload_zeroinit</a>
 <LI><a href="#[a66504]">__user_initial_stackheap</a>
 <LI><a href="#[1111d10]">_memcpy_lastbytes</a>
 <LI><a href="#[1111718]">_memcpy_lastbytes_aligned</a>
 <LI><a href="#[11b2b8c]">__ARM_call_via_r0</a>
 <LI><a href="#[11b2bdc]">__call_via_r0</a>
 <LI><a href="#[11b2ac0]">__ARM_call_via_r1</a>
 <LI><a href="#[11b2b10]">__call_via_r1</a>
 <LI><a href="#[11b29f4]">__ARM_call_via_r2</a>
 <LI><a href="#[11b2a44]">__call_via_r2</a>
 <LI><a href="#[11b2928]">__ARM_call_via_r3</a>
 <LI><a href="#[11b2978]">__call_via_r3</a>
 <LI><a href="#[11b282c]">__ARM_call_via_r4</a>
 <LI><a href="#[11b28ac]">__call_via_r4</a>
 <LI><a href="#[11b2730]">__ARM_call_via_r5</a>
 <LI><a href="#[11b27b0]">__call_via_r5</a>
 <LI><a href="#[11b2634]">__ARM_call_via_r6</a>
 <LI><a href="#[11b26b4]">__call_via_r6</a>
 <LI><a href="#[11b2538]">__ARM_call_via_r7</a>
 <LI><a href="#[11b25b8]">__call_via_r7</a>
 <LI><a href="#[11c8068]">_memset</a>
 <LI><a href="#[11d7dec]">_memset_w</a>
 <LI><a href="#[11bdff8]">__fpl_inf_d2f</a>
 <LI><a href="#[11bd59c]">__fpl_inf_dadd</a>
 <LI><a href="#[11c69ec]">__fpl_inf_dcmp</a>
 <LI><a href="#[11c5524]">__fpl_inf_fcmp</a>
 <LI><a href="#[11bc178]">__fpl_inf_ddiv</a>
 <LI><a href="#[11bb18c]">__dflt_normalise</a>
 <LI><a href="#[11ba874]">__fpl_inf_dmul</a>
 <LI><a href="#[11d281c]">__fpl_inf_dsqrt</a>
 <LI><a href="#[11bd520]">__fpl_inf_dsub</a>
 <LI><a href="#[11b9fb4]">__fpl_inf_f2d</a>
 <LI><a href="#[11b9618]">__fpl_inf_fadd</a>
 <LI><a href="#[11b8400]">__fpl_inf_fdiv</a>
 <LI><a href="#[11b7824]">__fpl_inf_ffix</a>
 <LI><a href="#[11b6ce8]">__fpl_inf_ffixu</a>
 <LI><a href="#[11b61e4]">__fflt_normalise</a>
 <LI><a href="#[11b58f4]">__fpl_inf_fmul</a>
 <LI><a href="#[11ed7b4]">__fplib_config_pureend_doubles</a>
 <LI><a href="#[11b959c]">__fpl_inf_fsub</a>
 <LI><a href="#[11c4534]">__fpl_inf_scalbn</a>
 <LI><a href="#[a66c74]">Undef_Handler</a>
 <LI><a href="#[a66bfc]">SWI_Handler</a>
 <LI><a href="#[a66b80]">PAbt_Handler</a>
 <LI><a href="#[a66b04]">DAbt_Handler</a>
 <LI><a href="#[a66a8c]">IRQ_Handler</a>
 <LI><a href="#[a66a14]">FIQ_Handler</a>
 <LI><a href="#[11107b4]">__arm_div4</a>
 <LI><a href="#[111073c]">__arm_div8</a>
 <LI><a href="#[11106c0]">__arm_div_large</a>
 <LI><a href="#[11bd964]">_dadd1</a>
 <LI><a href="#[11bd788]">_dsub1</a>
 <LI><a href="#[11b9968]">_fadd1</a>
 <LI><a href="#[11b978c]">_fsub1</a>
</UL>
<P>
<H3>
Mutually Recursive functions
</H3><UL>
 <LI><a href="#[107aa78]">DSP_CFG_VIRTUALIZER</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[107aaf8]">DSP_CFG_PPM_Mode</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[107ab78]">DSP_CFG_PPM</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[107abf0]">DSP_CFG_MATRIX</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[107ac6c]">DSP_CFG_DECODER</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[107ace8]">DSP_BOOT</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[10ba9e0]">DSP_CFG_MCLK_FACTOR</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[10baae4]">DSP_CFG_AUDIO_SRC</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[fcf908]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[a66c74]">Undef_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66c74]">Undef_Handler</a><BR>
 <LI><a href="#[a66bfc]">SWI_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66bfc]">SWI_Handler</a><BR>
 <LI><a href="#[a66b80]">PAbt_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66b80]">PAbt_Handler</a><BR>
 <LI><a href="#[a66b04]">DAbt_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66b04]">DAbt_Handler</a><BR>
 <LI><a href="#[a66a8c]">IRQ_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66a8c]">IRQ_Handler</a><BR>
 <LI><a href="#[a66a14]">FIQ_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66a14]">FIQ_Handler</a><BR>
</UL>
<BR>
<P><STRONG><a name="[a66684]"></a>Reset_Handler</STRONG> (ARM, 0 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[11be720]"></a>__main</STRONG> (ARM, 8 bytes, Stack size 0 bytes, __main.o(!!!main))
<BR><BR>[Stack]<UL><LI>Max Depth = 68 + Unknown Stack Size
<LI>Call Chain = __main -> __rt_entry -> __rt_lib_init -> _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[1180a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
<LI><a href="#[11cf738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[1180a04]"></a>__scatterload</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[11be720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[1180934]"></a>__scatterload_rt2</STRONG> (ARM, 48 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11cf738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[1180984]"></a>__scatterload_null</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[1181160]"></a>__decompress</STRONG> (ARM, 92 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[1181110]"></a>__decompress1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[1180454]"></a>__scatterload_zeroinit</STRONG> (ARM, 44 bytes, Stack size unknown bytes, __scatter_zi.o(!!handler_zi), UNUSED)

<P><STRONG><a name="[11d4cbc]"></a>__ARM_argv_veneer</STRONG> (ARM, 16 bytes, Stack size 0 bytes, lib_init.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[a66504]"></a>__user_initial_stackheap</STRONG> (ARM, 0 bytes, Stack size unknown bytes, lpc2300.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11cedb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[a60588]"></a>Systeminit</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = Systeminit -> HardwareInit -> SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a600c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitRemoteRepeatKey
<LI><a href="#[a601bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[a60418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[b42570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UartInit
<LI><a href="#[b42664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Timer0Init
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[a6050c]"></a>ProcDimerOff</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = ProcDimerOff -> VfdSetDimerValue -> VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b42478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f264ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[a60498]"></a>main</STRONG> (Thumb, 130 bytes, Stack size 24 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1000 + Unknown Stack Size
<LI>Call Chain = main -> Timer0_Handler -> RadioDisplay -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMsgQueue
<LI><a href="#[a60238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[a602b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMessage
<LI><a href="#[a6032c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[a60588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Systeminit
<LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[b42478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[b424f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
<LI><a href="#[b425e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[b426dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[b42758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[b427d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[b42848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[b428cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LedStandby
<LI><a href="#[11b2b8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Address Reference Count : 1]<UL><LI> kernel.o(.text)
</UL>
<P><STRONG><a name="[f1e2b0]"></a>debug_printf</STRONG> (Thumb, 62 bytes, Stack size 160 bytes, debug.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[1113088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[a60238]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[b10058]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[b100d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[b4237c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[b42848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f117b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
<LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f26b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[f26cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[f26db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[f26e38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
<LI><a href="#[f26eb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
<LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f71eac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f724bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey
<LI><a href="#[f72534]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8c7d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8cf94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8d374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[f8d654]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[f8d9bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb46c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[fb4ab4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[fb4d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[fb4db0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[fcbf6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[fd9e98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[ff6110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[ff6194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
<LI><a href="#[ff6310]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcCurrenTunerFreq
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[100b7ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
<LI><a href="#[1023f88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
<LI><a href="#[102b1f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102eb30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DebugEepromValue
<LI><a href="#[10581b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[1058228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[107ae70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[107b078]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
<LI><a href="#[107b0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
<LI><a href="#[107b17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
<LI><a href="#[107b200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
<LI><a href="#[107b37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[107b3f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
<LI><a href="#[108c928]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
<LI><a href="#[108ca2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[108caac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHRACfg
<LI><a href="#[108cb2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[108cc24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
<LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
<LI><a href="#[108cd98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayBuffer
<LI><a href="#[108ce14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DispBuffer
<LI><a href="#[10e2ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
</UL>

<P><STRONG><a name="[b4237c]"></a>assert_Function</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, debug.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b30108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage
<LI><a href="#[b30180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f42620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
</UL>

<P><STRONG><a name="[f1e234]"></a>rs232_printf</STRONG> (Thumb, 62 bytes, Stack size 160 bytes, debug.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[1113088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[a603a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[b03f9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b04014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b22b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b22b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
<LI><a href="#[b22c7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ2VFD_
<LI><a href="#[b22cf8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2_
<LI><a href="#[b22d70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2M
<LI><a href="#[b22de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[b22f54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[b22fcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[b23044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b230c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b2313c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b231b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b23234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b232b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b2332c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b233a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[b235a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1DF_
<LI><a href="#[b2361c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[b23694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EU
<LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b23784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[b23880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ES
<LI><a href="#[b238f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EE
<LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[b23a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ED
<LI><a href="#[b23ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1D
<LI><a href="#[b23b5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1C
<LI><a href="#[b23bd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1A_
<LI><a href="#[b23c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1M
<LI><a href="#[b23cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[b23e30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
<LI><a href="#[b240a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f8dd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
<LI><a href="#[f8de7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[f8def4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
<LI><a href="#[f8df6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAIS
<LI><a href="#[f8dfe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASTO
<LI><a href="#[f8e060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2M
<LI><a href="#[f8e0dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRM
<LI><a href="#[f8e158]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
<LI><a href="#[f8e1d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[f8e250]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
<LI><a href="#[f8e2cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
<LI><a href="#[f8e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[f8e3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
<LI><a href="#[f8e43c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASSP
<LI><a href="#[f8e4b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTT_
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[f8e714]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[f8e794]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdT
<LI><a href="#[f8e80c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[f8e888]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[f8e900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[f8e97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[f8eae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[f8eb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[f8ebdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACNR
<LI><a href="#[f8ec58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[f8ecd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[f8ed50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[f8edcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[f8ee48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[f8eec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[f8ef40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[f8efbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[f8f038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[f8f0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[f8f130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[f8f1ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[f8f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[f8f2a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[f8f320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[f8f39c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[f8f418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[f8f594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[f8f610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[f8f68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[f8f708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[f8f784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[f8f800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[f8f87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[f8f8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
<LI><a href="#[f8f974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ1VFD_
<LI><a href="#[f8f9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[f8fa74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_
<LI><a href="#[f8faf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_
<LI><a href="#[f8fb6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_
<LI><a href="#[f8fbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_
<LI><a href="#[f8fc64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_
<LI><a href="#[f8fce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_
<LI><a href="#[f8fd5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_
<LI><a href="#[f8fdd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_
<LI><a href="#[f8fe54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[f8fed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[f8ff4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[f8ffc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[f90044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[f900c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[f9013c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[f901b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[f90234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[f902b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[f9032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[f903a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[f90424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[f904a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[f9051c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[f90598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[f90614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[f90690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[f9070c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[f90788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[f90be0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[f90c5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[f90cd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[f90d54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[f90dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[f90e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[f90ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[f90f3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[f90fb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[f9102c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[f910a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[f91124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[f911a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[f9121c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[f91294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[f9130c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[f91384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[f913fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[f91474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[f914f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[f9156c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[f915e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[f91664]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[f916dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[f91754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[f917d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[f9184c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[f918c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[f91944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[f919c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[f91a38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[f91ab0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[f91b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1LPS
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
<LI><a href="#[f92080]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[f920f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[f92170]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[f921ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[f92268]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[f922e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[f92358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[f923d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
<LI><a href="#[f92448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[f924c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[f92538]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[f925b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[f92628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[f926a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[f92718]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[f92790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
<LI><a href="#[f92884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[f928fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[f92974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[f929ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
</UL>

<P><STRONG><a name="[f1e1b8]"></a>debug_message</STRONG> (Thumb, 6 bytes, Stack size 12 bytes, debug.o(.text), UNUSED)

<P><STRONG><a name="[f15768]"></a>InitQueue</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, queue.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[10156c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
<LI><a href="#[1015830]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>

<P><STRONG><a name="[f156ec]"></a>IsQueueEmpty</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a603a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[f15494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
<LI><a href="#[f15588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[ff6110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[ff6194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[f15674]"></a>IsQueueFull</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f15494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
<LI><a href="#[f15514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InQueue
</UL>

<P><STRONG><a name="[f155fc]"></a>QueueFront</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, queue.o(.text), UNUSED)

<P><STRONG><a name="[f15588]"></a>DeQueue</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DeQueue -> IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[f156ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a603a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[ff6110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[ff6194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[f15514]"></a>InQueue</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f15674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10157b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Isr (via Veneer)
<LI><a href="#[1015928]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Isr (via Veneer)
</UL>

<P><STRONG><a name="[f15494]"></a>GetQueueElementNum</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f15674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull
<LI><a href="#[f156ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
</UL>
<BR>[Called By]<UL><LI><a href="#[f15410]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementRemain
</UL>

<P><STRONG><a name="[f15410]"></a>GetQueueElementRemain</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f15494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
</UL>

<P><STRONG><a name="[f15394]"></a>GetQueueElement</STRONG> (Thumb, 48 bytes, Stack size 40 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[f11c00]"></a>SetDspPower</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f117b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>
<BR>[Called By]<UL><LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[f11b88]"></a>SetDspDelay</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f118a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[fb51a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>

<P><STRONG><a name="[f11b0c]"></a>SetDspCorner</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 880 + Unknown Stack Size
<LI>Call Chain = SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11920]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fe60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
</UL>

<P><STRONG><a name="[f11a90]"></a>SetDspSpkMode</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 880 + Unknown Stack Size
<LI>Call Chain = SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f116b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcSpkMode
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fee0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f91384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[f913fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[f91474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[f914f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[f9156c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[f915e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[f91664]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[f916dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[f92080]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[f920f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[f92170]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[f921ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[f92268]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[f922e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[f92358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[f923d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
</UL>

<P><STRONG><a name="[f11a14]"></a>SetDspSignal</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11734]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[fb5124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceTestSignal
</UL>

<P><STRONG><a name="[f1199c]"></a>SetDspIrc</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SetDspIrc -> DspProcIrc -> InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1182c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>
<BR>[Called By]<UL><LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[b1b670]"></a>HeadphoneDetect</STRONG> (Thumb, 154 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = HeadphoneDetect -> MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1b4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[b1c8f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[b1b5ec]"></a>GetEncoderSwitchThread</STRONG> (Thumb, 378 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetEncoderSwitchThread</UL>
<BR>[Calls]<UL><LI><a href="#[b1b3f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseEncoderSwitchPlus
<LI><a href="#[b1b478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseEncoderSwitchMinus
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[b1b574]"></a>key_task</STRONG> (Thumb, 168 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = key_task -> GetPanelKeyThread -> read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1b4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
<LI><a href="#[b1c77c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[a60140]"></a>InitMsgQueue</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, message.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b30180]"></a>PostMessage</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, message.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b308bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull
<LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>

<P><STRONG><a name="[b30108]"></a>SendMessage</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b308bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull
<LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b1b4fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
<LI><a href="#[f26370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[f42984]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f733cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetSoftMute
<LI><a href="#[f73448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDspChannel
<LI><a href="#[f734c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[f7354c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f735cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[f8caac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8cb28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cc24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[f8cca8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[f8cd24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8cd9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[f8ce14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8ce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[ff6704]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSavePreset
<LI><a href="#[ff6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgTextDisplay
</UL>

<P><STRONG><a name="[a602b4]"></a>GetMessage</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetMessage</UL>
<BR>[Calls]<UL><LI><a href="#[b30938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueEmpty
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b240a8]"></a>GetProtocolFloatValue</STRONG> (Thumb, 200 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = GetProtocolFloatValue -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[11b954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b04014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b22b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b22b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b22de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b23044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b230c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b2313c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b231b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b23234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b232b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b2332c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b233a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[b2361c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[f8e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[f8e80c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[f8e888]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[f8e900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[f8e97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[f8eae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[f8eb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[f8f0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[f8f130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[f8f1ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[f8f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[f8f2a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[f8f320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[f8f39c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[f8f418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[f90424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[f904a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[f9051c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[f90598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[f90614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[f90690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[f9070c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[f90788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[f90be0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[f90c5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[f90cd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[f90d54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[f90dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[f90e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[f90ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[f90f3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[f90fb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[f9102c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[f910a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[f91124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[f911a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[f9121c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[f91294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[f9130c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
<LI><a href="#[f92448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[f924c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[f92538]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[f925b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[f92628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[f926a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[f92718]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[f92790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
<LI><a href="#[f92884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[f928fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[f92974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[f929ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
</UL>

<P><STRONG><a name="[b24024]"></a>IsProtocolStringValid</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
<LI><a href="#[f8e250]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
</UL>

<P><STRONG><a name="[b23fac]"></a>ProcCmdSPU</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23f28]"></a>GetCurrentDecodeStatus</STRONG> (Thumb, 68 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b23e30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[b23ea8]"></a>GetPcmDecodeMode</STRONG> (Thumb, 126 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetPcmDecodeMode</UL>
<BR>[Calls]<UL><LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b23694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EU
<LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b23e30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[b23e30]"></a>ProcCmdZ1_</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[b23f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurrentDecodeStatus
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23db4]"></a>GetZone1Channel</STRONG> (Thumb, 158 bytes, Stack size 8 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetZone1Channel</UL>
<BR>[Calls]<UL><LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
</UL>

<P><STRONG><a name="[b23d3c]"></a>ProcCmdZ1S</STRONG> (Thumb, 280 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1S -> RadioInit -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23db4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8c9c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23cc4]"></a>ProcCmdZ1P</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1P -> MsgSetPower -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cd24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8d10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1PowerOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23c4c]"></a>ProcCmdZ1M</STRONG> (Thumb, 192 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1M -> MsgSetMute -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23bd4]"></a>ProcCmdZ1A_</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1A_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23b5c]"></a>ProcCmdZ1C</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1C -> SetLate -> DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23ae4]"></a>ProcCmdZ1D</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1D -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23a6c]"></a>ProcCmdZ1ED</STRONG> (Thumb, 142 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ED -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d84c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b239e8]"></a>GetDolby2ChDecodeMode</STRONG> (Thumb, 108 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
</UL>

<P><STRONG><a name="[b23970]"></a>ProcCmdZ1EF</STRONG> (Thumb, 252 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EF -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b239e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDolby2ChDecodeMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d74c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[f8d8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b238f8]"></a>ProcCmdZ1EE</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EE -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23880]"></a>ProcCmdZ1ES</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ES -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b237fc]"></a>GetDolby5ChDecodeMode</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b23784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
</UL>

<P><STRONG><a name="[b23784]"></a>ProcCmdZ1EX</STRONG> (Thumb, 374 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EX -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b237fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDolby5ChDecodeMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b2370c]"></a>ProcCmdZ1E</STRONG> (Thumb, 292 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1E -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d74c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[f8d7d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23694]"></a>ProcCmdZ1EU</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EU -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b2361c]"></a>ProcCmdZ1VM</STRONG> (Thumb, 192 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VM -> MsgSetVolume -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8d08c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[11b7754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b235a0]"></a>ProcCmdZ1DF_</STRONG> (Thumb, 242 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1DF_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23524]"></a>ProtocolSetEq</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d5d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b23044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b230c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b2313c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b231b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b23234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b232b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b2332c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b233a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[f90424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[f904a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[f9051c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[f90598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[f90614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[f90690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[f9070c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[f90788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
</UL>

<P><STRONG><a name="[b234a0]"></a>IsProtocolEqBandValid</STRONG> (Thumb, 230 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsProtocolEqBandValid</UL>
<BR>[Calls]<UL><LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b23044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b230c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b2313c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b231b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b23234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b232b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b2332c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b233a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[f90424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[f904a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[f9051c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[f90598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[f90614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[f90690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[f9070c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[f90788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
</UL>

<P><STRONG><a name="[b23424]"></a>IsBalanceValid</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsBalanceValid</UL>
<BR>[Calls]<UL><LI><a href="#[11b4bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[11b51a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b04014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b22b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b22b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b23044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b230c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b2313c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b231b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b23234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b232b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b2332c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b233a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[f90424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[f904a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[f9051c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[f90598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[f90614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[f90690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[f9070c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[f90788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[f90be0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[f90c5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[f90cd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[f90d54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[f90dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[f90e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[f90ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[f90f3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[f92884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[f928fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[f92974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[f929ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
</UL>

<P><STRONG><a name="[b233a8]"></a>ProcCmdZ1EQL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQL -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b2332c]"></a>ProcCmdZ1EQC</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQC -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b232b0]"></a>ProcCmdZ1EQR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQR -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23234]"></a>ProcCmdZ1EQSR</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSR -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b231b8]"></a>ProcCmdZ1EQBSR</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQBSR -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b2313c]"></a>ProcCmdZ1EQBSL</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQBSL -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b230c0]"></a>ProcCmdZ1EQSL</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSL -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b23044]"></a>ProcCmdZ1EQSW</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSW -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22fcc]"></a>ProcCmdZ1EQ</STRONG> (Thumb, 156 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQ -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8d564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22f54]"></a>ProcCmdZ2P</STRONG> (Thumb, 334 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2P -> MsgSetPower -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cd24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8d010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22ed8]"></a>GetZone2Channel</STRONG> (Thumb, 108 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetZone2Channel</UL>
<BR>[Calls]<UL><LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
</UL>

<P><STRONG><a name="[b22e60]"></a>ProcCmdZ2S</STRONG> (Thumb, 554 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2S -> Zone2RadioMode -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b22ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetZone2Channel
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8be90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8bf0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22de8]"></a>ProcCmdZ2V</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2V -> MsgSetVolume -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8d08c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[11b7754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22d70]"></a>ProcCmdZ2M</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2M -> MsgSetMute -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22cf8]"></a>ProcCmdZ2_</STRONG> (Thumb, 190 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22c7c]"></a>ProCmdZ2VFD_</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProCmdZ2VFD_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22c04]"></a>ProcCmdRSN</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = ProcCmdRSN -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b24024]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolStringValid
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c084]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22b8c]"></a>ProcCmdSLL</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b22b14]"></a>ProcCmdSLC</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b04014]"></a>ProcCmdSLR</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b03f9c]"></a>ProcCmdSLSR</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f929ec]"></a>ProcCmdSLSL</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92974]"></a>ProcCmdSLBR</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLBR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f928fc]"></a>ProcCmdSLBL</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLBL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92884]"></a>ProcCmdSLSW</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSW -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92808]"></a>IsDistanceValid</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsDistanceValid</UL>
<BR>[Calls]<UL><LI><a href="#[11b3a88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[11b51a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[f90fb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[f9102c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[f910a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[f91124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[f911a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[f9121c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[f91294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[f9130c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[f92448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[f924c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[f92538]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[f925b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[f92628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[f926a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[f92718]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[f92790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
</UL>

<P><STRONG><a name="[f92790]"></a>ProcCmdSPL</STRONG> (Thumb, 340 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92718]"></a>ProcCmdSPC</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPC -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f926a0]"></a>ProcCmdSPR</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92628]"></a>ProcCmdSPSR</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPSR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f925b0]"></a>ProcCmdSPSL</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPSL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92538]"></a>ProcCmdSPBR</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPBR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f924c0]"></a>ProcCmdSPBL</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPBL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92448]"></a>ProcCmdSPs</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPs -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f923d0]"></a>ProcCmdSZL</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92358]"></a>ProcCmdSZR</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f922e0]"></a>ProcCmdSZSL</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92268]"></a>ProcCmdSZSR</STRONG> (Thumb, 270 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f921ec]"></a>ProcCmdSZSBL</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSBL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92170]"></a>ProcCmdSZSBR</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSBR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f920f8]"></a>ProcCmdSZC</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZC -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92080]"></a>ProcCmdSZS</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZS -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f92000]"></a>IsCrossoverValid</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = IsCrossoverValid</UL>
<BR>[Calls]<UL><LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>

<P><STRONG><a name="[f91f80]"></a>GetCrossoverPoint</STRONG> (Thumb, 116 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>

<P><STRONG><a name="[f91f04]"></a>ProcCmdSZXFL</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91e88]"></a>ProcCmdSZXFC</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFC -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91e0c]"></a>ProcCmdSZXFR</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91d90]"></a>ProcCmdSZXSR</STRONG> (Thumb, 276 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91d14]"></a>ProcCmdSZXSL</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91c98]"></a>ProcCmdSZXSBR</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSBR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91c1c]"></a>ProcCmdSZXSBL</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSBL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91ba4]"></a>ProcCmdSZX</STRONG> (Thumb, 122 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZX -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91b28]"></a>ProcCmdZ1LPS</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 888 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1LPS -> ChangeListenProfileMode -> SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8dc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91ab0]"></a>ProcCmdSSPL</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91a38]"></a>ProcCmdSSPC</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPC -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f919c0]"></a>ProcCmdSSPR</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91944]"></a>ProcCmdSSPSR</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f918c8]"></a>ProcCmdSSPSL</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9184c]"></a>ProcCmdSSPSBR</STRONG> (Thumb, 298 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSBR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f917d0]"></a>ProcCmdSSPSBL</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSBL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91754]"></a>ProcCmdSSPSW</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSW -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f916dc]"></a>ProcCmdMSZL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91664]"></a>ProcCmdMSZR</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f915e8]"></a>ProcCmdMSZSL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9156c]"></a>ProcCmdMSZSR</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f914f0]"></a>ProcCmdMSZSBL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSBL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91474]"></a>ProcCmdMSZSBR</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSBR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f913fc]"></a>ProcCmdMSZC</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZC -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91384]"></a>ProcCmdMSZS</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZS -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9130c]"></a>ProcCmdMSPL</STRONG> (Thumb, 318 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91294]"></a>ProcCmdMSPC</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPC -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9121c]"></a>ProcCmdMSPR</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f911a0]"></a>ProcCmdMSPSR</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPSR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f91124]"></a>ProcCmdMSPSL</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPSL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f910a8]"></a>ProcCmdMSPBR</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPBR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9102c]"></a>ProcCmdMSPBL</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPBL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90fb4]"></a>ProcCmdMSPs</STRONG> (Thumb, 100 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPs -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90f3c]"></a>ProcCmdMSLL</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90ec4]"></a>ProcCmdMSLC</STRONG> (Thumb, 76 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90e4c]"></a>ProcCmdMSLR</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90dd0]"></a>ProcCmdMSLSR</STRONG> (Thumb, 296 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90d54]"></a>ProcCmdMSLSL</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90cd8]"></a>ProcCmdMSLBR</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLBR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90c5c]"></a>ProcCmdMSLBL</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLBL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90be0]"></a>ProcCmdMSLSW</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSW -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90b64]"></a>ProcCmdMSZXFL</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90ae8]"></a>ProcCmdMSZXFC</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFC -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90a6c]"></a>ProcCmdMSZXFR</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f909f0]"></a>ProcCmdMSZXSR</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90974]"></a>ProcCmdMSZXSBR</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSBR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f908f8]"></a>ProcCmdMSZXSBL</STRONG> (Thumb, 336 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSBL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9087c]"></a>ProcCmdMSZXSL</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90804]"></a>ProcCmdMSZX</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZX -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f91f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f92000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90788]"></a>ProcCmdMZ1EQL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQL -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9070c]"></a>ProcCmdMZ1EQC</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQC -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90690]"></a>ProcCmdMZ1EQR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQR -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90614]"></a>ProcCmdMZ1EQSR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSR -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90598]"></a>ProcCmdMZ1EQBSR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQBSR -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9051c]"></a>ProcCmdMZ1EQBSL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQBSL -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f904a0]"></a>ProcCmdMZ1EQSL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSL -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90424]"></a>ProcCmdMZ1EQSW</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSW -> ProtocolSetEq -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b23424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b234a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b23524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f903a8]"></a>ProcCmdMSSPL</STRONG> (Thumb, 272 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9032c]"></a>ProcCmdMSSPC</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPC -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f902b0]"></a>ProcCmdMSSPR</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90234]"></a>ProcCmdMSSPSR</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f901b8]"></a>ProcCmdMSSPSL</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f9013c]"></a>ProcCmdMSSPSBR</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSBR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f900c0]"></a>ProcCmdMSSPSBL</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSBL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f90044]"></a>ProcCmdMSSPSW</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSW -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ffc8]"></a>ProcCmdZ1EMDIM</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMDIM -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c4f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ff4c]"></a>ProcCmdZ1EMP</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fed0]"></a>ProcCmdZ1EMC</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fe54]"></a>ProcCmdZ1EMDEL</STRONG> (Thumb, 554 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMDEL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8db20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fdd8]"></a>ProcCmdZ1VFL_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VFL_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fd5c]"></a>ProcCmdZ1VFR_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VFR_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fce0]"></a>ProcCmdZ1VC_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VC_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fc64]"></a>ProcCmdZ1VSL_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VSL_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fbe8]"></a>ProcCmdZ1VSR_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VSR_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fb6c]"></a>ProcCmdZ1VBL_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VBL_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8faf0]"></a>ProcCmdZ1VBR_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VBR_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8fa74]"></a>ProcCmdZ1VS_</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VS_ -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f9f0]"></a>Rs232UpdateStreamType</STRONG> (Thumb, 2526 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Rs232UpdateStreamType -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ1VFD_
</UL>

<P><STRONG><a name="[f8f974]"></a>ProCmdZ1VFD_</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProCmdZ1VFD_ -> Rs232UpdateStreamType -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8f9f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f8f8]"></a>ProcCmdZ1IN1</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f87c]"></a>ProcCmdZ1IN2</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f800]"></a>ProcCmdZ1IN3</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f784]"></a>ProcCmdZ1IN4</STRONG> (Thumb, 674 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f708]"></a>ProcCmdZ1IN5</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f68c]"></a>ProcCmdZ1IN6</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f610]"></a>ProcCmdZ1IN7</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f594]"></a>ProcCmdZ1IN8</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f514]"></a>IsAnalogLevelValid</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsAnalogLevelValid</UL>
<BR>[Calls]<UL><LI><a href="#[11b4bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[11b51a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[f8f130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[f8f1ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[f8f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[f8f2a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[f8f320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[f8f39c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[f8f418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
</UL>

<P><STRONG><a name="[f8f494]"></a>FindLevelPosition</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = FindLevelPosition -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[11b3a88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[11b401c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[11b45a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11b7754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8f0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[f8f130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[f8f1ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[f8f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[f8f2a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[f8f320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[f8f39c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[f8f418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
</UL>

<P><STRONG><a name="[f8f418]"></a>ProcCmdZ1SAL1</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f39c]"></a>ProcCmdZ1SAL2</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f320]"></a>ProcCmdZ1SAL3</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f2a4]"></a>ProcCmdZ1SAL4</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f228]"></a>ProcCmdZ1SAL5</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f1ac]"></a>ProcCmdZ1SAL6</STRONG> (Thumb, 322 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f130]"></a>ProcCmdZ1SAL7</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f0b4]"></a>ProcCmdZ1SAL8</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8f494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[f8f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8f038]"></a>ProcCmdZ1ACN1</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8efbc]"></a>ProcCmdZ1ACN2</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ef40]"></a>ProcCmdZ1ACN3</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8eec4]"></a>ProcCmdZ1ACN4</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ee48]"></a>ProcCmdZ1ACN5</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8edcc]"></a>ProcCmdZ1ACN6</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ed50]"></a>ProcCmdZ1ACN7</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ecd4]"></a>ProcCmdZ1ACN8</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ec58]"></a>ProcCmdZ1ACN7_1</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN7_1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ebdc]"></a>ProcCmdZ1ACNR</STRONG> (Thumb, 332 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACNR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8eb64]"></a>ProcCmdTAT</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAT -> MsgSetRadioSearch -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8eae8]"></a>ProcCmdTAHDT</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDT -> MsgSetRadioSearch -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8ea70]"></a>ProcCmdTFT</STRONG> (Thumb, 160 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTFT -> MsgSetRadioSearch -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e9f4]"></a>ProcCmdTFHDT</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTFHDT -> MsgSetRadioSearch -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e97c]"></a>ProcCmdTAP</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAP -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e900]"></a>ProcCmdTAHDP</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDP -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e888]"></a>ProcCmdTFP</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTFP -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e80c]"></a>ProcCmdTFHDP</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = ProcCmdTFHDP -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e794]"></a>ProcCmdT</STRONG> (Thumb, 236 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = ProcCmdT -> MsgSetRadioSearch -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e714]"></a>GetTunerPosition</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = GetTunerPosition -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
</UL>

<P><STRONG><a name="[f8e69c]"></a>ProcCmdTAS</STRONG> (Thumb, 164 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAS -> SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[f8cf94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[f8e714]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e620]"></a>ProcCmdTAHDS</STRONG> (Thumb, 166 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDS -> SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[f8cf94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[f8e714]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e5a8]"></a>ProcCmdTAF</STRONG> (Thumb, 220 bytes, Stack size 40 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAF -> SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[f8cf94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[f8e714]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e52c]"></a>ProcCmdTAHDF</STRONG> (Thumb, 218 bytes, Stack size 40 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 856 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDF -> SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[f8cf94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[f8e714]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e4b4]"></a>ProcCmdTT_</STRONG> (Thumb, 184 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTT_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e43c]"></a>ProcCmdASSP</STRONG> (Thumb, 318 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASSP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e3c0]"></a>ProcCmdASHDMIAO</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdASHDMIAO -> SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c6dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e344]"></a>ProcCmdASAVD</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = ProcCmdASAVD -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b240a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8db20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[f92808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e2cc]"></a>ProcCmdASFP</STRONG> (Thumb, 144 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASFP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8ce94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e250]"></a>ProcCmdASRSN</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = ProcCmdASRSN -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b24024]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolStringValid
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c084]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[f8c8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e1d4]"></a>ProcCmdASIRC</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIRC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e158]"></a>ProcCmdASIR2C</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIR2C -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8be14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e0dc]"></a>ProcCmdASIRM</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIRM -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8e060]"></a>ProcCmdASIR2M</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIR2M -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8dfe8]"></a>ProcCmdASTO</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASTO -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8df6c]"></a>ProcCmdASAIS</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASAIS -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8def4]"></a>ProcCmdASDD</STRONG> (Thumb, 364 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ProcCmdASDD -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8de7c]"></a>ProcCmdASRD</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = ProcCmdASRD -> SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8c364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[f8de08]"></a>StrCmp</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8dd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
</UL>

<P><STRONG><a name="[f8dd8c]"></a>ProcRs232Msg</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcRs232Msg -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8de08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StrCmp
<LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[a603a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
</UL>

<P><STRONG><a name="[a603a0]"></a>C11Rs232</STRONG> (Thumb, 188 bytes, Stack size 8 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = C11Rs232 -> ProcRs232Msg -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f15588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[f156ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[f1e140]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[f1e234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f8dd8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
</UL>
<BR>[Address Reference Count : 1]<UL><LI> main.o(.data)
</UL>
<P><STRONG><a name="[fb5598]"></a>SetSpeakerMode</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = SetSpeakerMode -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fb551c]"></a>SetDistanceMode</STRONG> (Thumb, 336 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = SetDistanceMode -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb4ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fb54a0]"></a>SetBalanceMode</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = SetBalanceMode -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fb541c]"></a>SetCrossoverPointsMode</STRONG> (Thumb, 364 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb48c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fb53a4]"></a>Phase_Relay</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Phase_Relay</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
</UL>

<P><STRONG><a name="[f8c574]"></a>SetSpkPhase</STRONG> (Thumb, 358 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4ba8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacInvert
<LI><a href="#[fb53a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fb70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[f90044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[f900c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[f9013c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[f901b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[f90234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[f902b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[f9032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[f903a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[f91754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[f917d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[f9184c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[f918c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[f91944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[f919c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[f91a38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[f91ab0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[fb5324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[1004c60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
</UL>

<P><STRONG><a name="[fb5324]"></a>SetSpeakerPhaseMode</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SetSpeakerPhaseMode -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fb52a8]"></a>SetPanoramaMode</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, setup_func.o(.text), UNUSED)

<P><STRONG><a name="[fb5224]"></a>SetPanoramaToDefault</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, setup_func.o(.text), UNUSED)

<P><STRONG><a name="[f8dc10]"></a>ChangeListenProfileMode</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 872 + Unknown Stack Size
<LI>Call Chain = ChangeListenProfileMode -> SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fb4c20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[fb5324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[fb541c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[fb54a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[fb551c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode
<LI><a href="#[fb5598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerMode
</UL>
<BR>[Called By]<UL><LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[f91b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1LPS
</UL>

<P><STRONG><a name="[b10994]"></a>AssignedInputSetup</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = AssignedInputSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fd64]"></a>SpkDimensionSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SpkDimensionSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c4f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fbec]"></a>SpkPanoramaSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SpkPanoramaSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0faf4]"></a>SpkWidthSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SpkWidthSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c3e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb51a8]"></a>SetSpkDistance</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11b88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspDelay
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b0fde4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
</UL>

<P><STRONG><a name="[b0fde4]"></a>SpkDelaySetup</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = SpkDelaySetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb51a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fb70]"></a>SpkPhaseSetup</STRONG> (Thumb, 190 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SpkPhaseSetup -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb49c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fc6c]"></a>SpkEqSetup</STRONG> (Thumb, 206 bytes, Stack size 32 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = SpkEqSetup -> EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d5d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fe60]"></a>SpkCrossoverSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11b0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspCorner
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b10894]"></a>AvSyncDelaySetup</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = AvSyncDelaySetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8db20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0ff5c]"></a>SpkBlanceTestMode</STRONG> (Thumb, 372 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = SpkBlanceTestMode -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb4d2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f26adc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb5124]"></a>SetBalanceTestSignal</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = SetBalanceTestSignal -> SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[f26a58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[b0ffdc]"></a>SpkBlanceSetup</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SpkBlanceSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 2]<UL><LI> menu_tbl.o(.data)
<LI> setup_menu.o(.text)
</UL>
<P><STRONG><a name="[b104c4]"></a>LateSetup</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = LateSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b1034c]"></a>PasswordModeSetup</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = PasswordModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b102d0]"></a>PasswordSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = PasswordSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b1081c]"></a>BrightSetup</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = BrightSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8ce94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b10914]"></a>AutoInputSeekSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = AutoInputSeekSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0f3a8]"></a>Zone2InputSetup</STRONG> (Thumb, 340 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = Zone2InputSetup -> Zone2RadioMode -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8be90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8bf0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[f8d010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fb4554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb50a8]"></a>GetVolumeIndex</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, setup_func.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
</UL>

<P><STRONG><a name="[b0f228]"></a>Zone2VolumeSetup</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = Zone2VolumeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb46c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[fb50a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVolumeIndex
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b1053c]"></a>IrControlSetup</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = IrControlSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0f328]"></a>Zone2IrControlSetup</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = Zone2IrControlSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8be14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0f2a8]"></a>Zone2IrModeSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = Zone2IrModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b10254]"></a>RearIrModeSetup</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = RearIrModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0f4a4]"></a>TriggerSetup</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = TriggerSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b101d4]"></a>RestoreDefaultSetup</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = RestoreDefaultSetup -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fee0]"></a>SpkConfigSetup</STRONG> (Thumb, 138 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f91384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[f913fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[f91474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[f914f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[f9156c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[f915e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[f91664]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[f916dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[f92080]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[f920f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[f92170]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[f921ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[f92268]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[f922e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[f92358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[f923d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0fce4]"></a>SpkDistanceSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb51a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f90fb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[f9102c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[f910a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[f91124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[f911a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[f9121c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[f91294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[f9130c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[f92448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[f924c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[f92538]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[f925b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[f92628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[f926a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[f92718]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[f92790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb5028]"></a>SetAnalogInLevel</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = SetAnalogInLevel -> Set2ChVolume -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b10a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
</UL>

<P><STRONG><a name="[b10a14]"></a>AnalogLevelSetup</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = AnalogLevelSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb5028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb4fac]"></a>SetAnalogInMode</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, setup_func.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b10a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
</UL>

<P><STRONG><a name="[b10a94]"></a>AnalogInSetup</STRONG> (Thumb, 154 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = AnalogInSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4fac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInMode
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b10634]"></a>HDMIInAudioSetup</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = HDMIInAudioSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f8c6dc]"></a>SetHdmiAudioOut</STRONG> (Thumb, 128 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb4ab4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b106b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f8e3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
</UL>

<P><STRONG><a name="[b10730]"></a>CDPureAudio</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = CDPureAudio -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b106b4]"></a>HDMIAUIDOOUT</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = HDMIAUIDOOUT -> SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c6dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb4f28]"></a>SetMasterVolumeLevel</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = SetMasterVolumeLevel -> SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb47c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[b103cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
</UL>

<P><STRONG><a name="[b103cc]"></a>MasterVolumeLevel</STRONG> (Thumb, 102 bytes, Stack size 40 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 880 + Unknown Stack Size
<LI>Call Chain = MasterVolumeLevel -> SetMasterVolumeLevel -> SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb4ea4]"></a>SetZ2MasterVolumeLevel</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = SetZ2MasterVolumeLevel -> SetZ2MasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[fb46c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[fb4740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeValue
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Z2MasterVolumeLevel
</UL>

<P><STRONG><a name="[b0f424]"></a>Z2MasterVolumeLevel</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = Z2MasterVolumeLevel -> SetZ2MasterVolumeLevel -> SetZ2MasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4ea4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb4e28]"></a>MaxVolumeLevel</STRONG> (Thumb, 212 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = MaxVolumeLevel -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[b10154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMaxVolumeLevel
</UL>

<P><STRONG><a name="[b10154]"></a>SetMaxVolumeLevel</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = SetMaxVolumeLevel -> MaxVolumeLevel -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4e28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f8c8d0]"></a>ReadName</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = ReadName -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b1044c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[b105b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
<LI><a href="#[f8e250]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
</UL>

<P><STRONG><a name="[f8c084]"></a>WriteName</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b1044c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[b105b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
<LI><a href="#[b22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
<LI><a href="#[f8e250]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
</UL>

<P><STRONG><a name="[fb4db0]"></a>ChanegName</STRONG> (Thumb, 106 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ChanegName -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b1044c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[b105b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
</UL>

<P><STRONG><a name="[b105b8]"></a>InputNameSetup</STRONG> (Thumb, 172 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = InputNameSetup -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c084]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[f8c8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[fb4db0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b1044c]"></a>LogoSetup</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = LogoSetup -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c084]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[f8c8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[fb4db0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f27328]"></a>ReadPwd</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = ReadPwd -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f26b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[f272b0]"></a>WritePwd</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f8c364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[f27230]"></a>read_curr_option</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = read_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[f26760]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[f26fac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
</UL>

<P><STRONG><a name="[f271b0]"></a>write_curr_option</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = write_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f8c364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[f27130]"></a>execute_curr_option</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = execute_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[f26760]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[f8c364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[f270b0]"></a>load_default_option</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = load_default_option</UL>
<BR>[Calls]<UL><LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[f2702c]"></a>Inquire_restrict_option</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Inquire_restrict_option</UL>
<BR>[Calls]<UL><LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[f26fac]"></a>MenuLoadCurOption</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = MenuLoadCurOption -> read_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[f27230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[f26f30]"></a>MenuFindPage</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, setup_menu.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b10058]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[f26c48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[f26eb4]"></a>MenuCaptionShow</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = MenuCaptionShow -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[f26e38]"></a>MenuHeaderShow</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = MenuHeaderShow -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f26cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[f26db8]"></a>VfdShowMenuOption</STRONG> (Thumb, 76 bytes, Stack size 48 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[1113088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[f26d3c]"></a>MenuItemShow</STRONG> (Thumb, 1204 bytes, Stack size 80 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1040 + Unknown Stack Size
<LI>Call Chain = MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[f26eb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
<LI><a href="#[f2702c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[f27230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[11bc0b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f26cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[f26cc4]"></a>MenuDisplay</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1056 + Unknown Stack Size
<LI>Call Chain = MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f26d3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[f26e38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
</UL>
<BR>[Called By]<UL><LI><a href="#[b10058]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[f2656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[f26c48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[b10058]"></a>SetupMenuDisplay</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = SetupMenuDisplay -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f26f30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuFindPage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f26c48]"></a>SetupMenuInit</STRONG> (Thumb, 90 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f26f30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuFindPage
</UL>
<BR>[Called By]<UL><LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f26b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[f26bcc]"></a>VfdInitDispPwd</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = VfdInitDispPwd -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f26b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[f26b54]"></a>SetupInit</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f26bcc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[f26c48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
<LI><a href="#[f27328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadPwd
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f26adc]"></a>SetupExit</STRONG> (Thumb, 252 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = SetupExit -> SpkBlanceTestMode -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ff5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f26468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[f8c948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[b100d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f26a58]"></a>SetupMenuProcBalance</STRONG> (Thumb, 98 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = SetupMenuProcBalance -> SetBalanceTestSignal -> SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fb4d2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[fb5124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceTestSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[f269dc]"></a>ProcSetupUpKey</STRONG> (Thumb, 312 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = ProcSetupUpKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[f26a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f26fac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
<LI><a href="#[f2702c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f8dc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f2695c]"></a>ProcSetupDownKey</STRONG> (Thumb, 328 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = ProcSetupDownKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[f26a58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f26fac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
<LI><a href="#[f2702c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f8dc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f268dc]"></a>ProcSetupLeftKey</STRONG> (Thumb, 450 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = ProcSetupLeftKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f271b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f27230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f2685c]"></a>ProcSetupRightKey</STRONG> (Thumb, 444 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = ProcSetupRightKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f271b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f27230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f267dc]"></a>ProcSetupEnterKey</STRONG> (Thumb, 282 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1064 + Unknown Stack Size
<LI>Call Chain = ProcSetupEnterKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[b0ff5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f26370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[f26468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[f26bcc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f271b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f8dc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[b100d8]"></a>SetupExitMenu</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 968 + Unknown Stack Size
<LI>Call Chain = SetupExitMenu -> SetupExit -> SpkBlanceTestMode -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26adc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
<LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f26760]"></a>SetupLoadEeprom</STRONG> (Thumb, 582 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetupLoadEeprom -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f27230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b42848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
</UL>

<P><STRONG><a name="[f8c364]"></a>SetupLoadDefault</STRONG> (Thumb, 238 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f270b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;load_default_option
<LI><a href="#[f27130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f271b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f272b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b101d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[b42848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8de7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
</UL>

<P><STRONG><a name="[f266e4]"></a>PwdKeyService</STRONG> (Thumb, 624 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = PwdKeyService -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b100d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26bcc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[f26c48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f272b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f26668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f26668]"></a>SetupKeyService</STRONG> (Thumb, 246 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1080 + Unknown Stack Size
<LI>Call Chain = SetupKeyService -> PwdKeyService -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b100d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f266e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f267dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f2685c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f2695c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[f26adc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Called By]<UL><LI><a href="#[f264ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[f265e8]"></a>SetupFlashHandler</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = SetupFlashHandler -> MsgSetFlash -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[f2656c]"></a>UpdateVfdFlash</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1072 + Unknown Stack Size
<LI>Call Chain = UpdateVfdFlash -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f263e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVfdbufferChar
<LI><a href="#[f26cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f264ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[f264ec]"></a>SetupProcMessage</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1136 + Unknown Stack Size
<LI>Call Chain = SetupProcMessage -> Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a6050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[f261f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f2656c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[f26668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[f8d200]"></a>IsCurFocusTid</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f4c208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f731dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[f81ce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundProcMessage
</UL>

<P><STRONG><a name="[f262f4]"></a>SetCurFocusTid</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f26adc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[f26b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[f42908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f71e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[f72334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8c9c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f8d468]"></a>GetCurFocusTid</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b100d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[b23db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel
<LI><a href="#[b42758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[b427d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f26b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[f72334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[fd9e98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[b427d0]"></a>ProcMessage</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = ProcMessage</UL>
<BR>[Calls]<UL><LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b424f8]"></a>VfdRefresh</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = VfdRefresh -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7e578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f7e6ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
</UL>

<P><STRONG><a name="[f263e8]"></a>GetVfdbufferChar</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f2656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
</UL>

<P><STRONG><a name="[f7e6ec]"></a>SetVfdOwner</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = SetVfdOwner -> VfdRefresh -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b424f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
</UL>
<BR>[Called By]<UL><LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[f7e670]"></a>VfdTimerHandler</STRONG> (Thumb, 94 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[104526c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[f7e5f4]"></a>SetVfdDispMode</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8c17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
</UL>

<P><STRONG><a name="[fb45d4]"></a>VfdDisplay</STRONG> (Thumb, 114 bytes, Stack size 104 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7e578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11110fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy (via Veneer)
<LI><a href="#[1113088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[b101d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[f2656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f26bcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[f26db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[f26e38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
<LI><a href="#[f26eb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
<LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f422a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f42620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
<LI><a href="#[f4271c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[f42794]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayConnectHelp
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f72f6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[f730e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f731dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[f73260]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[ff6294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[ff6488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[f26278]"></a>VfdDisplayBlank</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7e578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[111211c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f26bcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[f26cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f422a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f42908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f72f6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[f730e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f73260]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8c9c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[ff6488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
</UL>

<P><STRONG><a name="[f8c17c]"></a>VfdTempDisp</STRONG> (Thumb, 114 bytes, Stack size 104 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 912 + Unknown Stack Size
<LI>Call Chain = VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7e578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[f7e5f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdDispMode
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11110fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy (via Veneer)
<LI><a href="#[1113088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[b22fcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[f8c0fc]"></a>VfdTempDispBlank</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = VfdTempDispBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7e578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[111211c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b22fcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[f8d08c]"></a>IsZone1VolumeValid</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b22de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b2361c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f8cd9c]"></a>MsgSetMute</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetMute -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b22d70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2M
<LI><a href="#[b23c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1M
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[f735cc]"></a>MsgSetStream</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetStream -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[fd9e98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[108ca2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[108caac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHRACfg
<LI><a href="#[108cb2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[108cba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
<LI><a href="#[108cc24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
</UL>

<P><STRONG><a name="[f8ce14]"></a>MsgSetInputSource</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetInputSource -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b10994]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[b10a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[f42908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8ec58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[f8ecd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[f8ed50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[f8edcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[f8ee48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[f8eec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[f8ef40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[f8efbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[f8f038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[f8f594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[f8f610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[f8f68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[f8f708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[f8f784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[f8f800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[f8f87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[f8f8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
</UL>

<P><STRONG><a name="[f7354c]"></a>MsgSetDSPSetting</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetDSPSetting -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[f72724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f727a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[f7281c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[f72898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[f72914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[f8d74c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[107b0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
<LI><a href="#[107b200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[f734c8]"></a>MsgSetDSPHDMISetting</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetDSPHDMISetting -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f725b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[104526c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[f73448]"></a>MsgSetDspChannel</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetDspChannel -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[f733cc]"></a>MsgSetSoftMute</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetSoftMute -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[104526c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[f8cd24]"></a>MsgSetPower</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetPower -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b22f54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[b23cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f8cb28]"></a>MsgSetVfdShow</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b100d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b23784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[b42758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f42908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f4c208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f72534]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[f725b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[f726a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[f72724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f727a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[f72914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f732d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RefreshHandle
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8e80c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[f8e888]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[f8e900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[f8e97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[ff6218]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TextDisplayExit
<LI><a href="#[ff90fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveExit
<LI><a href="#[104526c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[f8ce94]"></a>MsgSetDimer</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetDimer -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b1081c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8e2cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
</UL>

<P><STRONG><a name="[b1b4fc]"></a>MsgSetKey</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b1b574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;key_task
<LI><a href="#[b1b670]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HeadphoneDetect
<LI><a href="#[b1c7fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;proc_key_hold
<LI><a href="#[b1c878]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;proc_key_press
</UL>

<P><STRONG><a name="[f8caac]"></a>MsgSetVolume</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetVolume -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b22de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b2361c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8c364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[f26370]"></a>MsgSetFlash</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetFlash -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f265e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupFlashHandler
<LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f2695c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[f269dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[f8d10c]"></a>IsZone1PowerOn</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b23cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f73354]"></a>SetRefresh</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f731dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
</UL>

<P><STRONG><a name="[f732d8]"></a>RefreshHandle</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = RefreshHandle -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
</UL>
<BR>[Called By]<UL><LI><a href="#[104526c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[f73260]"></a>ShowVersion</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = ShowVersion -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f731dc]"></a>VfdUpdateVolumeValue</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = VfdUpdateVolumeValue -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f73354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRefresh
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f730e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
</UL>

<P><STRONG><a name="[f7315c]"></a>VfdUpdateStreamType</STRONG> (Thumb, 2990 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = VfdUpdateStreamType -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f730e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[f730e0]"></a>VfdUpdateZone1</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = VfdUpdateZone1 -> VfdUpdateStreamType -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f7315c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f731dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f8d374]"></a>GetSrcName</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = GetSrcName -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4c208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
</UL>

<P><STRONG><a name="[f73064]"></a>SelectSource</STRONG> (Thumb, 1080 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f71674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[f71c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[f71eac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[f723b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[f72434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
</UL>

<P><STRONG><a name="[f72fe8]"></a>ProcInputSelect</STRONG> (Thumb, 186 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 880 + Unknown Stack Size
<LI>Call Chain = ProcInputSelect -> SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f73064]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f72f6c]"></a>PowerOnDisplay</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = PowerOnDisplay -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[fb47c4]"></a>SetMasterVolumeValue</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[fb4f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
</UL>

<P><STRONG><a name="[f72ee8]"></a>GetVolumeEepromSetValue</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f72e6c]"></a>SystemPowerOn</STRONG> (Thumb, 160 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b42478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f715fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[f716fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[f717f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetResetPin
<LI><a href="#[f71868]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoPowerOn
<LI><a href="#[f71b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[f71bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[f71cbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
<LI><a href="#[f71d34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitCs8416
<LI><a href="#[f71dac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[f72f6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb47c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
</UL>
<BR>[Called By]<UL><LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[f72df0]"></a>SystemPowerOff</STRONG> (Thumb, 92 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = SystemPowerOff -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b426dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f716fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[f71ad0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[f71b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
</UL>

<P><STRONG><a name="[f72d78]"></a>Zone1Mute</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Zone1Mute</UL>
<BR>[Calls]<UL><LI><a href="#[f718e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[f719dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
<LI><a href="#[fb49c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
</UL>

<P><STRONG><a name="[f72cfc]"></a>SetAutoseekFlag</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetAutoseekFlag -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f72c80]"></a>IsAutoSeekOn</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = IsAutoSeekOn -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[f72c04]"></a>IsEverAutoseek</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = IsEverAutoseek -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[f72b8c]"></a>SeekSelect</STRONG> (Thumb, 352 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SeekSelect -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f72434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8c7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
</UL>

<P><STRONG><a name="[f72b10]"></a>ProcAutoSeekSur</STRONG> (Thumb, 534 bytes, Stack size 32 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 944 + Unknown Stack Size
<LI>Call Chain = ProcAutoSeekSur -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f722bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[f72b8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cd24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f72a90]"></a>ProcZone1PowerOn</STRONG> (Thumb, 170 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 952 + Unknown Stack Size
<LI>Call Chain = ProcZone1PowerOn -> ProcAutoSeekSur -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f71674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[f71774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[f72b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72c04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsEverAutoseek
<LI><a href="#[f72c80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAutoSeekOn
<LI><a href="#[f72cfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[f72e6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f8c6dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f72a10]"></a>ProcZone1PowerOff</STRONG> (Thumb, 116 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = ProcZone1PowerOff -> SystemPowerOff -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f71774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[f72d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[f72df0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[b42848]"></a>LoadSystemStartupValue</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = LoadSystemStartupValue -> SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26760]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[f8c364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[f72990]"></a>Zone1ProcAutoSeek</STRONG> (Thumb, 660 bytes, Stack size 40 bytes, zone1_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f722bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[f72b8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cd24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[f72914]"></a>PcmProcCesKey</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = PcmProcCesKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f8d7d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f72898]"></a>Ac3ProcCesKey</STRONG> (Thumb, 132 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = Ac3ProcCesKey -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8d8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f7281c]"></a>DtsProcCesKey</STRONG> (Thumb, 126 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = DtsProcCesKey -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8d84c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f727a0]"></a>PcmProcNeoKey</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = PcmProcNeoKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f8d7d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f72724]"></a>PcmProcPliiKey</STRONG> (Thumb, 184 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = PcmProcPliiKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f8d7d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f726a8]"></a>PcmProcSurKey</STRONG> (Thumb, 288 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = PcmProcSurKey -> DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f72124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f8d74c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f7262c]"></a>Ac3ProcPliiKey</STRONG> (Thumb, 284 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = Ac3ProcPliiKey -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f71fa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[f734c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f725b0]"></a>DtsProcPliiKey</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = DtsProcPliiKey -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f734c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d84c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f72534]"></a>Ac3ProcSurKey</STRONG> (Thumb, 232 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = Ac3ProcSurKey -> DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f721b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_MULTI
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d74c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f724bc]"></a>IsHidenKey</STRONG> (Thumb, 184 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = IsHidenKey -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f261f8]"></a>Zone1ProcMessage</STRONG> (Thumb, 1330 bytes, Stack size 40 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1120 + Unknown Stack Size
<LI>Call Chain = Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a6050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[b1081c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[b42478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f7201c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f720a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[f72a10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f72d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[f72ee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVolumeEepromSetValue
<LI><a href="#[f72fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f730e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[f7315c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f731dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[f76b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d08c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[f8d10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1PowerOn
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb48c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f264ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[f8d010]"></a>IsZone2PowerOn</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, zone2_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22f54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fb4ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[f4c38c]"></a>IsZone2VolumeValid</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, zone2_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[fb4740]"></a>SetZ2MasterVolumeValue</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetZ2MasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fb4ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
</UL>

<P><STRONG><a name="[f4c30c]"></a>ProcZone2PowerOn</STRONG> (Thumb, 138 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = ProcZone2PowerOn -> SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f71774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[f72e6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[f8d374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb4554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fb4740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeValue
</UL>
<BR>[Called By]<UL><LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[f4c28c]"></a>ProcZone2PowerOff</STRONG> (Thumb, 124 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = ProcZone2PowerOff -> SystemPowerOff -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f4bc2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[f4bf24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[f71774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[f72df0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f7e6ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[f4c208]"></a>Zone2ProcInputSelect</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = Zone2ProcInputSelect -> Zone2SelectChannel -> Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f4bf24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[f8d374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[fb4554]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[f8be90]"></a>Zone2RadioMode</STRONG> (Thumb, 244 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = Zone2RadioMode -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f4bca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[f4bd2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[f4bdac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[f4be2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f4bf24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8cf94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[f81be4]"></a>Zone2ProcMessage</STRONG> (Thumb, 580 bytes, Stack size 32 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 968 + Unknown Stack Size
<LI>Call Chain = Zone2ProcMessage -> ProcZone2PowerOn -> SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a6050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[f4bc2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[f4c208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f4c28c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f4c30c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f4c38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2VolumeValid
<LI><a href="#[f4d370]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[fb46c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[f42984]"></a>MsgSetIrc</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetIrc -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f42620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
<LI><a href="#[f72334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
</UL>

<P><STRONG><a name="[f72334]"></a>AutoSoundInit</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = AutoSoundInit -> MsgSetIrc -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f42908]"></a>AutoSoundExit</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = AutoSoundExit -> VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f723b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f42620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
</UL>

<P><STRONG><a name="[f42890]"></a>InitSpkPara</STRONG> (Thumb, 142 bytes, Stack size 0 bytes, auto_sound.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[f42814]"></a>IsAnySpkValid</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, auto_sound.o(.text), UNUSED)

<P><STRONG><a name="[f42794]"></a>DisplayConnectHelp</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = DisplayConnectHelp -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[f4271c]"></a>DisplayNA</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = DisplayNA -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
</UL>

<P><STRONG><a name="[f426a0]"></a>GetIrc2EqValue</STRONG> (Thumb, 1022 bytes, Stack size 656 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1416 + Unknown Stack Size
<LI>Call Chain = GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f41eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value
<LI><a href="#[f420a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[11b401c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[11b45a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[11b954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[11bdfa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
</UL>

<P><STRONG><a name="[f42620]"></a>ASProcSetupConfig</STRONG> (Thumb, 278 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = ASProcSetupConfig -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f425a0]"></a>ASProcSpeakerCheck</STRONG> (Thumb, 1016 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = ASProcSpeakerCheck -> DisplayConnectHelp -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[f1199c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f41f34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[f41fb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSpkDistance
<LI><a href="#[f42030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[f420a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[f421a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[f42794]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayConnectHelp
<LI><a href="#[f42890]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitSpkPara
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f723b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[f72434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b3a88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[11ba824]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul (via Veneer)
<LI><a href="#[11bdfa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f42520]"></a>ASProcSetDistance</STRONG> (Thumb, 562 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = ASProcSetDistance -> DisplayNA -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f4271c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11125f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[11bc0b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv (via Veneer)
<LI><a href="#[11bdfa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f424a0]"></a>ASProcSetBalance</STRONG> (Thumb, 1034 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1456 + Unknown Stack Size
<LI>Call Chain = ASProcSetBalance -> GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[f1199c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f41eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value
<LI><a href="#[f41f34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[f420a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[f42120]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue
<LI><a href="#[f426a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
<LI><a href="#[f4271c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11125f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11b3a88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[11b401c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[11ba824]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul (via Veneer)
<LI><a href="#[11bd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dsub (via Veneer)
<LI><a href="#[11bdfa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f4242c]"></a>sort</STRONG> (Thumb, 58 bytes, Stack size 4 bytes, auto_sound.o(.text), UNUSED)

<P><STRONG><a name="[f423a4]"></a>ASProcSetCrossoverPoints</STRONG> (Thumb, 620 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = ASProcSetCrossoverPoints -> DisplayNA -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[f1199c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f41f34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[f4271c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f42328]"></a>ASProcSetRoomEQ</STRONG> (Thumb, 872 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = ASProcSetRoomEQ -> DisplayNA -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b4237c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;assert_Function
<LI><a href="#[f1199c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f41f34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[f4271c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f8d4e4]"></a>FindBalancePosition</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = FindBalancePosition -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[11b401c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[11b45a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11b7754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b04014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b22b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b22b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b23524]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f90be0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[f90c5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[f90cd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[f90d54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[f90dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[f90e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[f90ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[f90f3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[f92884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[f928fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[f92974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[f929ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
</UL>

<P><STRONG><a name="[f422a8]"></a>SPK_Phase_Display</STRONG> (Thumb, 112 bytes, Stack size 48 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 960 + Unknown Stack Size
<LI>Call Chain = SPK_Phase_Display -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[f42224]"></a>ASProcSetSpeakerphase</STRONG> (Thumb, 2632 bytes, Stack size 24 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 984 + Unknown Stack Size
<LI>Call Chain = ASProcSetSpeakerphase -> SPK_Phase_Display -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fb70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[b0fc6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[b0fce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b0fe60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b0fee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[b0ffdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f422a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[f4271c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[f42908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f42984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[f44948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[f8d4e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1110c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11125f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[11b9398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fsub (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f81ce4]"></a>AutoSoundProcMessage</STRONG> (Thumb, 176 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = AutoSoundProcMessage</UL>
<BR>[Calls]<UL><LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[ff6880]"></a>SetRadioStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[ff6010]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
<LI><a href="#[ff9084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveInit
<LI><a href="#[ff90fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveExit
</UL>

<P><STRONG><a name="[ff6804]"></a>GetRadioStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[f8d188]"></a>IsFreqValid</STRONG> (Thumb, 114 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[f8eae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[f8eb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
</UL>

<P><STRONG><a name="[f8cca8]"></a>MsgSetRadioFreq</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetRadioFreq -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[f8eae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[f8eb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
</UL>

<P><STRONG><a name="[f8cba4]"></a>MsgSetRadioSearch</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetRadioSearch -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8e794]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdT
<LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[f8eae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[f8eb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[f8cc24]"></a>MsgSetRadioLoadPreset</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = MsgSetRadioLoadPreset -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8e80c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[f8e888]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[f8e900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[f8e97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ff6788]"></a>MsgTextDisplay</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = MsgTextDisplay -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ff6704]"></a>MsgSetRadioSavePreset</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = MsgSetRadioSavePreset -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b30108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[f8c854]"></a>SaveFmPreset</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
</UL>

<P><STRONG><a name="[f8cf94]"></a>LoadRadioPreset</STRONG> (Thumb, 258 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = LoadRadioPreset -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
</UL>

<P><STRONG><a name="[ff6684]"></a>IsTunerIfCorrect</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, radio_task.o(.text), UNUSED)

<P><STRONG><a name="[ff6604]"></a>ISValidTunerPostion</STRONG> (Thumb, 332 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6588]"></a>RadioDisplay</STRONG> (Thumb, 656 bytes, Stack size 56 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 968 + Unknown Stack Size
<LI>Call Chain = RadioDisplay -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8d010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11125f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ff6508]"></a>GetTextDispBuffer</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetTextDispBuffer</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[ff6488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
</UL>

<P><STRONG><a name="[ff6488]"></a>Radio_Text_Display</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 920 + Unknown Stack Size
<LI>Call Chain = Radio_Text_Display -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTextDispBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff640c]"></a>RadioChangeMode</STRONG> (Thumb, 824 bytes, Stack size 16 bytes, radio_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f4bd2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[f4bdac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[f4be2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f4bf24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[f71eac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[f72434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff5f10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>

<P><STRONG><a name="[f8c948]"></a>RadioInit</STRONG> (Thumb, 496 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = RadioInit -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60418]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f4bd2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[f4bdac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[f4be2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f4bf24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[f71eac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[f72434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb4944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff5f10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[f26adc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[f8c9c0]"></a>RadioExit</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = RadioExit -> VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f26468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[f4bf24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[f4c188]"></a>CalcRadioPosition</STRONG> (Thumb, 376 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[ff6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[ff6390]"></a>CalcRadioFreq</STRONG> (Thumb, 166 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6310]"></a>CalcCurrenTunerFreq</STRONG> (Thumb, 60 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = CalcCurrenTunerFreq -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6294]"></a>UpdateSaveVfd</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 928 + Unknown Stack Size
<LI>Call Chain = UpdateSaveVfd -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[ff9084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveInit
</UL>

<P><STRONG><a name="[ff6218]"></a>TextDisplayExit</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = TextDisplayExit -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6010]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
</UL>

<P><STRONG><a name="[ff6194]"></a>C11_Tuner_SIS_Change</STRONG> (Thumb, 426 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = C11_Tuner_SIS_Change -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f15588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[f156ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[ff5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6110]"></a>C11_Tuner_PSD_Change</STRONG> (Thumb, 628 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = C11_Tuner_PSD_Change -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f15588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[f156ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6094]"></a>PreProcSaveKey</STRONG> (Thumb, 234 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = PreProcSaveKey -> UpdateSaveVfd -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f4c188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[ff6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[ff6704]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSavePreset
<LI><a href="#[ff90fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveExit
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ff6010]"></a>PreProcTextDisplayKey</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = PreProcTextDisplayKey -> TextDisplayExit -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff6218]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TextDisplayExit
<LI><a href="#[ff6880]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ff5f94]"></a>RadioKeyService</STRONG> (Thumb, 986 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 976 + Unknown Stack Size
<LI>Call Chain = RadioKeyService -> RadioDisplay -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f4c188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[f8c948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8c9c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
<LI><a href="#[ff6094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[ff6588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[ff6788]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgTextDisplay
<LI><a href="#[ff6804]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRadioStatus
<LI><a href="#[ff9084]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveInit
<LI><a href="#[ff9174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcDigitKey
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[f81c64]"></a>RadioProcMessage</STRONG> (Thumb, 1908 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1136 + Unknown Stack Size
<LI>Call Chain = RadioProcMessage -> Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a6050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f261f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f4bca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[f4bdac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[f4c188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[f7315c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f7e6ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[f8c854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[f8cf94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8d188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5c80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[ff5d00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Up
<LI><a href="#[ff5d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Down
<LI><a href="#[ff5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[ff5e8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
<LI><a href="#[ff5f94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[ff6110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[ff6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
<LI><a href="#[ff6310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcCurrenTunerFreq
<LI><a href="#[ff6390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioFreq
<LI><a href="#[ff6488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[ff6508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTextDispBuffer
<LI><a href="#[ff6588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[ff6604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ISValidTunerPostion
<LI><a href="#[ff6804]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRadioStatus
<LI><a href="#[ff6880]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
<LI><a href="#[ff9358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_freq
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[b42758]"></a>RadioLoop</STRONG> (Thumb, 144 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = RadioLoop -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10158a8]"></a>SetUart0Baudrate</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = SetUart0Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1015830]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>

<P><STRONG><a name="[1015830]"></a>Uart0Init</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Uart0Init -> SetUart0Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[f15768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[10158a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetUart0Baudrate
</UL>
<BR>[Called By]<UL><LI><a href="#[b42570]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UartInit
</UL>

<P><STRONG><a name="[f1e140]"></a>Uart0Send</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, uart.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a603a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[f1e234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f1e2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;debug_printf
</UL>

<P><STRONG><a name="[1015738]"></a>SetUart1Baudrate</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10156c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
</UL>

<P><STRONG><a name="[10156c0]"></a>Uart1Init</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Uart1Init -> SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[f15768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[1015738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetUart1Baudrate
</UL>
<BR>[Called By]<UL><LI><a href="#[b42570]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UartInit
</UL>

<P><STRONG><a name="[1015648]"></a>Uart1Send</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, uart.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f4bca4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[f4bd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[f4bdac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[fe191c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Freq
<LI><a href="#[fe1998]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Ext_Reset
<LI><a href="#[fe1a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Stop_Seek
<LI><a href="#[fe1a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Band_Command
<LI><a href="#[ff5c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[ff5d00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Up
<LI><a href="#[ff5d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Down
<LI><a href="#[ff5e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[ff5e8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
</UL>

<P><STRONG><a name="[b42570]"></a>UartInit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = UartInit -> Uart1Init -> SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[10156c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
<LI><a href="#[1015830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>
<BR>[Called By]<UL><LI><a href="#[a60588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[1015928]"></a>Uart0Isr</STRONG> (ARM, 68 bytes, Stack size 32 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Uart0Isr -> InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f15514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uart.o(.text)
</UL>
<P><STRONG><a name="[10157b8]"></a>Uart1Isr</STRONG> (ARM, 84 bytes, Stack size 32 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Uart1Isr -> InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f15514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uart.o(.text)
</UL>
<P><STRONG><a name="[100b7ac]"></a>Cs8416WriteByte</STRONG> (Thumb, 52 bytes, Stack size 88 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = Cs8416WriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[100b4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f71d34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitCs8416
</UL>

<P><STRONG><a name="[100b730]"></a>Cs8416ReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[100b53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[100b5b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsCs8416Unlock
<LI><a href="#[100b634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[100b6b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
</UL>

<P><STRONG><a name="[100b6b4]"></a>Cs8416GetFreq</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = Cs8416GetFreq -> Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[100b730]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[100b634]"></a>CheckCs8416Unlock</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = CheckCs8416Unlock -> Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[100b730]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fe89f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[100b5b8]"></a>IsCs8416Unlock</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, cs8416.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100b730]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>

<P><STRONG><a name="[f71d34]"></a>InitCs8416</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = InitCs8416 -> Cs8416WriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[100b7ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[1004dd0]"></a>SelectDSD</STRONG> (Thumb, 186 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1004d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>

<P><STRONG><a name="[1004d58]"></a>write_word</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1004a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[1004dd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
</UL>
<BR>[Called By]<UL><LI><a href="#[1004cdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>

<P><STRONG><a name="[1004cdc]"></a>Pcm1796Write</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[1004d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>
<BR>[Called By]<UL><LI><a href="#[f421a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[f71c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[f71cbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
<LI><a href="#[f8daac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fb4ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacInvert
</UL>

<P><STRONG><a name="[fb4ba8]"></a>DacInvert</STRONG> (Thumb, 182 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = DacInvert -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[1004cdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
</UL>

<P><STRONG><a name="[f421a0]"></a>Auto_Setup_DAC_Phase</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = Auto_Setup_DAC_Phase -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004cdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[1004c60]"></a>InitDACPhase</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = InitDACPhase -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8c574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f71cbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
</UL>

<P><STRONG><a name="[f8daac]"></a>DacMute</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = DacMute -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[1004cdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[b101d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[f26a58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[f8de7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f71cbc]"></a>InitDACReg</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = InitDACReg -> InitDACPhase -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1004c60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
<LI><a href="#[1004cdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[1004be8]"></a>DSD_Choose</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DSD_Choose</UL>
<BR>[Calls]<UL><LI><a href="#[1004b70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Select
</UL>
<BR>[Called By]<UL><LI><a href="#[f71c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
</UL>

<P><STRONG><a name="[f71c44]"></a>InitDSDMode</STRONG> (Thumb, 158 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = InitDSDMode -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[1004be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Choose
<LI><a href="#[1004cdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[a60238]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[fd9e98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
</UL>

<P><STRONG><a name="[f8d654]"></a>EepromWriteByte</STRONG> (Thumb, 52 bytes, Stack size 88 bytes, eeprom.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[100b4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b04014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b0f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[b0f2a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrModeSetup
<LI><a href="#[b0f328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b0f424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Z2MasterVolumeLevel
<LI><a href="#[b0f4a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TriggerSetup
<LI><a href="#[b0faf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[b0fb70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[b0fbec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[b0fc6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[b0fce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b0fd64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[b0fde4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
<LI><a href="#[b0fe60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b0fee0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[b0ffdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[b10154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMaxVolumeLevel
<LI><a href="#[b10254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RearIrModeSetup
<LI><a href="#[b102d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordSetup
<LI><a href="#[b1034c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordModeSetup
<LI><a href="#[b103cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
<LI><a href="#[b104c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[b1053c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[b10634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIInAudioSetup
<LI><a href="#[b106b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[b10730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CDPureAudio
<LI><a href="#[b1081c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[b10894]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[b10914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoInputSeekSetup
<LI><a href="#[b10994]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[b10a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
<LI><a href="#[b10a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[b22b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b22b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b23524]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b42848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f272b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[f4c208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f72cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8c084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[f8c854]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[f8def4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
<LI><a href="#[f8df6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAIS
<LI><a href="#[f8dfe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASTO
<LI><a href="#[f8e060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2M
<LI><a href="#[f8e0dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRM
<LI><a href="#[f8e158]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
<LI><a href="#[f8e1d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[f8e2cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
<LI><a href="#[f8e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[f8e3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
<LI><a href="#[f8e43c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASSP
<LI><a href="#[f8ebdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACNR
<LI><a href="#[f8ec58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[f8ecd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[f8ed50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[f8edcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[f8ee48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[f8eec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[f8ef40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[f8efbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[f8f038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[f8f0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[f8f130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[f8f1ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[f8f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[f8f2a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[f8f320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[f8f39c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[f8f418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[f8f594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[f8f610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[f8f68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[f8f708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[f8f784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[f8f800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[f8f87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[f8f8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
<LI><a href="#[f8fe54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[f8fed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[f8ff4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[f8ffc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[f90044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[f900c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[f9013c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[f901b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[f90234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[f902b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[f9032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[f903a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[f90be0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[f90c5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[f90cd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[f90d54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[f90dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[f90e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[f90ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[f90f3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[f91754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[f917d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[f9184c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[f918c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[f91944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[f919c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[f91a38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[f91ab0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[f92884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[f928fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[f92974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[f929ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[fb4740]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeValue
<LI><a href="#[fb47c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[fb4e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
<LI><a href="#[102ebb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FillEepromValue
</UL>

<P><STRONG><a name="[f8d6d0]"></a>EepromReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, eeprom.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = EepromReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[100b53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[b0f2a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrModeSetup
<LI><a href="#[b0f328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b0f424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Z2MasterVolumeLevel
<LI><a href="#[b0f4a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TriggerSetup
<LI><a href="#[b0faf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[b0fb70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[b0fbec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[b0fc6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[b0fce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[b0fd64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[b0fde4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
<LI><a href="#[b0fe60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[b0fee0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[b0ffdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[b10154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMaxVolumeLevel
<LI><a href="#[b10254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RearIrModeSetup
<LI><a href="#[b102d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordSetup
<LI><a href="#[b1034c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordModeSetup
<LI><a href="#[b103cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
<LI><a href="#[b104c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[b1053c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[b10634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIInAudioSetup
<LI><a href="#[b106b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[b10730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CDPureAudio
<LI><a href="#[b1081c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[b10894]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[b10914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoInputSeekSetup
<LI><a href="#[b10994]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[b10a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
<LI><a href="#[b10a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[b42848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f26760]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[f27328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadPwd
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f71674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsEverAutoseek
<LI><a href="#[f72c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAutoSeekOn
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8c574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[f8c8d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8cf94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[f8fa74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_
<LI><a href="#[f8faf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_
<LI><a href="#[f8fb6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_
<LI><a href="#[f8fbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_
<LI><a href="#[f8fc64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_
<LI><a href="#[f8fce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_
<LI><a href="#[f8fd5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_
<LI><a href="#[f8fdd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_
<LI><a href="#[f8fe54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[f8fed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[f8ff4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[f8ffc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[fb4554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fb4e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
<LI><a href="#[fb4f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[fb5324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[fb541c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[fb54a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[fb5598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerMode
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1004c60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
<LI><a href="#[102eb30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DebugEepromValue
</UL>

<P><STRONG><a name="[102ebb0]"></a>FillEepromValue</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, eeprom.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>

<P><STRONG><a name="[102eb30]"></a>DebugEepromValue</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, eeprom.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>

<P><STRONG><a name="[1004990]"></a>wait_timer</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, i2cdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[febafc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[1004d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[100b4c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[100b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102450c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
<LI><a href="#[1024a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
<LI><a href="#[102adac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[102ae28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[102b178]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[102b1f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102b270]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[102b2e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[102b360]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[105454c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[10545c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[10546c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[1054dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>

<P><STRONG><a name="[102ae28]"></a>I2CWriteNByte</STRONG> (Thumb, 128 bytes, Stack size 40 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102b1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102b270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[102b2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
</UL>
<BR>[Called By]<UL><LI><a href="#[10581b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[1058228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
</UL>

<P><STRONG><a name="[102adac]"></a>I2CReadNByte</STRONG> (Thumb, 184 bytes, Stack size 48 bytes, i2cdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102b178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[102b1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102b270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[102b2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[102b360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
</UL>

<P><STRONG><a name="[100b4c0]"></a>I2C_bytewrite</STRONG> (Thumb, 148 bytes, Stack size 48 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102b1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102b270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[102b2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d654]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f8d9bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fb4ab4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[100b7ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
</UL>

<P><STRONG><a name="[100b53c]"></a>I2C_byteread</STRONG> (Thumb, 188 bytes, Stack size 48 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102b178]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[102b1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102b270]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[102b2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[102b360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d6d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[100b730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>

<P><STRONG><a name="[b1b380]"></a>read165</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, ic165.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = read165</UL>
<BR>[Calls]<UL><LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[1026c5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort1
</UL>
<BR>[Called By]<UL><LI><a href="#[b1c8f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[102450c]"></a>Ext4094Sendbyte</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1023e98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094Cs
<LI><a href="#[1024a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[1024414]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>

<P><STRONG><a name="[1024490]"></a>Ext4094SetBit</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Ext4094SetBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[102450c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[102400c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[1024090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[1024114]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[1024198]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[102421c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[1024298]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[1024314]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[1024390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[1024414]"></a>Ext4094ClearBit</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[102450c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[102400c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[1024090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[1024114]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[1024198]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[102421c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[1024298]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[1024314]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[1024390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[1024390]"></a>Set_SLSR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_SLSR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1023f88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
</UL>

<P><STRONG><a name="[1024314]"></a>Set_HDMI_ISR</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_HDMI_ISR -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[f71e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
</UL>

<P><STRONG><a name="[1024298]"></a>Set_HDMI_RST</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[102421c]"></a>Set_UART_SEL</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_UART_SEL -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[f71e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
</UL>

<P><STRONG><a name="[1024198]"></a>Set_Zone2_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_Zone2_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[1024114]"></a>Set_FLFR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_FLFR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1023f88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
</UL>

<P><STRONG><a name="[1024090]"></a>Set_CENLFE_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_CENLFE_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1023f88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
</UL>

<P><STRONG><a name="[102400c]"></a>Set_SBLSBR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1024414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[1024490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1023f88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
</UL>

<P><STRONG><a name="[1023f88]"></a>Set_Mas9116_HardMute</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, ic4094.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[102400c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[1024090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[1024114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[1024390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[f71bc8]"></a>LPC2132HwReset</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = LPC2132HwReset -> Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1024298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
</UL>
<BR>[Called By]<UL><LI><a href="#[f71e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[f71dac]"></a>IC4094_Default</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = IC4094_Default -> Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1023e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094OE
<LI><a href="#[102400c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[1024090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[1024114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[1024198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[102421c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[1024298]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[1024314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[1024390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[f71e28]"></a>HDMI_Software_Update</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = HDMI_Software_Update -> LPC2132HwReset -> Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f262f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[f71bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[102421c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[1024314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fb4848]"></a>SetIoport0</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f421a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[fb53a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay
<LI><a href="#[1004d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[1004dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
<LI><a href="#[103e680]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[103eb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[105454c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[10545c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[10546c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[1054dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>

<P><STRONG><a name="[103eff8]"></a>SensePort0</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103da70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SenseDspBusy
<LI><a href="#[103daec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[10546c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
</UL>

<P><STRONG><a name="[1004af8]"></a>SetIoport1</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1b380]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read165
<LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[1004dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
<LI><a href="#[103e680]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[103eb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[105454c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[10545c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[10546c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[1054dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>

<P><STRONG><a name="[1026c5c]"></a>SensePort1</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1b380]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read165
</UL>

<P><STRONG><a name="[1004a80]"></a>SetIoport2</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[1004d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[103eb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
</UL>

<P><STRONG><a name="[103ef80]"></a>SensePort2</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[103ef08]"></a>SetIoport3</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[103ee90]"></a>SensePort3</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[1004a08]"></a>SetIoport4</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[1004dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
<LI><a href="#[103eb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
</UL>

<P><STRONG><a name="[103ee18]"></a>SensePort4</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[f716fc]"></a>SystemPower</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[f71b50]"></a>PowerLed</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b428cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LedStandby
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[b428cc]"></a>LedStandby</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LedStandby</UL>
<BR>[Calls]<UL><LI><a href="#[f71b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[103ed2c]"></a>InitPower</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f4bf24]"></a>HDRadioPower</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f4c208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8c9c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[103ecac]"></a>InitHDRaidoPower</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f717f0]"></a>SetResetPin</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[103ebb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemReset
</UL>

<P><STRONG><a name="[103ec30]"></a>InitResetPin</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103ebb8]"></a>SystemReset</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, ioport.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f717f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetResetPin
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>

<P><STRONG><a name="[103eb44]"></a>InitDac</STRONG> (Thumb, 122 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitDac</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[1004a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103ea54]"></a>SetMas9116Cs0</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e6f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[103e9d8]"></a>SetMas9116Cs1</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e6f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[103e95c]"></a>SetMas9116Cs2</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e6f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[103e8e0]"></a>SetMas9116Cs3</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e6f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[103e864]"></a>SetMas9116Cs4</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e6f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[103e7e8]"></a>SetMas9116Cs5</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e6f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[103e6f8]"></a>SelectMas9116</STRONG> (Thumb, 314 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SelectMas9116</UL>
<BR>[Calls]<UL><LI><a href="#[103e7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[103e864]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[103e8e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[103e95c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[103e9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[103ea54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
</UL>
<BR>[Called By]<UL><LI><a href="#[105454c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[10545c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[103e680]"></a>InitMas9116</STRONG> (Thumb, 78 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMas9116</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103e604]"></a>SetMax335Data</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[febafc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[103e0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
</UL>

<P><STRONG><a name="[103e588]"></a>SetMax335Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[febafc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[103e0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
</UL>

<P><STRONG><a name="[103e50c]"></a>SetMax335Cs1</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e490]"></a>SetMax335Cs2</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e414]"></a>SetMax335Cs3</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e398]"></a>SetMax335Cs4</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e31c]"></a>SetMax335Cs5</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e2a0]"></a>SetMax335Cs6</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e224]"></a>SetMax335Cs7</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e1a8]"></a>SetMax335Cs8</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[103e12c]"></a>SelectMax335</STRONG> (Thumb, 144 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SelectMax335</UL>
<BR>[Calls]<UL><LI><a href="#[103e1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs8
<LI><a href="#[103e224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs7
<LI><a href="#[103e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs6
<LI><a href="#[103e31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs5
<LI><a href="#[103e398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs4
<LI><a href="#[103e414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs3
<LI><a href="#[103e490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs2
<LI><a href="#[103e50c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs1
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c1f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
</UL>

<P><STRONG><a name="[103e0b4]"></a>InitMAS335</STRONG> (Thumb, 72 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMAS335</UL>
<BR>[Calls]<UL><LI><a href="#[103e588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[103e604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[fb49c4]"></a>Set7CH1Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0fb70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[f71ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[f72d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[103dfbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[103e038]"></a>SetZone2Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f4bc2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[103dfbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[f719dc]"></a>SetBalance_Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f71ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[f72d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[103dfbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[f718e4]"></a>SetHeadphoneMute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f71ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[f72d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[103dfbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[f4bc2c]"></a>Zone2Mute</STRONG> (Thumb, 26 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone2Mute</UL>
<BR>[Calls]<UL><LI><a href="#[103e038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[103dfbc]"></a>InitMuteControl</STRONG> (Thumb, 72 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMuteControl</UL>
<BR>[Calls]<UL><LI><a href="#[f718e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[f719dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
<LI><a href="#[fb49c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[103e038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f71ad0]"></a>PowerOffMuteControl</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = PowerOffMuteControl</UL>
<BR>[Calls]<UL><LI><a href="#[f718e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[f719dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
<LI><a href="#[fb49c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>

<P><STRONG><a name="[103df48]"></a>Init165</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[b1b3f4]"></a>SenseEncoderSwitchPlus</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1b5ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
</UL>

<P><STRONG><a name="[b1b478]"></a>SenseEncoderSwitchMinus</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1b5ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
</UL>

<P><STRONG><a name="[103dec8]"></a>InitEncoderSwitch</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f72238]"></a>DSP_Input_Stream_Select</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[103de44]"></a>Init_Dsp_Input_Select</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1004b70]"></a>DSD_Select</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1004be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Choose
</UL>

<P><STRONG><a name="[103ddc8]"></a>Init_DSD_Select</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103dd48]"></a>SenseAnalogSignal</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[fe7a74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
</UL>

<P><STRONG><a name="[1023e98]"></a>Set4094Cs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[102450c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>

<P><STRONG><a name="[1023e20]"></a>Set4094OE</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f71dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[1023da8]"></a>SetData4094</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1024a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>

<P><STRONG><a name="[1023f10]"></a>Set4094Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1024a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>

<P><STRONG><a name="[103dcd0]"></a>Init4094</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103dc58]"></a>SetDspReset</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103db64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
</UL>

<P><STRONG><a name="[103dbdc]"></a>InitDspResetPin</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103db64]"></a>DSPHwReset</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DSPHwReset</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[103dc58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspReset
</UL>
<BR>[Called By]<UL><LI><a href="#[f117b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
<LI><a href="#[107b37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>

<P><STRONG><a name="[103daec]"></a>SenseDspIrq</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[103eff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[fcbf6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[fd0138]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[107b37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[10e2ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
</UL>

<P><STRONG><a name="[103da70]"></a>SenseDspBusy</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SenseDspBusy</UL>
<BR>[Calls]<UL><LI><a href="#[103eff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[103d9f8]"></a>Set_Spi_Cs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[103d808]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
</UL>

<P><STRONG><a name="[103d980]"></a>Set_Spi_Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[fd0138]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[fd01b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[103d808]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
</UL>

<P><STRONG><a name="[103d904]"></a>Set_Spi_MOSI</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fd01b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[103d808]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
</UL>

<P><STRONG><a name="[103d888]"></a>Sense_Spi_MISO</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fd0138]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
</UL>

<P><STRONG><a name="[103d808]"></a>Init_Dsp_Spi_Pin</STRONG> (Thumb, 64 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Init_Dsp_Spi_Pin</UL>
<BR>[Calls]<UL><LI><a href="#[103d904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_MOSI
<LI><a href="#[103d980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[103d9f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[100b2e8]"></a>set_sda</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[100b35c]"></a>set_scl</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[100b3d0]"></a>sense_sda</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[100b448]"></a>sense_scl</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[103d790]"></a>set_vfd_sda</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[103d718]"></a>set_vfd_scl</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[103d69c]"></a>sense_vfd_sda</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[103d620]"></a>sense_vfd_scl</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[102e950]"></a>set_sda1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[102e9c8]"></a>set_scl1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[102ea40]"></a>sense_sda1</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[102eab8]"></a>sense_scl1</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[103d5a8]"></a>set_sda2</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[103d530]"></a>set_scl2</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[103d4b8]"></a>sense_sda2</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[103d440]"></a>sense_scl2</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[103d3c4]"></a>set_sda_hdmi</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[103d348]"></a>set_scl_hdmi</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d1d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[103d2cc]"></a>sense_sda_hdmi</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[103d250]"></a>sense_scl_hdmi</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[103d1d8]"></a>I2cPinInit</STRONG> (Thumb, 172 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = I2cPinInit</UL>
<BR>[Calls]<UL><LI><a href="#[100b2e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda
<LI><a href="#[100b35c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl
<LI><a href="#[102e950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda1
<LI><a href="#[102e9c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl1
<LI><a href="#[103d348]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl_hdmi
<LI><a href="#[103d3c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda_hdmi
<LI><a href="#[103d530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl2
<LI><a href="#[103d5a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda2
<LI><a href="#[103d718]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_vfd_scl
<LI><a href="#[103d790]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_vfd_sda
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[103d160]"></a>EnableEint0</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[103d0e4]"></a>DisableEint0</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[103d06c]"></a>EnableEint1</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8c008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[103cff0]"></a>DisableEint1</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8c008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[103cf78]"></a>EnableEint2</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8be14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
</UL>

<P><STRONG><a name="[103cefc]"></a>DisableEint2</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8be14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
</UL>

<P><STRONG><a name="[103ce84]"></a>EnableEint3</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8c008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[103ce08]"></a>DisableEint3</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8c008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[f8c008]"></a>Zone1SelectIr</STRONG> (Thumb, 110 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone1SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[103ce08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint3
<LI><a href="#[103ce84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint3
<LI><a href="#[103cff0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint1
<LI><a href="#[103d06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint1
</UL>
<BR>[Called By]<UL><LI><a href="#[b1053c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[f8e1d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[103cd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;remote_config
</UL>

<P><STRONG><a name="[103cd8c]"></a>remote_config</STRONG> (Thumb, 60 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = remote_config -> Zone1SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[f8c008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f8be14]"></a>Zone2SelectIr</STRONG> (Thumb, 92 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone2SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[103cefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint2
<LI><a href="#[103cf78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint2
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[f8e158]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
</UL>

<P><STRONG><a name="[b426dc]"></a>SetIoStandby</STRONG> (Thumb, 180 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SetIoStandby</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[1004a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[103e1a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs8
<LI><a href="#[103e224]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs7
<LI><a href="#[103e2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs6
<LI><a href="#[103e31c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs5
<LI><a href="#[103e398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs4
<LI><a href="#[103e414]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs3
<LI><a href="#[103e490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs2
<LI><a href="#[103e50c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs1
<LI><a href="#[103e588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[103e604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
<LI><a href="#[103e7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[103e864]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[103e8e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[103e95c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[103e9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[103ea54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>

<P><STRONG><a name="[f71868]"></a>SetIoPowerOn</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[a601bc]"></a>HardwareInit</STRONG> (Thumb, 90 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = HardwareInit -> SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f716fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[f71774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[103cd8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;remote_config
<LI><a href="#[103d1d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
<LI><a href="#[103d808]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
<LI><a href="#[103dbdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDspResetPin
<LI><a href="#[103dcd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init4094
<LI><a href="#[103ddc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_DSD_Select
<LI><a href="#[103de44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Input_Select
<LI><a href="#[103dec8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitEncoderSwitch
<LI><a href="#[103df48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init165
<LI><a href="#[103dfbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[103e0b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
<LI><a href="#[103e680]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[103eb44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[103ec30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitResetPin
<LI><a href="#[103ecac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitHDRaidoPower
<LI><a href="#[103ed2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitPower
</UL>
<BR>[Called By]<UL><LI><a href="#[a60588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[103f070]"></a>exint3</STRONG> (ARM, 200 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint3 -> ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[103cc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[103eda4]"></a>exint2</STRONG> (ARM, 236 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint2 -> ir2_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[103cd0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[103ead0]"></a>exint1</STRONG> (ARM, 236 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint1 -> ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[103cc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[103e774]"></a>exint0</STRONG> (ARM, 200 bytes, Stack size 40 bytes, ioport.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[103cc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>

<P><STRONG><a name="[1050088]"></a>repeat_IRkey_allowed</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, ir.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[103cc90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips
</UL>

<P><STRONG><a name="[a600c0]"></a>InitRemoteRepeatKey</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = InitRemoteRepeatKey</UL>
<BR>[Calls]<UL><LI><a href="#[111211c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[a60418]"></a>AddRemoteRepeatKey</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = AddRemoteRepeatKey</UL>
<BR>[Calls]<UL><LI><a href="#[1050088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;repeat_IRkey_allowed
</UL>
<BR>[Called By]<UL><LI><a href="#[a60588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
<LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f26c48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
</UL>

<P><STRONG><a name="[f26468]"></a>DeleteRemoteRepeatKey</STRONG> (Thumb, 102 bytes, Stack size 4 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = DeleteRemoteRepeatKey</UL>
<BR>[Called By]<UL><LI><a href="#[f267dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[f26adc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[f8c9c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
</UL>

<P><STRONG><a name="[1050000]"></a>zone2_repeat_IRkey_allowed</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ir.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103cc90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips
<LI><a href="#[103cd0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips
</UL>

<P><STRONG><a name="[103cc90]"></a>ir_core_philips</STRONG> (Thumb, 714 bytes, Stack size 48 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[1050000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;zone2_repeat_IRkey_allowed
<LI><a href="#[1050088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;repeat_IRkey_allowed
<LI><a href="#[11b4bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[11b51a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11bb13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[103e774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint0 (via Veneer)
<LI><a href="#[103ead0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint1 (via Veneer)
<LI><a href="#[103f070]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint3 (via Veneer)
</UL>

<P><STRONG><a name="[103cd0c]"></a>ir2_core_philips</STRONG> (Thumb, 622 bytes, Stack size 48 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ir2_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[1050000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;zone2_repeat_IRkey_allowed
<LI><a href="#[11b4bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[11b51a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11bb13c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[103eda4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint2 (via Veneer)
</UL>

<P><STRONG><a name="[f8da38]"></a>DelayMs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[b101d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[b428cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LedStandby
<LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[f26a58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f715fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[f71964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[f71bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f72724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72df0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f73260]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8d74c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[f8de7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[fcbf6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[fe7a74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[ff6488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[100b634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[103db64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[103ebb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemReset
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[107b0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
<LI><a href="#[107b37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
<LI><a href="#[109fc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
<LI><a href="#[10e2ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
</UL>

<P><STRONG><a name="[b425e8]"></a>Timer0_Handler</STRONG> (Thumb, 214 bytes, Stack size 8 bytes, timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 976 + Unknown Stack Size
<LI>Call Chain = Timer0_Handler -> RadioDisplay -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1b574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;key_task
<LI><a href="#[b1b5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
<LI><a href="#[f15768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[f265e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupFlashHandler
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[ff6110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[ff6488]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[ff6588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[10451f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b42664]"></a>Timer0Init</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[104526c]"></a>timer0_irq</STRONG> (ARM, 752 bytes, Stack size 24 bytes, timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = timer0_irq -> RefreshHandle -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f732d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RefreshHandle (via Veneer)
<LI><a href="#[f733cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetSoftMute (via Veneer)
<LI><a href="#[f734c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting (via Veneer)
<LI><a href="#[f7e670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTimerHandler (via Veneer)
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> timer.o(.text)
</UL>
<P><STRONG><a name="[1058228]"></a>VfdSendNByte</STRONG> (Thumb, 56 bytes, Stack size 88 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[102ae28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f7e578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>

<P><STRONG><a name="[10581b0]"></a>VfdSendByte</STRONG> (Thumb, 52 bytes, Stack size 80 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[102ae28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b42478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[f7e578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>

<P><STRONG><a name="[f7e578]"></a>VfdUpdateBuffer</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10581b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[1058228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b424f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
<LI><a href="#[f26278]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f8c0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[fb45d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>

<P><STRONG><a name="[b42478]"></a>VfdSetDimerValue</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = VfdSetDimerValue -> VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10581b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[a6050c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10546c4]"></a>Mas9116Read</STRONG> (Thumb, 176 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Mas9116Read</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[103eff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[105454c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
</UL>

<P><STRONG><a name="[1054644]"></a>CalcMas9116Volume</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[11b3a88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[11b954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10545c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[10545c8]"></a>Mas9116SetGain</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[103e6f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1054644]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume
<LI><a href="#[1054dd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[f8c7d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[fb46c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[ff16e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume
</UL>

<P><STRONG><a name="[105454c]"></a>Mas9116ReadRC5</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Mas9116ReadRC5 -> Mas9116Read</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[103e6f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[10546c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
</UL>
<BR>[Called By]<UL><LI><a href="#[f715fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>

<P><STRONG><a name="[10544d0]"></a>Mas9116Reset</STRONG> (Thumb, 138 bytes, Stack size 8 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Mas9116Reset -> Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[103e7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[103e864]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[103e8e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[103e95c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[103e9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[103ea54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
<LI><a href="#[1054dd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>
<BR>[Called By]<UL><LI><a href="#[f715fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[fb464c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>

<P><STRONG><a name="[fb46c4]"></a>SetZone2Volume</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = SetZone2Volume -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[10545c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fb4ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
</UL>

<P><STRONG><a name="[f8c7d8]"></a>Set2ChVolume</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Set2ChVolume -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[10545c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8f0b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[f8f130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[f8f1ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[f8f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[f8f2a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[f8f320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[f8f39c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[f8f418]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[fb5028]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel
</UL>

<P><STRONG><a name="[f8c758]"></a>SetBalanceVolume</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[10545c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[11b954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b04014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b0ffdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[b22b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b22b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[f90be0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[f90c5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[f90cd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[f90d54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[f90dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[f90e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[f90ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[f90f3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[f92884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[f928fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[f92974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[f929ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[fb4944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fb54a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
</UL>

<P><STRONG><a name="[fb4944]"></a>Set7Ch1MainVolume</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = Set7Ch1MainVolume -> SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[f8c758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f26adc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[f42908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fb4e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
<LI><a href="#[fb4f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[ff16e0]"></a>AutoSoundSetVolume</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, volume.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10545c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>

<P><STRONG><a name="[fb464c]"></a>SoftMute</STRONG> (Thumb, 152 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = SoftMute -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[102400c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[1024090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[1024114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[1024390]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
<LI><a href="#[10544d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[105454c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
</UL>
<BR>[Called By]<UL><LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f72334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[f725b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[f72724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f727a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fd9e98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[f715fc]"></a>VolumeInit</STRONG> (Thumb, 116 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = VolumeInit -> Mas9116ReadRC5 -> Mas9116Read</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10544d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[105454c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
</UL>
<BR>[Called By]<UL><LI><a href="#[f72e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[febafc]"></a>Max335SendByte</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[103e588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[103e604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c1f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
</UL>

<P><STRONG><a name="[f8c5ec]"></a>SetMax335Switch</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SetMax335Switch</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f723b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[f72434]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8bf0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[fb4554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fe79fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[ff5f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>

<P><STRONG><a name="[f8c1f4]"></a>UpdateMax335</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[febafc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[103e12c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f723b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[f72434]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[f8bf0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[fb4554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fe79fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[ff5f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>

<P><STRONG><a name="[f8d9bc]"></a>DigiSendByte</STRONG> (Thumb, 52 bytes, Stack size 88 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[100b4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[f71774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[fe7af0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2DigiSelectChannel
<LI><a href="#[fe7b74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelectChannel
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[f71774]"></a>SetTrigerOut</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a601bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[f4c28c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[f72a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[fe7b74]"></a>DigitalInSelectChannel</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fe89f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[fe7af0]"></a>Zone2DigiSelectChannel</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fb4554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
</UL>

<P><STRONG><a name="[fe7a74]"></a>CheckAnalogIn</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CheckAnalogIn</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[103dd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseAnalogSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[fe89f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[fe79fc]"></a>AnalogInOff</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInOff -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[f71674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[f722bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[fe7974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSelectInputChannel
</UL>

<P><STRONG><a name="[f8bf0c]"></a>Zone2AnalogInOff</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Zone2AnalogInOff -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fb4554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
</UL>

<P><STRONG><a name="[ff5f10]"></a>AnalogInSelectChannel</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInSelectChannel -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fe89f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fb4554]"></a>Zone2SelectChannel</STRONG> (Thumb, 232 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = Zone2SelectChannel -> Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8bf0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[fe7af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2DigiSelectChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f4c208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[f4c30c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
</UL>

<P><STRONG><a name="[f723b0]"></a>AnalogInputTypeSelect</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInputTypeSelect -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f42908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[fe89f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[f72434]"></a>Analog7CH1OutSelectChannel</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Analog7CH1OutSelectChannel -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fe89f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fe7974]"></a>SystemSelectInputChannel</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, channel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fe79fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[fe89f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[f71674]"></a>SystemSearchInputChannel</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fe79fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[fe89f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[f72a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[f722bc]"></a>CheckInput</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = CheckInput -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fe79fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[fe89f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[f72b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
</UL>

<P><STRONG><a name="[ff5e00]"></a>Tuner_Req_Radio_Monitor_Command</STRONG> (Thumb, 140 bytes, Stack size 40 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Tuner_Req_Radio_Monitor_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[ff6194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[fe1a90]"></a>Tuner_Band_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Band_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[ff5d00]"></a>Tuner_Req_Tune_Up</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Req_Tune_Up</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff5d80]"></a>Tuner_Req_Tune_Down</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Req_Tune_Down</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fe1a14]"></a>Tuner_Stop_Seek</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Tuner_Stop_Seek</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[ff5c80]"></a>Tuner_Seek_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Seek_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff5e8c]"></a>Tuner_HDSEEK_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_HDSEEK_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[f4bdac]"></a>Tuner_Mute_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Mute_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f4bd2c]"></a>Tuner_Volume_Init</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Tuner_Volume_Init</UL>
<BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fe1998]"></a>Tuner_Ext_Reset</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, tuner.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>

<P><STRONG><a name="[fe191c]"></a>Tuner_Req_Freq</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tuner.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>

<P><STRONG><a name="[fe18a0]"></a>FreqCheckSum</STRONG> (Thumb, 28 bytes, Stack size 4 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = FreqCheckSum</UL>
<BR>[Called By]<UL><LI><a href="#[f4bca4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
</UL>

<P><STRONG><a name="[f4bca4]"></a>Tuner_Write_Freq_Command</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36 + Unknown Stack Size
<LI>Call Chain = Tuner_Write_Freq_Command -> FreqCheckSum</UL>
<BR>[Calls]<UL><LI><a href="#[fe18a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FreqCheckSum
<LI><a href="#[1015648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
<LI><a href="#[111040c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f4be2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
</UL>

<P><STRONG><a name="[f4be2c]"></a>InitTuner</STRONG> (Thumb, 250 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = InitTuner -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f4bca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fe1a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Stop_Seek
<LI><a href="#[fe1a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Band_Command
<LI><a href="#[ff5c80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[ff5e8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
</UL>
<BR>[Called By]<UL><LI><a href="#[f8be90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fb4ab4]"></a>HdmiSendByte</STRONG> (Thumb, 52 bytes, Stack size 88 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[100b4c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f71eac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[f8c6dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
</UL>

<P><STRONG><a name="[f8d27c]"></a>HdmiReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = HdmiReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[100b53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60238]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fd9e98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[fd9f10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[f71eac]"></a>HDMI_Port_Select</STRONG> (Thumb, 112 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = HDMI_Port_Select -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb4ab4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[f8c948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff640c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fd9f10]"></a>HDMI_Loop</STRONG> (Thumb, 168 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = HDMI_Loop -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>
<BR>[Called By]<UL><LI><a href="#[a60238]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[fd9e98]"></a>DSD_Loop</STRONG> (Thumb, 212 bytes, Stack size 16 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DSD_Loop -> HdmiReadByte -> I2C_byteread -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f71c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>
<BR>[Called By]<UL><LI><a href="#[a60238]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[fd9e20]"></a>HDMI_Busy</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = HDMI_Busy -> DSP_API_Read -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fd9da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
</UL>
<BR>[Called By]<UL><LI><a href="#[a60238]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[a60238]"></a>HDMI_DSD_Loop</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = HDMI_DSD_Loop -> HDMI_Loop -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f71c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[fd9e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Busy
<LI><a href="#[fd9e98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[fd9f10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[fcf988]"></a>Delay_SPI</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dsp_spi.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>

<P><STRONG><a name="[fcf908]"></a>DspSpiWriteNByte</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fd01b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[103d980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[103d9f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
<LI><a href="#[103da70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[f42030]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[f420a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[f71fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[f72124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO
<LI><a href="#[f721b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_MULTI
<LI><a href="#[fb4ca4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[fc687c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[fc690c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[fc699c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[fc6a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[fc6aac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[fc6b38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[fc6bc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[fc6c48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[fc6cd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[fc6d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[fc6de0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[fc6e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[fc6ef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[fc6f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
<LI><a href="#[fc7004]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER
<LI><a href="#[fc7084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_HPF_CONTROL
<LI><a href="#[fc710c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_5XOVER_CONTROL
<LI><a href="#[fc7194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
<LI><a href="#[fd9da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
<LI><a href="#[fe78f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[107a3cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[107a458]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
<LI><a href="#[107a55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Speaker_Select
<LI><a href="#[107a5e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Control
<LI><a href="#[107a6e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[107a764]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[107a7ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[107a8f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE
<LI><a href="#[107a978]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Channel
<LI><a href="#[107a9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Test_Duration
<LI><a href="#[107aa78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[107aaf8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107ab78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107abf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[107ac6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[107ace8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[107af78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DTS_HD_HRA_Read
<LI><a href="#[107aff8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDTSHDChannel
<LI><a href="#[1091c68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolbyPLIIX
<LI><a href="#[1091ce8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DIMENSION_CONFIGURATION
<LI><a href="#[1091d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1091e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CNOTROL_REGISTER
<LI><a href="#[1091e94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_Control
<LI><a href="#[1095258]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION
<LI><a href="#[10952e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1095378]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CONTROL_REGISTER
<LI><a href="#[1095400]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[1095484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
<LI><a href="#[10987f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadRegist
<LI><a href="#[109886c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadCrossbar
<LI><a href="#[10988e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolby
<LI><a href="#[10989e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[1098a60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[1098adc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
<LI><a href="#[1098b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_STEREO_MODE_CONTROL
<LI><a href="#[1098bec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_Control
<LI><a href="#[109fbe4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDelay
<LI><a href="#[109fce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DLYAUXCNTL
<LI><a href="#[109fd60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EXT_BUFF_SIZE
<LI><a href="#[109fde0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EXT_BUFF_ADDR
<LI><a href="#[109fe60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Max_Setting
<LI><a href="#[109fee4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Unit
<LI><a href="#[109ff60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_MAIN_PPM_CONTROL
<LI><a href="#[10ba9e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10baa60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode_Pl2x
<LI><a href="#[10baae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[10bab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_OUTPUT_FS
<LI><a href="#[10be240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Decode_Mode_Control
<LI><a href="#[10be2cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Control
<LI><a href="#[10cb084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadSgen
<LI><a href="#[10cb0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CHANNEL_SIGNAL_SELECT
<LI><a href="#[10d06b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadOS
<LI><a href="#[10d0730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB_Debug
<LI><a href="#[10d07c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_Debug
<LI><a href="#[10d3024]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Max_EQ_Fc
<LI><a href="#[10d8bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC_1_Test_Signal
<LI><a href="#[10d8c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Tx_Channel
<LI><a href="#[10d8ccc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Gain
<LI><a href="#[10d8d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC_1_Control
<LI><a href="#[10e2ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[10e2fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[10e3064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_POSTGAIN
<LI><a href="#[10e30e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CH_PREATTENUATION
<LI><a href="#[10e3168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Flash
<LI><a href="#[10e31e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Bands
<LI><a href="#[10e3260]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Channels
<LI><a href="#[10e32dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Config
<LI><a href="#[10e3358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>

<P><STRONG><a name="[fcf88c]"></a>DspSpiReadNByte</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fcf988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Delay_SPI
<LI><a href="#[fd0138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[fd01b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[103d980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[103d9f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
<LI><a href="#[103daec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[fcbf6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[107b3f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
<LI><a href="#[10e2ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
</UL>

<P><STRONG><a name="[fc7214]"></a>ConvertDbValue</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[11b1dd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pow (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[11bdfa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc687c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[fc690c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[fc699c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[fc6a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[fc6aac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[fc6b38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[fc6bc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[fc6c48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[fc6cd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[fc6d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[fc6de0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[fc6e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[fc6ef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[fc6f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
</UL>

<P><STRONG><a name="[fc7194]"></a>DSP_BASS_CONTROL</STRONG> (Thumb, 174 bytes, Stack size 40 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6714]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BassOn
<LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc710c]"></a>DSP_BASS_MGR_5XOVER_CONTROL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_MGR_5XOVER_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc7084]"></a>DSP_BASS_MGR_HPF_CONTROL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_MGR_HPF_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc7004]"></a>DSP_SET_BASS_CORNER</STRONG> (Thumb, 304 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_SET_BASS_CORNER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb48c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>

<P><STRONG><a name="[fc6f80]"></a>DSP_BASS_INPUT_LEVEL</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_INPUT_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6ef8]"></a>DSP_BASS_LFE_OUTPUT_LEVEL</STRONG> (Thumb, 206 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_LFE_OUTPUT_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6e6c]"></a>DSP_BASS_FRONT_SUM_OUTPUT_LEVEL</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_FRONT_SUM_OUTPUT_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6de0]"></a>DSP_BASS_BACK_SUM_OUTPUT_LEVEL</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_BACK_SUM_OUTPUT_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6d58]"></a>DSP_BASS_SUM1_INPUT_LEVEL</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_SUM1_INPUT_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6cd0]"></a>DSP_BASS_SUM2_INPUT_LEVEL</STRONG> (Thumb, 160 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_SUM2_INPUT_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6c48]"></a>DSP_BASS_SUM3_INPUT_LEVLE</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_SUM3_INPUT_LEVLE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6bc0]"></a>DSP_BASS_SUM4_INPUT_LEVLE</STRONG> (Thumb, 174 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_SUM4_INPUT_LEVLE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6b38]"></a>DSP_BASS_SUM5_INPUT_LEVLE</STRONG> (Thumb, 190 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_SUM5_INPUT_LEVLE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6aac]"></a>DSP_BASS_X_INPUT_LEVEL_FRONT</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_X_INPUT_LEVEL_FRONT -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6a24]"></a>DSP_BASS_X_INPUT_LEVEL_BACK</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_X_INPUT_LEVEL_BACK -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc699c]"></a>DSP_BASS_INPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_INPUT_SUB_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc690c]"></a>DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc687c]"></a>DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc7214]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6800]"></a>ConfigSpkMode</STRONG> (Thumb, 512 bytes, Stack size 48 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc6788]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[fc6788]"></a>C11SetBass</STRONG> (Thumb, 584 bytes, Stack size 24 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc6800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode
<LI><a href="#[fc687c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[fc690c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[fc699c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[fc6a24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[fc6aac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[fc6b38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[fc6bc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[fc6c48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[fc6cd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[fc6d58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[fc6de0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[fc6e6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[fc6ef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[fc6f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
<LI><a href="#[fc7084]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_HPF_CONTROL
<LI><a href="#[fc710c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_5XOVER_CONTROL
<LI><a href="#[fc7194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[fb48c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>

<P><STRONG><a name="[fc6714]"></a>BassOn</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, bassmanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fc7194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
</UL>

<P><STRONG><a name="[fb48c0]"></a>SetBassManagerSpeaker</STRONG> (Thumb, 206 bytes, Stack size 8 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 848 + Unknown Stack Size
<LI>Call Chain = SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fc6788]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
<LI><a href="#[fc7004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER
</UL>
<BR>[Called By]<UL><LI><a href="#[f116b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSpkMode
<LI><a href="#[f11920]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[fb541c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
</UL>

<P><STRONG><a name="[109ff60]"></a>DSP_MAIN_PPM_CONTROL</STRONG> (Thumb, 152 bytes, Stack size 32 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_MAIN_PPM_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[109fc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>

<P><STRONG><a name="[109fee4]"></a>DSP_Delay_Unit</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[fb4ca4]"></a>DSP_Delay_Channel_Setting</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f118a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay
<LI><a href="#[f8db20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[fb551c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode
<LI><a href="#[109fc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>

<P><STRONG><a name="[109fe60]"></a>DSP_Delay_Max_Setting</STRONG> (Thumb, 182 bytes, Stack size 24 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[109fde0]"></a>DSP_EXT_BUFF_ADDR</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109fd60]"></a>DSP_EXT_BUFF_SIZE</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109fce4]"></a>DSP_DLYAUXCNTL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109fc60]"></a>DSP_Delay_Firmware_Init</STRONG> (Thumb, 104 bytes, Stack size 8 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = DSP_Delay_Firmware_Init -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb4ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[109ff60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_MAIN_PPM_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[f8db20]"></a>DSP_AV_Delay</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = DSP_AV_Delay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb4ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
</UL>
<BR>[Called By]<UL><LI><a href="#[b10894]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f8e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[f8fe54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
</UL>

<P><STRONG><a name="[109fbe4]"></a>DspReadDelay</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1098bec]"></a>DSP_AC3_Control</STRONG> (Thumb, 140 bytes, Stack size 24 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1098b64]"></a>DSP_AC3_STEREO_MODE_CONTROL</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1098adc]"></a>DSP_AC3_COMPRESSION_CONTROL</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = DSP_AC3_COMPRESSION_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[1098964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[1098a60]"></a>DSP_AC3_CUT_X</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_AC3_CUT_X -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[1098964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[10989e4]"></a>DSP_AC3_BOOST_Y</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_AC3_BOOST_Y -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[1098964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[1098964]"></a>DSP_AC3_DRC_INIT</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = DSP_AC3_DRC_INIT -> DSP_AC3_BOOST_Y -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10989e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[1098a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[1098adc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>

<P><STRONG><a name="[10988e8]"></a>DspReadDolby</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109886c]"></a>DspReadCrossbar</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10987f0]"></a>DspReadRegist</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1095484]"></a>DSP_PLII_Control</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLII_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[10951d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Firmware_Cfg
</UL>

<P><STRONG><a name="[1095400]"></a>DSP_PLII_DECODE_MODE</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLII_DECODE_MODE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c3e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[f8c464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[f8c4f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[10951d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Firmware_Cfg
</UL>

<P><STRONG><a name="[1095378]"></a>DSP_PLII_CONTROL_REGISTER</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLII_CONTROL_REGISTER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
</UL>

<P><STRONG><a name="[10952e8]"></a>DSP_PLII_CENTER_WIDTH_CONFIGURATION</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLII_CENTER_WIDTH_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c3e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
</UL>

<P><STRONG><a name="[1095258]"></a>DSP_PLII_DIMENSION_CONFIGURATION</STRONG> (Thumb, 170 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLII_DIMENSION_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c4f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
</UL>

<P><STRONG><a name="[10951d4]"></a>DSP_PLII_Firmware_Cfg</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, dolbyprologicii.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1095400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[1095484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
</UL>

<P><STRONG><a name="[1091e94]"></a>DSP_PLIIx_Control</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[f72124]"></a>DSP_PLIIx_DECODE_MODE_STEREO</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLIIx_DECODE_MODE_STEREO -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f726a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
</UL>

<P><STRONG><a name="[1091e0c]"></a>DSP_PLIIx_CNOTROL_REGISTER</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1091d78]"></a>DSP_PLIIx_CENTER_WIDTH_CONFIGURATION</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1091ce8]"></a>DSP_PLIIx_DIMENSION_CONFIGURATION</STRONG> (Thumb, 170 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[f721b0]"></a>DSP_PLIIx_DECODE_MODE_MULTI</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_PLIIx_DECODE_MODE_MULTI -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f72534]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
</UL>

<P><STRONG><a name="[1091c68]"></a>DspReadDolbyPLIIX</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[108ce14]"></a>DispBuffer</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, dsp_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
</UL>

<P><STRONG><a name="[108cd98]"></a>DisplayBuffer</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = DisplayBuffer -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[108cd1c]"></a>ClearDspBuffer</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dsp_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[108cca0]"></a>AnalyseDspMsg</STRONG> (Thumb, 282 bytes, Stack size 24 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = AnalyseDspMsg -> DspProcUnsolicitedMsg -> ProcAutodetecResponse -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[108c928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
<LI><a href="#[108ca2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[108caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHRACfg
<LI><a href="#[108cb2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[108cba8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
<LI><a href="#[108cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
<LI><a href="#[108cd98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayBuffer
<LI><a href="#[1111cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a6032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[a6032c]"></a>DspLoop</STRONG> (Thumb, 226 bytes, Stack size 16 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 896 + Unknown Stack Size
<LI>Call Chain = DspLoop -> ProcInputSelect -> SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f72fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[f73448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDspChannel
<LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[fcf88c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[100b6b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
<LI><a href="#[103daec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[103dd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseAnalogSignal
<LI><a href="#[108cca0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
<LI><a href="#[108cd1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClearDspBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[f41eb0]"></a>ReConvert_8_24_Value</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ReConvert_8_24_Value</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
</UL>

<P><STRONG><a name="[f42120]"></a>ConvertBalanceValue</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ConvertBalanceValue -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11b7754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
</UL>

<P><STRONG><a name="[107b5f0]"></a>ArrayToDWORD</STRONG> (Thumb, 112 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[107b3f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>

<P><STRONG><a name="[107b574]"></a>ArrayToHWORD</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fcbf6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
</UL>

<P><STRONG><a name="[f8c3e4]"></a>Set_Prologic2Width</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = Set_Prologic2Width -> DSP_PLII_CENTER_WIDTH_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10952e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1095400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
</UL>
<BR>[Called By]<UL><LI><a href="#[b0faf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[f8fed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
</UL>

<P><STRONG><a name="[f8c4f0]"></a>Set_Prologic2Dimension</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = Set_Prologic2Dimension -> DSP_PLII_DIMENSION_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1095258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION
<LI><a href="#[1095400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fd64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[f8ffc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
</UL>

<P><STRONG><a name="[f8c464]"></a>Set_Prologic2Panorama_On_Or_Off</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = Set_Prologic2Panorama_On_Or_Off -> DSP_PLII_CONTROL_REGISTER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1095378]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CONTROL_REGISTER
<LI><a href="#[1095400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[1095484]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fbec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[f8ff4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
</UL>

<P><STRONG><a name="[f116b8]"></a>DspProcSpkMode</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb48c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>
<BR>[Called By]<UL><LI><a href="#[f11a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>

<P><STRONG><a name="[f118a4]"></a>DspProcDelay</STRONG> (Thumb, 312 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb4ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f11b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspDelay
</UL>

<P><STRONG><a name="[f11920]"></a>DspProcCorner</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb48c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f11b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspCorner
</UL>

<P><STRONG><a name="[f11734]"></a>DspProcSignal</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[107a878]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_ENABLE
<LI><a href="#[107a8f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE
</UL>
<BR>[Called By]<UL><LI><a href="#[f11a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
</UL>

<P><STRONG><a name="[f1182c]"></a>DspProcIrc</STRONG> (Thumb, 206 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DspProcIrc -> InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8daac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[107a4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
<LI><a href="#[107a55c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Speaker_Select
<LI><a href="#[107a5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Control
<LI><a href="#[107a978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Channel
<LI><a href="#[107a9f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Test_Duration
<LI><a href="#[107ade8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[f1199c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
</UL>

<P><STRONG><a name="[f71964]"></a>SetDh2On</STRONG> (Thumb, 182 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = SetDh2On -> Change_DSP_VIRTUALIZER_Code -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107ade8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[107b4f4]"></a>DspChannelOut5_1</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = DspChannelOut5_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[107a3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[107a458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[f720a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
</UL>

<P><STRONG><a name="[107b474]"></a>DspChannelOut7_1</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[107a3cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[107a458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[f720a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[107b0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[f720a0]"></a>DspChannelOutSetting</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DspChannelOutSetting -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[107b474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[107b4f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f7201c]"></a>DspLoadDefaultSetting</STRONG> (Thumb, 192 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 864 + Unknown Stack Size
<LI>Call Chain = DspLoadDefaultSetting -> SetBassManagerSpeaker -> C11SetBass -> ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f8db20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fb48c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[fb4c20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[107aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107ab78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[107ade8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[109fc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[107b3f8]"></a>CheckDspMessage</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 696 + Unknown Stack Size
<LI>Call Chain = CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fcf88c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[107b5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ArrayToDWORD
</UL>
<BR>[Called By]<UL><LI><a href="#[107b37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>

<P><STRONG><a name="[107b37c]"></a>DspMasterBoot</STRONG> (Thumb, 70 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 704 + Unknown Stack Size
<LI>Call Chain = DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[103daec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[103db64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[107b3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f117b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>

<P><STRONG><a name="[f117b0]"></a>DspProcPower</STRONG> (Thumb, 148 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 712 + Unknown Stack Size
<LI>Call Chain = DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[103db64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[107ad60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107b37c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>
<BR>[Called By]<UL><LI><a href="#[f11c00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
</UL>

<P><STRONG><a name="[fe78f4]"></a>DSPFirmwareWrite</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[fb4554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fc6800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode
<LI><a href="#[107a4dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
<LI><a href="#[107a878]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_ENABLE
<LI><a href="#[107b280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllMono
<LI><a href="#[107b2fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllStereo
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[107b2fc]"></a>SetMixerAllStereo</STRONG> (Thumb, 480 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = SetMixerAllStereo -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d74c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>

<P><STRONG><a name="[107b280]"></a>SetMixerAllMono</STRONG> (Thumb, 178 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d74c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>

<P><STRONG><a name="[f8d74c]"></a>DspSetCrossbarEffect</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107ade8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[107ae70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[107b280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllMono
<LI><a href="#[107b2fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllStereo
</UL>
<BR>[Called By]<UL><LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[f72534]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[f726a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
</UL>

<P><STRONG><a name="[f8d3ec]"></a>GetNormalFreq</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f726a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[f72724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f727a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[f72914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8f9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[f8d7d0]"></a>DspDecodePcm</STRONG> (Thumb, 420 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107aa78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[107abf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[107ae70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[107b474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[107b4f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[f72724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f727a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[f72914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[10451f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[f8d8c8]"></a>DspDecodeAc3</STRONG> (Thumb, 1046 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107a660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
<LI><a href="#[107aa78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[107aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107ab78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107abf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[107b474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1098964]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b23784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[f72898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[107b17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
<LI><a href="#[107b200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[107b200]"></a>AC3_Cfg_Change_Deal</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = AC3_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8d8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Called By]<UL><LI><a href="#[108cc24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
</UL>

<P><STRONG><a name="[108cc24]"></a>AnalyseAc3Cfg</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = AnalyseAc3Cfg -> AC3_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[107b200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[107b17c]"></a>TureHD_Cfg_Change_Deal</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = TureHD_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d8c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Called By]<UL><LI><a href="#[108ca2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
</UL>

<P><STRONG><a name="[108ca2c]"></a>AnalyseTureHDCfg</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = AnalyseTureHDCfg -> TureHD_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[107b17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[f8d84c]"></a>DspDecodeDTS</STRONG> (Thumb, 1068 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107aa78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[107aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107ab78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107abf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[107ac6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[107ade8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[107ae70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[107b474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b23a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ED
<LI><a href="#[f725b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[f7281c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[107b078]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
<LI><a href="#[107b0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[107b0fc]"></a>DTS_Cfg_Change_Deal</STRONG> (Thumb, 162 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = DTS_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f8d84c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107b474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
</UL>
<BR>[Called By]<UL><LI><a href="#[108cba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
</UL>

<P><STRONG><a name="[108cba8]"></a>AnalyseDtsCfg</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = AnalyseDtsCfg -> DTS_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[107b0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[107b078]"></a>DtsHD_Cfg_Change_Deal</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = DtsHD_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d84c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>
<BR>[Called By]<UL><LI><a href="#[108cb2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
</UL>

<P><STRONG><a name="[fcbf6c]"></a>ReadDsp</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = ReadDsp -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fcf88c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[103daec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[107b574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ArrayToHWORD
</UL>
<BR>[Called By]<UL><LI><a href="#[f42030]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[f420a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[f71fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[fd9da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
<LI><a href="#[107af78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DTS_HD_HRA_Read
<LI><a href="#[107aff8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDTSHDChannel
<LI><a href="#[1091c68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolbyPLIIX
<LI><a href="#[10987f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadRegist
<LI><a href="#[109886c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadCrossbar
<LI><a href="#[10988e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolby
<LI><a href="#[109fbe4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDelay
<LI><a href="#[10cb084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadSgen
<LI><a href="#[10d06b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadOS
</UL>

<P><STRONG><a name="[107aff8]"></a>DspReadDTSHDChannel</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, dspdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[108cb2c]"></a>AnalyseDtsHDCfg</STRONG> (Thumb, 464 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = AnalyseDtsHDCfg -> DtsHD_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[107b078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[108caac]"></a>AnalyseDtsHRACfg</STRONG> (Thumb, 146 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = AnalyseDtsHRACfg -> MsgSetStream -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[107af78]"></a>DSP_DTS_HD_HRA_Read</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dspdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10451f0]"></a>lpcm_20_config</STRONG> (Thumb, 98 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = lpcm_20_config -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[f8d7d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[100b6b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[b425e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[107aef4]"></a>ProcAutodetecResponse</STRONG> (Thumb, 1702 bytes, Stack size 32 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 832 + Unknown Stack Size
<LI>Call Chain = ProcAutodetecResponse -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f11c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f72238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[f7354c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[f735cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d7d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fb464c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[100b6b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
<LI><a href="#[107b474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[108c928]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
</UL>

<P><STRONG><a name="[108c928]"></a>DspProcUnsolicitedMsg</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 840 + Unknown Stack Size
<LI>Call Chain = DspProcUnsolicitedMsg -> ProcAutodetecResponse -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[107aef4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>
<BR>[Called By]<UL><LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[f8c668]"></a>SetLate</STRONG> (Thumb, 118 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = SetLate -> DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[107a6e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[107a764]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[107a7ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[10989e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[1098a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[1098adc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b104c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[b23b5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1C
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[f8def4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
</UL>

<P><STRONG><a name="[10e34c4]"></a>CALC_EQ_FC</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CALC_EQ_FC</UL>
<BR>[Calls]<UL><LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[10e344c]"></a>CALC_EQ_Q</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CALC_EQ_Q</UL>
<BR>[Calls]<UL><LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[10e33d4]"></a>CALC_EQ_G</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = CALC_EQ_G</UL>
<BR>[Calls]<UL><LI><a href="#[11b3a88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[10e3358]"></a>DSP_Eq_Control</STRONG> (Thumb, 146 bytes, Stack size 32 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[fb4c20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
</UL>

<P><STRONG><a name="[10e32dc]"></a>DSP_Eq_Config</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10e3260]"></a>DSP_Eq_Channels</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10e31e4]"></a>DSP_Eq_Bands</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10e3168]"></a>DSP_Eq_Flash</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10e30e0]"></a>DSP_EQ_CH_PREATTENUATION</STRONG> (Thumb, 222 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10e3064]"></a>DSP_EQ_POSTGAIN</STRONG> (Thumb, 226 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10e2fe8]"></a>DSP_EQ_CHANGER</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_EQ_CHANGER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[f8d5d8]"></a>EqModuleconfig</STRONG> (Thumb, 516 bytes, Stack size 32 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[10e2fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[10e3358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
<LI><a href="#[10e33d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G
<LI><a href="#[10e344c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q
<LI><a href="#[10e34c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11b9f64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fc6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[b23524]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
</UL>

<P><STRONG><a name="[10e2f68]"></a>DSP_Power_on_config</STRONG> (Thumb, 572 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8d3ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[10e2fe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[10e33d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G
<LI><a href="#[10e344c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q
<LI><a href="#[10e34c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC
<LI><a href="#[11b60d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb4c20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
</UL>

<P><STRONG><a name="[fb4c20]"></a>DSP_EQ_Firmware_Init</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = DSP_EQ_Firmware_Init -> DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10e2f68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
<LI><a href="#[10e3358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f8d564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[f8dc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[f8d564]"></a>EqOn</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = EqOn -> DSP_EQ_Firmware_Init -> DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb4c20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[10e3358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[b22fcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[10e2ef0]"></a>DspReadEq</STRONG> (Thumb, 118 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fcf88c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[103daec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>

<P><STRONG><a name="[10d8dc4]"></a>Convert_8_24_Value</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Convert_8_24_Value</UL>
<BR>[Calls]<UL><LI><a href="#[11b58a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[107a4dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
</UL>

<P><STRONG><a name="[107a4dc]"></a>InitMicParameter</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[10d8dc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value
</UL>
<BR>[Called By]<UL><LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[10d8d44]"></a>DSP_IRC_1_Control</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[107a978]"></a>DSP_Rx_Channel</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_Rx_Channel -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[10d8ccc]"></a>DSP_Rx_Gain</STRONG> (Thumb, 84 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10d8c4c]"></a>DSP_IRC1_Tx_Channel</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[107a9f4]"></a>DSP_IRC1_Test_Duration</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_IRC1_Test_Duration -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[10d8bc8]"></a>DSP_IRC_1_Test_Signal</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[f420a8]"></a>DspReadIrc1</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f41fb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSpkDistance
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
<LI><a href="#[10d8b48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsIrc1ValidResult
</UL>

<P><STRONG><a name="[f41fb4]"></a>GetSpkDistance</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = GetSpkDistance -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f420a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
</UL>
<BR>[Called By]<UL><LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[10d8b48]"></a>IsIrc1ValidResult</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f420a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
</UL>

<P><STRONG><a name="[107a5e0]"></a>Dsp_IRC2_Control</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = Dsp_IRC2_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[107a55c]"></a>Dsp_IRC2_Speaker_Select</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = Dsp_IRC2_Speaker_Select -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[10d3024]"></a>Dsp_IRC2_Max_EQ_Fc</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc2_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[f42030]"></a>DspReadIrc2</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DspReadIrc2 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f41f34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[f41f34]"></a>IsIrc2ValidResult</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = IsIrc2ValidResult -> DspReadIrc2 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f42030]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
</UL>
<BR>[Called By]<UL><LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[107a458]"></a>OS_OUTPUT_MODE_CONTROL</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, os_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = OS_OUTPUT_MODE_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[107b474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[107b4f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>

<P><STRONG><a name="[107a3cc]"></a>OS_OUTPUT_MODE_CONTROL_FOR_DSPB</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, os_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 784 + Unknown Stack Size
<LI>Call Chain = OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[107b474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[107b4f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>

<P><STRONG><a name="[10d07c4]"></a>OS_OUTPUT_MODE_CONTROL_Debug</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10d0730]"></a>OS_OUTPUT_MODE_CONTROL_FOR_DSPB_Debug</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10d06b8]"></a>DspReadOS</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[107a878]"></a>DSP_SGEN_ENABLE</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, signalgenerator.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 776 + Unknown Stack Size
<LI>Call Chain = DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fe78f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[f11734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>

<P><STRONG><a name="[107a8f4]"></a>DSP_SGEN_CHANNEL_ENABLE</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, signalgenerator.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_SGEN_CHANNEL_ENABLE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f11734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>

<P><STRONG><a name="[10cb0fc]"></a>DSP_CHANNEL_SIGNAL_SELECT</STRONG> (Thumb, 222 bytes, Stack size 32 bytes, signalgenerator.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10cb084]"></a>DspReadSgen</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, signalgenerator.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10be2cc]"></a>DSP_TRUEHD_Control</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10be240]"></a>DSP_TRUEHD_Decode_Mode_Control</STRONG> (Thumb, 166 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[107a6e0]"></a>DSP_TRUEHD_DRC_Control</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = DSP_TRUEHD_DRC_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[107a660]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[107a764]"></a>DSP_TRUEHD_Cut_Scalefactor</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[107a660]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[107a7ec]"></a>DSP_TRUEHD_Boost_Scalefactor</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_TRUEHD_Boost_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[107a660]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[107a660]"></a>DSP_TRUEHD_DRC_INIT</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 768 + Unknown Stack Size
<LI>Call Chain = DSP_TRUEHD_DRC_INIT -> DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[107a6e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[107a764]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[107a7ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>

<P><STRONG><a name="[f71fa0]"></a>DspReadTRUEHD</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DspReadTRUEHD -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
</UL>

<P><STRONG><a name="[107ace8]"></a>DSP_BOOT</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + In Cycle
<LI>Call Chain = DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fb4d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[107ae70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[10ba8e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
<LI><a href="#[10ba960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[10bab64]"></a>DSP_CFG_OUTPUT_FS</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10baae4]"></a>DSP_CFG_AUDIO_SRC</STRONG> (Thumb, 172 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_AUDIO_SRC -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb4d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10ba8e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
</UL>

<P><STRONG><a name="[107ac6c]"></a>DSP_CFG_DECODER</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_DECODER -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[fb4d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>

<P><STRONG><a name="[107abf0]"></a>DSP_CFG_MATRIX</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_MATRIX -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ae70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
</UL>

<P><STRONG><a name="[107aa78]"></a>DSP_CFG_VIRTUALIZER</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_VIRTUALIZER -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>

<P><STRONG><a name="[107ab78]"></a>DSP_CFG_PPM</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_PPM -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10ba960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[107aaf8]"></a>DSP_CFG_PPM_Mode</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_PPM_Mode -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ae70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[10ba960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[10baa60]"></a>DSP_CFG_PPM_Mode_Pl2x</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10ba9e0]"></a>DSP_CFG_MCLK_FACTOR</STRONG> (Thumb, 168 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_MCLK_FACTOR -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fb4d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[107ade8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10ba8e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
</UL>

<P><STRONG><a name="[fb4d2c]"></a>Change_DSP_Decoder_Code</STRONG> (Thumb, 142 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Change_DSP_Decoder_Code -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[107ac6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10ba9e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10baae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0ff5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f26a58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[107ae70]"></a>Change_DSP_MATRIX_Code</STRONG> (Thumb, 304 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Change_DSP_MATRIX_Code -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[107aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107abf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d74c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>

<P><STRONG><a name="[107ade8]"></a>Change_DSP_VIRTUALIZER_Code</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Change_DSP_VIRTUALIZER_Code -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[107aa78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[107ab78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107ac6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10ba9e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10baae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
</UL>
<BR>[Called By]<UL><LI><a href="#[f1182c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[f71964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[f7201c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[f8d74c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>

<P><STRONG><a name="[10ba960]"></a>Change_DSP_PPM_Code</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[107aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107ab78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
</UL>

<P><STRONG><a name="[107ad60]"></a>Change_Input_Audio_Source</STRONG> (Thumb, 780 bytes, Stack size 8 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = Change_Input_Audio_Source -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f72d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[f8da38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[107aa78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[107aaf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[107ab78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[107abf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[107ac6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10ba9e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10baae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f117b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>

<P><STRONG><a name="[10ba8e0]"></a>DSP_Update_Flash</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[107ace8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10ba9e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10baae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
</UL>

<P><STRONG><a name="[fd9da4]"></a>DSP_API_Read</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = DSP_API_Read -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fcbf6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[fcf908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd9e20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Busy
</UL>

<P><STRONG><a name="[1113c14]"></a>_printf_pre_padding</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, _printf_pad.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_pre_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9bd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[11cb76c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11cbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[11cc2e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>

<P><STRONG><a name="[1113b90]"></a>_printf_post_padding</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, _printf_pad.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9bd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[11cb76c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11cbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[11cc2e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>

<P><STRONG><a name="[1113720]"></a>_printf_int_dec</STRONG> (Thumb, 98 bytes, Stack size 72 bytes, _printf_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = _printf_int_dec -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11c7b70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_udiv10 (via Veneer)
<LI><a href="#[11cb76c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11cc6e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
<LI><a href="#[11cc738]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_signed
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1113088]"></a>vsprintf</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, vsprintf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11c8494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[11c8a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[f1e234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f1e2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[f8c17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[fb45d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>

<P><STRONG><a name="[11125f8]"></a>__0sprintf</STRONG> (Thumb, 40 bytes, Stack size 32 bytes, __0sprintf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = __0sprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11c8494]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[11c8a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[111211c]"></a>__aeabi_memset</STRONG> (ARM, 16 bytes, Stack size 0 bytes, aeabi_memset.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[11c8068]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[a600c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitRemoteRepeatKey (via Veneer)
<LI><a href="#[f26278]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank (via Veneer)
<LI><a href="#[f8c0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank (via Veneer)
</UL>

<P><STRONG><a name="[1111cc0]"></a>__aeabi_memcpy</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memcpy.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a602b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage (via Veneer)
<LI><a href="#[b1044c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup (via Veneer)
<LI><a href="#[b105b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup (via Veneer)
<LI><a href="#[b22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN (via Veneer)
<LI><a href="#[b30108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage (via Veneer)
<LI><a href="#[b30180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage (via Veneer)
<LI><a href="#[108cca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg (via Veneer)
</UL>

<P><STRONG><a name="[1111c48]"></a>__rt_memcpy</STRONG> (ARM, 212 bytes, Stack size 0 bytes, rt_memcpy.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[111164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[1111d10]"></a>_memcpy_lastbytes</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy.o(.text), UNUSED)

<P><STRONG><a name="[111164c]"></a>__aeabi_memcpy4</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_memcpy4</UL>
<BR>[Called By]<UL><LI><a href="#[f422a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display (via Veneer)
<LI><a href="#[f8d27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte (via Veneer)
<LI><a href="#[f8d654]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte (via Veneer)
<LI><a href="#[f8d6d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte (via Veneer)
<LI><a href="#[f8d9bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte (via Veneer)
<LI><a href="#[fb4ab4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte (via Veneer)
<LI><a href="#[100b730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte (via Veneer)
<LI><a href="#[100b7ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte (via Veneer)
<LI><a href="#[10581b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte (via Veneer)
<LI><a href="#[1058228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte (via Veneer)
<LI><a href="#[1111c48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_memcpy
</UL>

<P><STRONG><a name="[111169c]"></a>__aeabi_memcpy8</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11115d0]"></a>__rt_memcpy_w</STRONG> (ARM, 100 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[1111718]"></a>_memcpy_lastbytes_aligned</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11110fc]"></a>strncpy</STRONG> (ARM, 108 bytes, Stack size 8 bytes, strncpy.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strncpy</UL>
<BR>[Calls]<UL><LI><a href="#[11c8018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[f8c17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp (via Veneer)
<LI><a href="#[fb45d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay (via Veneer)
</UL>

<P><STRONG><a name="[1110c58]"></a>strlen</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, strlen.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strlen</UL>
<BR>[Called By]<UL><LI><a href="#[f1e234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f1e2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[f422a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[f423a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[f8c17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[fb45d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>

<P><STRONG><a name="[1110528]"></a>__aeabi_idiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text), UNUSED)

<P><STRONG><a name="[11104d8]"></a>__aeabi_idivmod</STRONG> (ARM, 364 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[11ce934]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idiv0
</UL>
<BR>[Called By]<UL><LI><a href="#[a602b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage (via Veneer)
<LI><a href="#[b30108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage (via Veneer)
<LI><a href="#[b30180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage (via Veneer)
<LI><a href="#[b308bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull (via Veneer)
<LI><a href="#[f15394]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElement (via Veneer)
<LI><a href="#[f15514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
<LI><a href="#[f15588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DeQueue (via Veneer)
<LI><a href="#[f15674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull (via Veneer)
<LI><a href="#[f156ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty (via Veneer)
<LI><a href="#[f41eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value (via Veneer)
<LI><a href="#[f42120]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[f72990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek (via Veneer)
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey (via Veneer)
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay (via Veneer)
<LI><a href="#[11c9d20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp (via Veneer)
<LI><a href="#[11de914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
</UL>

<P><STRONG><a name="[11bee60]"></a>__use_two_region_memory</STRONG> (ARM, 4 bytes, Stack size 0 bytes, stkheap2.o(.text), UNUSED)

<P><STRONG><a name="[11bedd8]"></a>__rt_stackheap_init</STRONG> (ARM, 60 bytes, Stack size 24 bytes, stkheap2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = __rt_stackheap_init -> __user_setup_stackheap</UL>
<BR>[Calls]<UL><LI><a href="#[11cda5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_storage
<LI><a href="#[11cedb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>
<BR>[Called By]<UL><LI><a href="#[11cf738]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11bed50]"></a>__rt_heap_extend</STRONG> (ARM, 24 bytes, Stack size 8 bytes, stkheap2.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11bef34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[11b3014]"></a>__ARM_switch8</STRONG> (ARM, 24 bytes, Stack size 0 bytes, switch8.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup (via Veneer)
<LI><a href="#[b10a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup (via Veneer)
<LI><a href="#[b22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN (via Veneer)
<LI><a href="#[b22e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S (via Veneer)
<LI><a href="#[b22ed8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone2Channel (via Veneer)
<LI><a href="#[b234a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid (via Veneer)
<LI><a href="#[b235a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1DF_ (via Veneer)
<LI><a href="#[b2370c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E (via Veneer)
<LI><a href="#[b23970]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF (via Veneer)
<LI><a href="#[b23d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S (via Veneer)
<LI><a href="#[b23db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel (via Veneer)
<LI><a href="#[b23ea8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode (via Veneer)
<LI><a href="#[f118a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay (via Veneer)
<LI><a href="#[f11920]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner (via Veneer)
<LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage (via Veneer)
<LI><a href="#[f266e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService (via Veneer)
<LI><a href="#[f26760]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom (via Veneer)
<LI><a href="#[f2685c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey (via Veneer)
<LI><a href="#[f268dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey (via Veneer)
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[f26fac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption (via Veneer)
<LI><a href="#[f4d370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey (via Veneer)
<LI><a href="#[f72124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO (via Veneer)
<LI><a href="#[f724bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey (via Veneer)
<LI><a href="#[f7262c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey (via Veneer)
<LI><a href="#[f72fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect (via Veneer)
<LI><a href="#[f7315c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType (via Veneer)
<LI><a href="#[f76b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey (via Veneer)
<LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage (via Veneer)
<LI><a href="#[f8c364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault (via Veneer)
<LI><a href="#[f8c574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase (via Veneer)
<LI><a href="#[f8c668]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate (via Veneer)
<LI><a href="#[f8d374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSrcName (via Veneer)
<LI><a href="#[f8d7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm (via Veneer)
<LI><a href="#[f8d84c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS (via Veneer)
<LI><a href="#[f8d8c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3 (via Veneer)
<LI><a href="#[f8f9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType (via Veneer)
<LI><a href="#[f8fe54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL (via Veneer)
<LI><a href="#[f8fed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC (via Veneer)
<LI><a href="#[f8ffc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM (via Veneer)
<LI><a href="#[fb4ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacInvert (via Veneer)
<LI><a href="#[fb4ca4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting (via Veneer)
<LI><a href="#[fb4d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code (via Veneer)
<LI><a href="#[fb4db0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChanegName (via Veneer)
<LI><a href="#[fb51a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance (via Veneer)
<LI><a href="#[fb53a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay (via Veneer)
<LI><a href="#[fb541c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode (via Veneer)
<LI><a href="#[fb551c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode (via Veneer)
<LI><a href="#[fc6800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode (via Veneer)
<LI><a href="#[fc6a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK (via Veneer)
<LI><a href="#[fc6aac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT (via Veneer)
<LI><a href="#[fc6b38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE (via Veneer)
<LI><a href="#[fc6ef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL (via Veneer)
<LI><a href="#[fc6f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL (via Veneer)
<LI><a href="#[fc7004]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER (via Veneer)
<LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService (via Veneer)
<LI><a href="#[ff6110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change (via Veneer)
<LI><a href="#[ff6194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change (via Veneer)
<LI><a href="#[ff9174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcDigitKey (via Veneer)
<LI><a href="#[1004dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD (via Veneer)
<LI><a href="#[103e12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335 (via Veneer)
<LI><a href="#[107a8f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE (via Veneer)
<LI><a href="#[107ace8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT (via Veneer)
<LI><a href="#[107ad60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source (via Veneer)
<LI><a href="#[107aef4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse (via Veneer)
<LI><a href="#[1091ce8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DIMENSION_CONFIGURATION (via Veneer)
<LI><a href="#[1091d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CENTER_WIDTH_CONFIGURATION (via Veneer)
<LI><a href="#[1095258]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION (via Veneer)
<LI><a href="#[10952e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION (via Veneer)
<LI><a href="#[1095400]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE (via Veneer)
<LI><a href="#[109fe60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Max_Setting (via Veneer)
<LI><a href="#[10baae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC (via Veneer)
<LI><a href="#[10bab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_OUTPUT_FS (via Veneer)
<LI><a href="#[10be240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Decode_Mode_Control (via Veneer)
<LI><a href="#[10cb0fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CHANNEL_SIGNAL_SELECT (via Veneer)
<LI><a href="#[10e3064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_POSTGAIN (via Veneer)
<LI><a href="#[10e30e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CH_PREATTENUATION (via Veneer)
</UL>

<P><STRONG><a name="[11b2f98]"></a>__rt_switch8</STRONG> (ARM, 0 bytes, Stack size 0 bytes, switch8.o(.text), UNUSED)

<P><STRONG><a name="[11b2b8c]"></a>__ARM_call_via_r0</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[102b178]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[102b360]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
</UL>

<P><STRONG><a name="[11b2bdc]"></a>__call_via_r0</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b2ac0]"></a>__ARM_call_via_r1</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b427d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[f81ce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundProcMessage
<LI><a href="#[102b178]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[102b1f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[102b270]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[102b2e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[102b360]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11b2b10]"></a>__call_via_r1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b29f4]"></a>__ARM_call_via_r2</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8dd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
<LI><a href="#[1113b90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[1113c14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11c9bd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[11cb76c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11cbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[11d99e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_outstr_char
<LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11b2a44]"></a>__call_via_r2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b2928]"></a>__ARM_call_via_r3</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f2702c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[f270b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;load_default_option
<LI><a href="#[f27130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f271b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f27230]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[11cc2e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[11d9208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
<LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11b2978]"></a>__call_via_r3</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b282c]"></a>__ARM_call_via_r4</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b28ac]"></a>__call_via_r4</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b2730]"></a>__ARM_call_via_r5</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b27b0]"></a>__call_via_r5</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b2634]"></a>__ARM_call_via_r6</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b26b4]"></a>__call_via_r6</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b2538]"></a>__ARM_call_via_r7</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b25b8]"></a>__call_via_r7</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11b1dd4]"></a>pow</STRONG> (ARM, 3604 bytes, Stack size 216 bytes, pow.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[11b1ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copysign
<LI><a href="#[11b4bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple
<LI><a href="#[11ba824]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[11bb050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2d
<LI><a href="#[11bc0b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv
<LI><a href="#[11bd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dsub
<LI><a href="#[11bd3b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_drsub
<LI><a href="#[11bd4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
<LI><a href="#[11c2834]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sqrt
<LI><a href="#[11c30cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
<LI><a href="#[11c45b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scalbn
<LI><a href="#[11ccc88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fc7214]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[11b1d58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__softfp_pow
</UL>

<P><STRONG><a name="[11b1d58]"></a>__softfp_pow</STRONG> (ARM, 4 bytes, Stack size 0 bytes, pow.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b1dd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11cf738]"></a>__rt_entry</STRONG> (ARM, 76 bytes, Stack size 16 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 68 + Unknown Stack Size
<LI>Call Chain = __rt_entry -> __rt_lib_init -> _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[11bedd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
<LI><a href="#[11d3058]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_lib_init
<LI><a href="#[11d34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_stackheap_init
<LI><a href="#[11d4bf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
<LI><a href="#[11d82b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit (via BX)
</UL>
<BR>[Called By]<UL><LI><a href="#[1180934]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
<LI><a href="#[11be720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[11cf5f0]"></a>__rt_exit</STRONG> (ARM, 20 bytes, Stack size 8 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __rt_exit -> __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[11d4ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11d82b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (via Veneer)
</UL>

<P><STRONG><a name="[11cf578]"></a>__rt_abort</STRONG> (ARM, 8 bytes, Stack size 0 bytes, kernel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c2210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>

<P><STRONG><a name="[11cedb8]"></a>__user_setup_stackheap</STRONG> (ARM, 96 bytes, Stack size 8 bytes, sys_stackheap_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __user_setup_stackheap</UL>
<BR>[Calls]<UL><LI><a href="#[a66504]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_initial_stackheap
<LI><a href="#[11c1d34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[11bedd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[11ce934]"></a>__aeabi_idiv0</STRONG> (ARM, 4 bytes, Stack size 0 bytes, aeabi_idiv0.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11104d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod
</UL>

<P><STRONG><a name="[11cda5c]"></a>__rt_stackheap_storage</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_stackheap_storage_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11bedd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[11cccd8]"></a>__read_errno</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, _rserrno.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11e0f94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr (via Veneer)
</UL>

<P><STRONG><a name="[11ccc88]"></a>__set_errno</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, _rserrno.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __set_errno</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11e0f94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow (via Veneer)
<LI><a href="#[11c2834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt (via Veneer)
</UL>

<P><STRONG><a name="[11cc738]"></a>_printf_truncate_signed</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, _printf_truncate.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1113720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[11cc6e8]"></a>_printf_truncate_unsigned</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, _printf_truncate.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1113720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[11cab54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[11cb130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>

<P><STRONG><a name="[11cc2e0]"></a>_printf_str</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, _printf_str.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = _printf_str -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1113b90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[1113c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11cbdb0]"></a>_printf_wctomb</STRONG> (Thumb, 190 bytes, Stack size 56 bytes, _printf_wctomb.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = _printf_wctomb -> _wcrtomb -> __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[1113b90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[1113c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[11d9208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11cb76c]"></a>_printf_int_common</STRONG> (Thumb, 168 bytes, Stack size 40 bytes, _printf_intcommon.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1113b90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[1113c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[1113720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[11ca6ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[11cab54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[11cb130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>

<P><STRONG><a name="[11cb130]"></a>_printf_longlong_hex</STRONG> (Thumb, 182 bytes, Stack size 88 bytes, _printf_longlong_hex.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_hex -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11cb76c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11cc6e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11cab54]"></a>_printf_longlong_oct</STRONG> (Thumb, 138 bytes, Stack size 64 bytes, _printf_longlong_oct.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_oct -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11cb76c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11cc6e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11ca6ac]"></a>_printf_longlong_dec</STRONG> (Thumb, 124 bytes, Stack size 80 bytes, _printf_longlong_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_dec -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11cb76c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[11def34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11ca194]"></a>_printf_charcount</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, _printf_charcount.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11c9ca0]"></a>__lib_sel_fp_printf</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, _printf_fp_dec.o(.text), UNUSED)

<P><STRONG><a name="[11c9c28]"></a>_fp_display</STRONG> (Thumb, 806 bytes, Stack size 64 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11c9d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp
<LI><a href="#[11c9d98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
<LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11dfbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[11f16a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__mathlib_classify (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9bd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[11c9bd8]"></a>_printf_fp_dec_real</STRONG> (Thumb, 234 bytes, Stack size 56 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1113b90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[1113c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[11c9c28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_display
<LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11b34dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec (via Veneer)
</UL>

<P><STRONG><a name="[11c8a44]"></a>_printf_char_common</STRONG> (Thumb, 44 bytes, Stack size 88 bytes, _printf_char_common.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11dade4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>
<BR>[Called By]<UL><LI><a href="#[11125f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[1113088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>

<P><STRONG><a name="[11c8494]"></a>_sputc</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, _sputc.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11125f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[1113088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Address Reference Count : 2]<UL><LI> __0sprintf.o(.text)
<LI> vsprintf.o(.text)
</UL>
<P><STRONG><a name="[11c8018]"></a>__aeabi_memclr</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11110fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>

<P><STRONG><a name="[11c7fa0]"></a>__rt_memclr</STRONG> (ARM, 64 bytes, Stack size 0 bytes, rt_memclr.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11d7dec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[11c8068]"></a>_memset</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[111211c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>

<P><STRONG><a name="[11c7b70]"></a>__rt_udiv10</STRONG> (ARM, 44 bytes, Stack size 0 bytes, rtudiv10.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1113720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec (via Veneer)
</UL>

<P><STRONG><a name="[11c30cc]"></a>__kernel_poly</STRONG> (ARM, 248 bytes, Stack size 24 bytes, poly.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[11ba824]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[11bd4a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
</UL>
<BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11c2834]"></a>sqrt</STRONG> (ARM, 100 bytes, Stack size 16 bytes, sqrt.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = sqrt -> _dsqrt</UL>
<BR>[Calls]<UL><LI><a href="#[11b51a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple
<LI><a href="#[11ccc88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[11d27cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsqrt
</UL>
<BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[11c27b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__softfp_sqrt
</UL>

<P><STRONG><a name="[11c27b8]"></a>__softfp_sqrt</STRONG> (ARM, 4 bytes, Stack size 0 bytes, sqrt.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c2834]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[11c2210]"></a>_sys_exit</STRONG> (ARM, 20 bytes, Stack size 0 bytes, sys_exit.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11cf578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_abort
</UL>

<P><STRONG><a name="[11c1c0c]"></a>__user_libspace</STRONG> (ARM, 8 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[11c1d34]"></a>__user_perproc_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11cedb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[11c1cac]"></a>__user_perthread_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[11e0f94]"></a>__aeabi_errno_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_errno_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11ccc88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[11cccd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__read_errno (via Veneer)
</UL>

<P><STRONG><a name="[11e1020]"></a>__rt_errno_addr_intlibspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_errno_addr_intlibspace.o(.text), UNUSED)

<P><STRONG><a name="[11dfbe4]"></a>__rt_locale</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_locale_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11c9c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (via Veneer)
<LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
<LI><a href="#[11f08e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>

<P><STRONG><a name="[11def34]"></a>_ll_udiv10</STRONG> (ARM, 160 bytes, Stack size 12 bytes, lludiv10.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _ll_udiv10</UL>
<BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
<LI><a href="#[11ca6ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec (via Veneer)
</UL>

<P><STRONG><a name="[11de914]"></a>_btod_etento</STRONG> (Thumb, 202 bytes, Stack size 72 bytes, bigflt0.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11dd97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul (via Veneer)
<LI><a href="#[11dd9cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[11dade4]"></a>__printf</STRONG> (Thumb, 740 bytes, Stack size 48 bytes, __printf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384 + Unknown Stack Size
<LI>Call Chain = __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1113720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
<LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[11b34dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec (via Veneer)
<LI><a href="#[11c3e34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex (via Veneer)
<LI><a href="#[11ca194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_charcount
<LI><a href="#[11ca6ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[11cab54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[11cb130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
<LI><a href="#[11cbdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[11cc2e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11dacf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wc (Weak Reference)
<LI><a href="#[11dad68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_mbtowc (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11c8a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>

<P><STRONG><a name="[11d99e4]"></a>_printf_outstr_char</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, _printf_outstr_char.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_outstr_char</UL>
<BR>[Calls]<UL><LI><a href="#[11b29f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[11d95e8]"></a>_printf_input_char</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, _printf_input_char.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[11d9208]"></a>_wcrtomb</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, _wcrtomb.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = _wcrtomb -> __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[11b2928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
<LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11f08e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11cbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
</UL>

<P><STRONG><a name="[11d88a0]"></a>_get_lc_numeric</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, lc_numeric_c.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11ef684]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[11d82b8]"></a>exit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = exit -> __rt_exit -> __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11cf5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
<LI><a href="#[11d81e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_call_atexit_fns (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11cf738]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11d7cf4]"></a>__aeabi_memclr4</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[11d7d70]"></a>__aeabi_memclr8</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[11d7c78]"></a>__rt_memclr_w</STRONG> (ARM, 84 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[11d7dec]"></a>_memset_w</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11c7fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_memclr
</UL>

<P><STRONG><a name="[11d4bf0]"></a>__rt_lib_init</STRONG> (Thumb, 188 bytes, Stack size 40 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = __rt_lib_init -> _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11d4264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_signal_init (Weak Reference)
<LI><a href="#[11d42e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_rand_init (Weak Reference)
<LI><a href="#[11d4358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio (Weak Reference)
<LI><a href="#[11d43cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_user_alloc (Weak Reference)
<LI><a href="#[11d444c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc (Weak Reference)
<LI><a href="#[11d44c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_getenv_init (Weak Reference)
<LI><a href="#[11d4540]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_time (Weak Reference)
<LI><a href="#[11d45bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_monetary (Weak Reference)
<LI><a href="#[11d46b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_collate (Weak Reference)
<LI><a href="#[11d4734]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_trap_init (Weak Reference)
<LI><a href="#[11d47b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_clock_init (Weak Reference)
<LI><a href="#[11d4828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_atexit_init (Weak Reference)
<LI><a href="#[11d4920]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cpp_initialize__aeabi_ (Weak Reference)
<LI><a href="#[11d49a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__alloca_initialize (Weak Reference)
<LI><a href="#[11d4a28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_DescSize (Weak Reference)
<LI><a href="#[11d4aa4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_exceptions_init (Weak Reference)
<LI><a href="#[11d4cbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_argv_veneer (via Veneer)
<LI><a href="#[11d88a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric
<LI><a href="#[11dfbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[11eac2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype
<LI><a href="#[11ed8c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11cf738]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry (via Veneer)
</UL>

<P><STRONG><a name="[11d4ba0]"></a>__rt_lib_shutdown</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11d4164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio (Weak Reference)
<LI><a href="#[11d41e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminate_user_alloc (Weak Reference)
<LI><a href="#[11d48a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11cf5f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
</UL>

<P><STRONG><a name="[11d34ac]"></a>_platform_post_stackheap_init</STRONG> (ARM, 12 bytes, Stack size 0 bytes, boardinit2.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11cf738]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11d3058]"></a>_platform_post_lib_init</STRONG> (ARM, 16 bytes, Stack size 8 bytes, boardinit3.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _platform_post_lib_init</UL>
<BR>[Called By]<UL><LI><a href="#[11cf738]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11f16a4]"></a>__mathlib_classify</STRONG> (ARM, 56 bytes, Stack size 8 bytes, classify.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __mathlib_classify</UL>
<BR>[Calls]<UL><LI><a href="#[11ed358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_fpclassify
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (via Veneer)
</UL>

<P><STRONG><a name="[11f11e0]"></a>__support_dtoi</STRONG> (ARM, 96 bytes, Stack size 16 bytes, dtoi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __support_dtoi</UL>
<BR>[Calls]<UL><LI><a href="#[11c45b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scalbn
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[11f0d4c]"></a>__I_use_semihosting</STRONG> (ARM, 0 bytes, Stack size 0 bytes, use_no_semi.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> sys_exit.o(.text)
</UL>
<P><STRONG><a name="[11f0cc4]"></a>__use_no_semihosting_swi</STRONG> (ARM, 4 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[11f08e8]"></a>__rt_ctype_table</STRONG> (ARM, 24 bytes, Stack size 8 bytes, rt_ctype_table.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[11dfbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
</UL>
<BR>[Called By]<UL><LI><a href="#[11d9208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb (via Veneer)
</UL>

<P><STRONG><a name="[11ef684]"></a>strcmp</STRONG> (ARM, 156 bytes, Stack size 4 bytes, strcmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = strcmp</UL>
<BR>[Called By]<UL><LI><a href="#[11d88a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (via Veneer)
<LI><a href="#[11eac2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (via Veneer)
</UL>

<P><STRONG><a name="[11edcd4]"></a>__ARM_get_argv</STRONG> (Thumb, 6 bytes, Stack size 4 bytes, no_argv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __ARM_get_argv</UL>
<BR>[Address Reference Count : 1]<UL><LI> lib_init.o(.emb_text)
</UL>
<P><STRONG><a name="[11ed358]"></a>__ARM_fpclassify</STRONG> (ARM, 44 bytes, Stack size 0 bytes, fpclassify.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11f16a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__mathlib_classify
</UL>

<P><STRONG><a name="[11ec054]"></a>__rt_fp_status_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_fp_status_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11ed8c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[11eac2c]"></a>_get_lc_ctype</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, lc_ctype_c.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _get_lc_ctype -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11ef684]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rt_ctype_table.o(.text)
</UL>
<P><STRONG><a name="[111045c]"></a>__aeabi_uidiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv), UNUSED)

<P><STRONG><a name="[111040c]"></a>__aeabi_uidivmod</STRONG> (ARM, 28 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv))
<BR><BR>[Calls]<UL><LI><a href="#[11106c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div_large
<LI><a href="#[111073c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div8
<LI><a href="#[11107b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div4
</UL>
<BR>[Called By]<UL><LI><a href="#[f4bca4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command (via Veneer)
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage (via Veneer)
<LI><a href="#[f8c854]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset (via Veneer)
<LI><a href="#[f8e4b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTT_ (via Veneer)
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[ff6294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd (via Veneer)
<LI><a href="#[ff6588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay (via Veneer)
<LI><a href="#[1015738]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetUart1Baudrate (via Veneer)
<LI><a href="#[10158a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetUart0Baudrate (via Veneer)
</UL>

<P><STRONG><a name="[11dda1c]"></a>_btod_d2e</STRONG> (ARM, 56 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e))
<BR><BR>[Calls]<UL><LI><a href="#[11dd900]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[11dd884]"></a>_d2e_denorm_low</STRONG> (ARM, 84 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e_denorm_low))
<BR><BR>[Called By]<UL><LI><a href="#[11dd900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>

<P><STRONG><a name="[11dd900]"></a>_d2e_norm_op1</STRONG> (ARM, 104 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e_norm_op1))
<BR><BR>[Calls]<UL><LI><a href="#[11dd884]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_denorm_low
</UL>
<BR>[Called By]<UL><LI><a href="#[11dda1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e
</UL>

<P><STRONG><a name="[11dd5ac]"></a>__btod_div_common</STRONG> (ARM, 716 bytes, Stack size 24 bytes, btod.o(CL$$btod_div_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __btod_div_common</UL>
<BR>[Called By]<UL><LI><a href="#[11dd9cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[11dd720]"></a>_e2e</STRONG> (ARM, 220 bytes, Stack size 24 bytes, btod.o(CL$$btod_e2e))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = _e2e</UL>
<BR>[Called By]<UL><LI><a href="#[11dd97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
<LI><a href="#[11dd9cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[11dd9cc]"></a>_btod_ediv</STRONG> (ARM, 52 bytes, Stack size 24 bytes, btod.o(CL$$btod_ediv))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _btod_ediv -> __btod_div_common</UL>
<BR>[Calls]<UL><LI><a href="#[11dd5ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_div_common
<LI><a href="#[11dd720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
<LI><a href="#[11de914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
</UL>

<P><STRONG><a name="[11dd97c]"></a>_btod_emul</STRONG> (ARM, 52 bytes, Stack size 24 bytes, btod.o(CL$$btod_emul))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11dd62c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_mult_common
<LI><a href="#[11dd720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
<LI><a href="#[11de914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
</UL>

<P><STRONG><a name="[11dd62c]"></a>__btod_mult_common</STRONG> (ARM, 616 bytes, Stack size 16 bytes, btod.o(CL$$btod_mult_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __btod_mult_common</UL>
<BR>[Called By]<UL><LI><a href="#[11dd97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
</UL>

<P><STRONG><a name="[11b1ce0]"></a>copysign</STRONG> (ARM, 16 bytes, Stack size 0 bytes, pow.o(i.copysign))
<BR><BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11bdfa8]"></a>__aeabi_d2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, d2f.o(x$fpl$d2f))
<BR><BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[fc7214]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[11bdf34]"></a>_d2f</STRONG> (ARM, 168 bytes, Stack size 0 bytes, d2f.o(x$fpl$d2f), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c6f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>

<P><STRONG><a name="[11bdff8]"></a>__fpl_inf_d2f</STRONG> (ARM, 0 bytes, Stack size unknown bytes, d2f.o(x$fpl$d2f), UNUSED)

<P><STRONG><a name="[11bd4a4]"></a>__aeabi_dadd</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dadd))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_dadd</UL>
<BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[11c30cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
</UL>

<P><STRONG><a name="[11bd430]"></a>_dadd</STRONG> (ARM, 452 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11bd788]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c749c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11bd59c]"></a>__fpl_inf_dadd</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)

<P><STRONG><a name="[11c749c]"></a>__fpl_dcheck_NaN2</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dcheck.o(x$fpl$dcheck), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11d2118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[11ba7b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dmul
<LI><a href="#[11bc040]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv
<LI><a href="#[11bd27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[11bd430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd
<LI><a href="#[11c6ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[11c6f84]"></a>__fpl_dcheck_NaN1</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dcheck1.o(x$fpl$dcheck1))
<BR><BR>[Calls]<UL><LI><a href="#[11d2118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[11bdf34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2f
<LI><a href="#[11c45b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;scalbn
<LI><a href="#[11d27cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsqrt
</UL>

<P><STRONG><a name="[11c6ae4]"></a>__fpl_dcmp_InfNaN</STRONG> (ARM, 128 bytes, Stack size 4 bytes, dcmpin.o(x$fpl$dcmpinfnan), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c749c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
<LI><a href="#[11f1fa4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[11b4b7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drcmple
<LI><a href="#[11b5130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dcmple
</UL>

<P><STRONG><a name="[11c69ec]"></a>__fpl_inf_dcmp</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dcmpin.o(x$fpl$dcmpinfnan), UNUSED)

<P><STRONG><a name="[11c55a0]"></a>__fpl_fcmp_InfNaN</STRONG> (ARM, 100 bytes, Stack size 0 bytes, fcmpin.o(x$fpl$dcmpinfnan), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
<LI><a href="#[11f1fa4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[11b3a10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_frcmple
<LI><a href="#[11b3fa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fcmple
<LI><a href="#[11b4534]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fcmpeq
</UL>

<P><STRONG><a name="[11c5524]"></a>__fpl_inf_fcmp</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fcmpin.o(x$fpl$dcmpinfnan), UNUSED)

<P><STRONG><a name="[11bc0b4]"></a>__aeabi_ddiv</STRONG> (ARM, 0 bytes, Stack size 16 bytes, ddiv.o(x$fpl$ddiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_ddiv</UL>
<BR>[Called By]<UL><LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11bc040]"></a>_ddiv</STRONG> (ARM, 464 bytes, Stack size 16 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11bbfc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ddiv_mantissas
<LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c749c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11bc178]"></a>__fpl_inf_ddiv</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ddiv.o(x$fpl$ddiv), UNUSED)

<P><STRONG><a name="[11bbfc4]"></a>_ddiv_mantissas</STRONG> (ARM, 608 bytes, Stack size 28 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11bc040]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv
</UL>

<P><STRONG><a name="[11bb050]"></a>__aeabi_i2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dflt))
<BR><BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11bafdc]"></a>_dflt</STRONG> (ARM, 88 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dflt), UNUSED)

<P><STRONG><a name="[11bb18c]"></a>__dflt_normalise</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dflt_noclz.o(x$fpl$dflt), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11bb0c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dfltu
</UL>

<P><STRONG><a name="[11bb13c]"></a>__aeabi_ui2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dfltu))
<BR><BR>[Called By]<UL><LI><a href="#[103cc90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[103cd0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
</UL>

<P><STRONG><a name="[11bb0c8]"></a>_dfltu</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dfltu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11bb18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__dflt_normalise
</UL>

<P><STRONG><a name="[11b51a4]"></a>__aeabi_cdcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dleqf.o(x$fpl$dleqf))
<BR><BR>[Called By]<UL><LI><a href="#[b23424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[f8f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[f92808]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[103cc90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[103cd0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
<LI><a href="#[11c2834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[11b5130]"></a>_dcmple</STRONG> (ARM, 132 bytes, Stack size 0 bytes, dleqf.o(x$fpl$dleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c6ae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[11ba824]"></a>__aeabi_dmul</STRONG> (ARM, 0 bytes, Stack size 16 bytes, dmul.o(x$fpl$dmul))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_dmul</UL>
<BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[11c30cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
</UL>

<P><STRONG><a name="[11ba7b0]"></a>_dmul</STRONG> (ARM, 460 bytes, Stack size 16 bytes, dmul.o(x$fpl$dmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c749c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11ba874]"></a>__fpl_inf_dmul</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dmul.o(x$fpl$dmul), UNUSED)

<P><STRONG><a name="[11b4bf4]"></a>__aeabi_cdrcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, drleqf.o(x$fpl$drleqf))
<BR><BR>[Called By]<UL><LI><a href="#[b23424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[f8f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[103cc90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[103cd0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
<LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11b4b7c]"></a>_drcmple</STRONG> (ARM, 156 bytes, Stack size 0 bytes, drleqf.o(x$fpl$drleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c6ae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[11bd3b4]"></a>__aeabi_drsub</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$drsb))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_drsub</UL>
<BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11bd340]"></a>_drsb</STRONG> (ARM, 24 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$drsb), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11bd788]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[11bd964]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
</UL>

<P><STRONG><a name="[11d27cc]"></a>_dsqrt</STRONG> (ARM, 384 bytes, Stack size 16 bytes, dsqrt.o(x$fpl$dsqrt))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _dsqrt</UL>
<BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c6f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>
<BR>[Called By]<UL><LI><a href="#[11c2834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[11d281c]"></a>__fpl_inf_dsqrt</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dsqrt.o(x$fpl$dsqrt), UNUSED)

<P><STRONG><a name="[11bd2f0]"></a>__aeabi_dsub</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dsub))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_dsub</UL>
<BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11bd27c]"></a>_dsub</STRONG> (ARM, 572 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11bd964]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
<LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c749c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11bd520]"></a>__fpl_inf_dsub</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)

<P><STRONG><a name="[11c64b8]"></a>__dunder</STRONG> (ARM, 272 bytes, Stack size 4 bytes, dunder.o(x$fpl$dunder), UNUSED)

<P><STRONG><a name="[11c6468]"></a>__dunder_d</STRONG> (ARM, 4 bytes, Stack size 0 bytes, dunder.o(x$fpl$dunder), UNUSED)

<P><STRONG><a name="[11b9f64]"></a>__aeabi_f2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, f2d.o(x$fpl$f2d))
<BR><BR>[Called By]<UL><LI><a href="#[b23424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[b240a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[f42520]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[f8c7d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume (via Veneer)
<LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig (via Veneer)
<LI><a href="#[f8f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[f8fa74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_ (via Veneer)
<LI><a href="#[f8faf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_ (via Veneer)
<LI><a href="#[f8fb6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_ (via Veneer)
<LI><a href="#[f8fbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_ (via Veneer)
<LI><a href="#[f8fc64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_ (via Veneer)
<LI><a href="#[f8fce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_ (via Veneer)
<LI><a href="#[f8fd5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_ (via Veneer)
<LI><a href="#[f8fdd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_ (via Veneer)
<LI><a href="#[f92808]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[fb46c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume (via Veneer)
<LI><a href="#[fc7214]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[11b9ef0]"></a>_f2d</STRONG> (ARM, 96 bytes, Stack size 0 bytes, f2d.o(x$fpl$f2d), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5a0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[11b9fb4]"></a>__fpl_inf_f2d</STRONG> (ARM, 0 bytes, Stack size unknown bytes, f2d.o(x$fpl$f2d), UNUSED)

<P><STRONG><a name="[11b954c]"></a>__aeabi_fadd</STRONG> (ARM, 0 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fadd))
<BR><BR>[Called By]<UL><LI><a href="#[b240a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[f8c758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume (via Veneer)
<LI><a href="#[1054644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
</UL>

<P><STRONG><a name="[11b94d8]"></a>_fadd</STRONG> (ARM, 260 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b978c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fsub1
<LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[11b9618]"></a>__fpl_inf_fadd</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)

<P><STRONG><a name="[11c5ea0]"></a>__fpl_fcheck_NaN2</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fcheck.o(x$fpl$fcheck), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11d2118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[11b5830]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fmul
<LI><a href="#[11b82c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fdiv
<LI><a href="#[11b9324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub
<LI><a href="#[11b94d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd
<LI><a href="#[11c55a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[11c5a0c]"></a>__fpl_fcheck_NaN1</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fcheck1.o(x$fpl$fcheck1), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11d2118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[11b6ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffixu
<LI><a href="#[11b76e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffix
<LI><a href="#[11b9ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_f2d
</UL>

<P><STRONG><a name="[11b833c]"></a>__aeabi_fdiv</STRONG> (ARM, 0 bytes, Stack size 4 bytes, fdiv.o(x$fpl$fdiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __aeabi_fdiv</UL>
<BR>[Called By]<UL><LI><a href="#[b240a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f42120]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[f42328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ (via Veneer)
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[f44948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[f8d4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[fc7214]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[11b82c8]"></a>_fdiv</STRONG> (ARM, 476 bytes, Stack size 4 bytes, fdiv.o(x$fpl$fdiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[11b8400]"></a>__fpl_inf_fdiv</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fdiv.o(x$fpl$fdiv), UNUSED)

<P><STRONG><a name="[11b45a8]"></a>__aeabi_cfcmpeq</STRONG> (ARM, 0 bytes, Stack size 0 bytes, feqf.o(x$fpl$feqf))
<BR><BR>[Called By]<UL><LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[f8d4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
</UL>

<P><STRONG><a name="[11b4534]"></a>_fcmpeq</STRONG> (ARM, 116 bytes, Stack size 0 bytes, feqf.o(x$fpl$feqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c55a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[11b7754]"></a>__aeabi_f2iz</STRONG> (ARM, 0 bytes, Stack size 0 bytes, ffix.o(x$fpl$ffix))
<BR><BR>[Called By]<UL><LI><a href="#[b22de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V (via Veneer)
<LI><a href="#[b2361c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM (via Veneer)
<LI><a href="#[f42120]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[f8d4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
</UL>

<P><STRONG><a name="[11b76e0]"></a>_ffix</STRONG> (ARM, 112 bytes, Stack size 0 bytes, ffix.o(x$fpl$ffix), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5a0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[11b7824]"></a>__fpl_inf_ffix</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ffix.o(x$fpl$ffix), UNUSED)

<P><STRONG><a name="[11b6c18]"></a>__aeabi_f2uiz</STRONG> (ARM, 0 bytes, Stack size 0 bytes, ffixu.o(x$fpl$ffixu))
<BR><BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase (via Veneer)
<LI><a href="#[f44948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[f8e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD (via Veneer)
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[f8e620]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS (via Veneer)
<LI><a href="#[f8e69c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS (via Veneer)
<LI><a href="#[f8e80c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP (via Veneer)
<LI><a href="#[f8e888]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP (via Veneer)
<LI><a href="#[f8e900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP (via Veneer)
<LI><a href="#[f8e97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP (via Veneer)
<LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT (via Veneer)
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT (via Veneer)
<LI><a href="#[f8eae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT (via Veneer)
<LI><a href="#[f8eb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT (via Veneer)
<LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX (via Veneer)
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL (via Veneer)
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL (via Veneer)
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR (via Veneer)
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR (via Veneer)
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR (via Veneer)
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC (via Veneer)
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL (via Veneer)
<LI><a href="#[f90fb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs (via Veneer)
<LI><a href="#[f9102c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL (via Veneer)
<LI><a href="#[f910a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR (via Veneer)
<LI><a href="#[f91124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL (via Veneer)
<LI><a href="#[f911a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR (via Veneer)
<LI><a href="#[f9121c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR (via Veneer)
<LI><a href="#[f91294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC (via Veneer)
<LI><a href="#[f9130c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL (via Veneer)
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX (via Veneer)
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL (via Veneer)
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR (via Veneer)
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL (via Veneer)
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR (via Veneer)
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR (via Veneer)
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC (via Veneer)
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL (via Veneer)
<LI><a href="#[f92000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid (via Veneer)
<LI><a href="#[f92448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs (via Veneer)
<LI><a href="#[f924c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL (via Veneer)
<LI><a href="#[f92538]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR (via Veneer)
<LI><a href="#[f925b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL (via Veneer)
<LI><a href="#[f92628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR (via Veneer)
<LI><a href="#[f926a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR (via Veneer)
<LI><a href="#[f92718]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC (via Veneer)
<LI><a href="#[f92790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL (via Veneer)
<LI><a href="#[fc7214]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[1054644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[10d8dc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value (via Veneer)
<LI><a href="#[10e33d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
<LI><a href="#[10e344c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q (via Veneer)
<LI><a href="#[10e34c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC (via Veneer)
</UL>

<P><STRONG><a name="[11b6ba4]"></a>_ffixu</STRONG> (ARM, 92 bytes, Stack size 0 bytes, ffixu.o(x$fpl$ffixu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5a0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[11b6ce8]"></a>__fpl_inf_ffixu</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ffixu.o(x$fpl$ffixu), UNUSED)

<P><STRONG><a name="[11b60d0]"></a>__aeabi_i2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$fflt))
<BR><BR>[Called By]<UL><LI><a href="#[b0f228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup (via Veneer)
<LI><a href="#[b240a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f41eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value (via Veneer)
<LI><a href="#[f42120]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[f72b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect (via Veneer)
<LI><a href="#[f73064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource (via Veneer)
<LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage (via Veneer)
<LI><a href="#[f8d4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[f8d5d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[fb4944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume (via Veneer)
<LI><a href="#[fb4ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel (via Veneer)
<LI><a href="#[fb5028]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel (via Veneer)
<LI><a href="#[ff16e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume (via Veneer)
<LI><a href="#[10e2f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config (via Veneer)
</UL>

<P><STRONG><a name="[11b605c]"></a>_fflt</STRONG> (ARM, 92 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$fflt), UNUSED)

<P><STRONG><a name="[11b61e4]"></a>__fflt_normalise</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fflt_noclz.o(x$fpl$fflt), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b6120]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffltu
</UL>

<P><STRONG><a name="[11b6194]"></a>__aeabi_ui2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$ffltu))
<BR><BR>[Called By]<UL><LI><a href="#[f26d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[f44948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[f90804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX (via Veneer)
<LI><a href="#[f9087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL (via Veneer)
<LI><a href="#[f908f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL (via Veneer)
<LI><a href="#[f90974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR (via Veneer)
<LI><a href="#[f909f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR (via Veneer)
<LI><a href="#[f90a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR (via Veneer)
<LI><a href="#[f90ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC (via Veneer)
<LI><a href="#[f90b64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL (via Veneer)
<LI><a href="#[f91ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX (via Veneer)
<LI><a href="#[f91c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL (via Veneer)
<LI><a href="#[f91c98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR (via Veneer)
<LI><a href="#[f91d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL (via Veneer)
<LI><a href="#[f91d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR (via Veneer)
<LI><a href="#[f91e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR (via Veneer)
<LI><a href="#[f91e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC (via Veneer)
<LI><a href="#[f91f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL (via Veneer)
</UL>

<P><STRONG><a name="[11b6120]"></a>_ffltu</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$ffltu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b61e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fflt_normalise
</UL>

<P><STRONG><a name="[11b401c]"></a>__aeabi_cfcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fleqf.o(x$fpl$fleqf))
<BR><BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[f426a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[f8d4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
</UL>

<P><STRONG><a name="[11b3fa8]"></a>_fcmple</STRONG> (ARM, 116 bytes, Stack size 0 bytes, fleqf.o(x$fpl$fleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c55a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[11b58a4]"></a>__aeabi_fmul</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fmul.o(x$fpl$fmul))
<BR><BR>[Called By]<UL><LI><a href="#[b240a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f42120]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[f8d4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[f8e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[f8e5a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[f8e9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT (via Veneer)
<LI><a href="#[f8ea70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[fc7214]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[1054644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[10d8dc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value (via Veneer)
<LI><a href="#[10e33d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
<LI><a href="#[10e344c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q (via Veneer)
<LI><a href="#[10e34c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC (via Veneer)
</UL>

<P><STRONG><a name="[11b5830]"></a>_fmul</STRONG> (ARM, 260 bytes, Stack size 0 bytes, fmul.o(x$fpl$fmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[11b58f4]"></a>__fpl_inf_fmul</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fmul.o(x$fpl$fmul), UNUSED)

<P><STRONG><a name="[11c503c]"></a>__fpl_normalise2</STRONG> (ARM, 148 bytes, Stack size 0 bytes, fnorm2_noclz.o(x$fpl$fnorm2), UNUSED)

<P><STRONG><a name="[11ed8c0]"></a>_fp_init</STRONG> (ARM, 24 bytes, Stack size 8 bytes, fpinit.o(x$fpl$fpinit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _fp_init</UL>
<BR>[Calls]<UL><LI><a href="#[11ec054]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_fp_status_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[11ed7b4]"></a>__fplib_config_pureend_doubles</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[11b3a88]"></a>__aeabi_cfrcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, frleqf.o(x$fpl$frleqf))
<BR><BR>[Called By]<UL><LI><a href="#[f424a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[f425a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[f8f494]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[f92808]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[1054644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[10e33d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
</UL>

<P><STRONG><a name="[11b3a10]"></a>_frcmple</STRONG> (ARM, 128 bytes, Stack size 0 bytes, frleqf.o(x$fpl$frleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11c55a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[11b9398]"></a>__aeabi_fsub</STRONG> (ARM, 0 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fsub))
<BR><BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase (via Veneer)
<LI><a href="#[f44948]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
</UL>

<P><STRONG><a name="[11b9324]"></a>_fsub</STRONG> (ARM, 356 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b9968]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fadd1
<LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c5ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[11b959c]"></a>__fpl_inf_fsub</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)

<P><STRONG><a name="[11c4b40]"></a>__funder</STRONG> (ARM, 140 bytes, Stack size 0 bytes, funder.o(x$fpl$funder), UNUSED)

<P><STRONG><a name="[11c4af0]"></a>__funder_d</STRONG> (ARM, 4 bytes, Stack size 0 bytes, funder.o(x$fpl$funder), UNUSED)

<P><STRONG><a name="[11f1af0]"></a>__ieee_status</STRONG> (ARM, 8 bytes, Stack size 0 bytes, istatus.o(x$fpl$ieeestatus))
<BR><BR>[Called By]<UL><LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[11b34dc]"></a>_printf_fp_dec</STRONG> (ARM, 4 bytes, Stack size 0 bytes, printf1.o(x$fpl$printf1))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11c9bd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (via Veneer)
</UL>

<P><STRONG><a name="[11c3e34]"></a>_printf_fp_hex</STRONG> (ARM, 4 bytes, Stack size 0 bytes, printf2.o(x$fpl$printf2))
<BR><BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (via Veneer)
</UL>

<P><STRONG><a name="[11d2118]"></a>__fpl_return_NaN</STRONG> (ARM, 116 bytes, Stack size 0 bytes, retnan.o(x$fpl$retnan))
<BR><BR>[Calls]<UL><LI><a href="#[11f1fa4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[11c5a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
<LI><a href="#[11c5ea0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
<LI><a href="#[11c6f84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
<LI><a href="#[11c749c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11c4358]"></a>__ARM_scalbn</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[11c43d4]"></a>scalbln</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[11c4448]"></a>scalblnl</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[11c45b4]"></a>scalbn</STRONG> (ARM, 108 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn))
<BR><BR>[Calls]<UL><LI><a href="#[11be074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11c6f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>
<BR>[Called By]<UL><LI><a href="#[11b1dd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[11f11e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__support_dtoi
</UL>

<P><STRONG><a name="[11c44c0]"></a>scalbnl</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[11c4534]"></a>__fpl_inf_scalbn</STRONG> (ARM, 0 bytes, Stack size unknown bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[11f1fa4]"></a>__fpl_cmpreturn</STRONG> (ARM, 60 bytes, Stack size 0 bytes, trapv.o(x$fpl$trapveneer))
<BR><BR>[Called By]<UL><LI><a href="#[11c55a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
<LI><a href="#[11c6ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
<LI><a href="#[11d2118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>

<P><STRONG><a name="[a66c74]"></a>Undef_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66c74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66c74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66bfc]"></a>SWI_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66bfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SWI_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66bfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SWI_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66b80]"></a>PAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66b80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66b80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66b04]"></a>DAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66b04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66b04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66a8c]"></a>IRQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66a8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66a14]"></a>FIQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[b1c96c]"></a>panel_convert_key_value</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, key_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1c8f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[b1c8f4]"></a>read_key</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1b380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read165
<LI><a href="#[b1b670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HeadphoneDetect
<LI><a href="#[b1c96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;panel_convert_key_value
</UL>
<BR>[Called By]<UL><LI><a href="#[b1c77c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[b1c878]"></a>proc_key_press</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = proc_key_press -> MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1b4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[b1c77c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[b1c7fc]"></a>proc_key_hold</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 728 + Unknown Stack Size
<LI>Call Chain = proc_key_hold -> MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1b4fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[b1c77c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[b1c77c]"></a>GetPanelKeyThread</STRONG> (Thumb, 94 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = GetPanelKeyThread -> read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b1c7fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;proc_key_hold
<LI><a href="#[b1c878]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;proc_key_press
<LI><a href="#[b1c8f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>
<BR>[Called By]<UL><LI><a href="#[b1b574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;key_task
</UL>

<P><STRONG><a name="[b30938]"></a>IsMsgQueueEmpty</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, message.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a602b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage
</UL>

<P><STRONG><a name="[b308bc]"></a>IsMsgQueueFull</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b30108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage
<LI><a href="#[b30180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage
</UL>

<P><STRONG><a name="[f76b08]"></a>Zone1ProcessKey</STRONG> (Thumb, 1476 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 1080 + Unknown Stack Size
<LI>Call Chain = Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f26278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[f26b54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[f71964]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[f71e28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[f72334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[f724bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey
<LI><a href="#[f72534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[f725b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[f7262c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[f726a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[f72724]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[f727a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[f7281c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[f72898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[f72914]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[f72b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[f72cfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[f72d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[f73260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[f7e6ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[f8c0fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[f8c17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f8c364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[f8c668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[f8c948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cd24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8ce94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[f8d564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[f8d654]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[fb45d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f261f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[f4d370]"></a>Zone2ProcessKey</STRONG> (Thumb, 816 bytes, Stack size 16 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = Zone2ProcessKey -> Zone2RadioMode -> VfdTempDisp -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f4c188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[f8be90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8bf0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[f8c1f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[f8c5ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[f8caac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[f8cc24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[f8cd24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[f8cd9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[f8ce14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[f8d200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[f8d27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[f8d374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[f8d9bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f81be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[f44948]"></a>GetCrossoverPoint</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GetCrossoverPoint -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[11b6194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11b6c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[11b833c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[11b9398]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fsub (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f42224]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[ff9358]"></a>get_freq</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f81c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff9174]"></a>PreProcDigitKey</STRONG> (Thumb, 144 bytes, Stack size 4 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = PreProcDigitKey</UL>
<BR>[Calls]<UL><LI><a href="#[11b3014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ff90fc]"></a>SaveExit</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = SaveExit -> MsgSetVfdShow -> SendMessage -> assert_Function -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f8cb28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6880]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[ff9084]"></a>SaveInit</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 936 + Unknown Stack Size
<LI>Call Chain = SaveInit -> UpdateSaveVfd -> VfdDisplay -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[ff6880]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5f94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[102b360]"></a>i2c_ack</STRONG> (Thumb, 286 bytes, Stack size 24 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[11b2b8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[100b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102adac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[102b1f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
</UL>

<P><STRONG><a name="[102b2e8]"></a>i2c_start</STRONG> (Thumb, 102 bytes, Stack size 8 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = i2c_start</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[100b4c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[100b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102adac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[102ae28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
</UL>

<P><STRONG><a name="[102b270]"></a>i2c_stop</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = i2c_stop</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[100b4c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[100b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102adac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[102ae28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
</UL>

<P><STRONG><a name="[102b1f4]"></a>i2c_writebyte</STRONG> (Thumb, 168 bytes, Stack size 16 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102b360]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[100b4c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[100b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102adac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[102ae28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
</UL>

<P><STRONG><a name="[102b178]"></a>i2c_readbyte</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = i2c_readbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[11b2ac0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[11b2b8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[100b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102adac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
</UL>

<P><STRONG><a name="[1024a3c]"></a>Iec4094Sendbyte</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1023da8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetData4094
<LI><a href="#[1023f10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094Clk
</UL>
<BR>[Called By]<UL><LI><a href="#[102450c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>

<P><STRONG><a name="[1054dd4]"></a>Mas9116WriteWord</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[fb4848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1004990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1004af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[10544d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[10545c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[fe89f8]"></a>CheckInputChannel</STRONG> (Thumb, 396 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 824 + Unknown Stack Size
<LI>Call Chain = CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f723b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[f72434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[fe7a74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
<LI><a href="#[fe7b74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelectChannel
<LI><a href="#[ff5f10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[100b634]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
</UL>
<BR>[Called By]<UL><LI><a href="#[f71674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[f722bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[fe7974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSelectInputChannel
</UL>

<P><STRONG><a name="[fd01b0]"></a>Write_Byte</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Write_Byte</UL>
<BR>[Calls]<UL><LI><a href="#[103d904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_MOSI
<LI><a href="#[103d980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
</UL>
<BR>[Called By]<UL><LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[fcf908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[fd0138]"></a>ReadByteDsp</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[103d888]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Sense_Spi_MISO
<LI><a href="#[103d980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[103daec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>
<BR>[Called By]<UL><LI><a href="#[fcf88c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>

<P><STRONG><a name="[11107b4]"></a>__arm_div4</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[111040c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[111073c]"></a>__arm_div8</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[111040c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[11106c0]"></a>__arm_div_large</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[111040c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[11bd964]"></a>_dadd1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11bd27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[11bd340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drsb
</UL>

<P><STRONG><a name="[11bd788]"></a>_dsub1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11bd340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drsb
<LI><a href="#[11bd430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd
</UL>

<P><STRONG><a name="[11b9968]"></a>_fadd1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b9324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub
</UL>

<P><STRONG><a name="[11b978c]"></a>_fsub1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b94d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd
</UL>

<P><STRONG><a name="[11c9d98]"></a>_fp_digits</STRONG> (Thumb, 492 bytes, Stack size 96 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11dd97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul (via Veneer)
<LI><a href="#[11dd9cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv (via Veneer)
<LI><a href="#[11dda1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e (via Veneer)
<LI><a href="#[11de914]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_etento
<LI><a href="#[11def34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10 (via Veneer)
<LI><a href="#[11f11e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__support_dtoi (via Veneer)
<LI><a href="#[11f1af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ieee_status (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>

<P><STRONG><a name="[11c9d20]"></a>_fp_addexp</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _fp_addexp</UL>
<BR>[Calls]<UL><LI><a href="#[11104d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11ccb88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11c9c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>

<P><STRONG><a name="[11d4aa4]"></a>__ARM_exceptions_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11ccb88]"></a>__ARM_stackcheck</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11c9bd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real (Weak Reference)
<LI><a href="#[11c9c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (Weak Reference)
<LI><a href="#[11c9d20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp (Weak Reference)
<LI><a href="#[11c9d98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (Weak Reference)
<LI><a href="#[11ccc88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__set_errno (Weak Reference)
<LI><a href="#[11cccd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__read_errno (Weak Reference)
<LI><a href="#[11d4ba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
<LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
<LI><a href="#[11d82b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
<LI><a href="#[11d88a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (Weak Reference)
<LI><a href="#[11d9208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb (Weak Reference)
<LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
<LI><a href="#[11de914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (Weak Reference)
<LI><a href="#[11eac2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (Weak Reference)
</UL>

<P><STRONG><a name="[11d4a28]"></a>__Heap_DescSize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d49a8]"></a>__alloca_initialize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d4920]"></a>__cpp_initialize__aeabi_</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d48a4]"></a>__cxa_finalize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4ba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>

<P><STRONG><a name="[11be074]"></a>__fpl_infinity</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11b5830]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fmul (Weak Reference)
<LI><a href="#[11b6ba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffixu (Weak Reference)
<LI><a href="#[11b76e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffix (Weak Reference)
<LI><a href="#[11b82c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fdiv (Weak Reference)
<LI><a href="#[11b9324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub (Weak Reference)
<LI><a href="#[11b94d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd (Weak Reference)
<LI><a href="#[11b9ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_f2d (Weak Reference)
<LI><a href="#[11ba7b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dmul (Weak Reference)
<LI><a href="#[11bc040]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv (Weak Reference)
<LI><a href="#[11bd27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub (Weak Reference)
<LI><a href="#[11bd430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd (Weak Reference)
<LI><a href="#[11bdf34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2f (Weak Reference)
<LI><a href="#[11c45b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;scalbn (Weak Reference)
<LI><a href="#[11c55a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN (Weak Reference)
<LI><a href="#[11c6ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN (Weak Reference)
<LI><a href="#[11d27cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsqrt (Weak Reference)
</UL>

<P><STRONG><a name="[11bef34]"></a>__user_heap_extend</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED, UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11bed50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[11d4828]"></a>_atexit_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d81e8]"></a>_call_atexit_fns</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d82b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
</UL>

<P><STRONG><a name="[11d47b0]"></a>_clock_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d4734]"></a>_fp_trap_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d46b8]"></a>_get_lc_collate</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d45bc]"></a>_get_lc_monetary</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d4540]"></a>_get_lc_time</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d44c4]"></a>_getenv_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d444c]"></a>_init_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d43cc]"></a>_init_user_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d4358]"></a>_initio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11dad68]"></a>_printf_mbtowc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
</UL>

<P><STRONG><a name="[11dacf0]"></a>_printf_wc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11dade4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
</UL>

<P><STRONG><a name="[11d42e0]"></a>_rand_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d4264]"></a>_signal_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11d41e0]"></a>_terminate_user_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4ba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>

<P><STRONG><a name="[11d4164]"></a>_terminateio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11d4ba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>
<HR></body></html>
