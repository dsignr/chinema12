<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\obj\C11_Audio.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\obj\C11_Audio.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, RVCT3.0 [Build 951]: Last Updated: Wed Apr 08 17:50:34 2009
<BR><P>
<H3>Maximum Stack Usage =        820 bytes + Unknown(Functions without stacksize,Cycles,Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
ASProcSetBalance -> GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq<P>
<H3>
Functions with no stack information
</H3><UL>
 <LI><a href="#[b46694]">Reset_Handler</a>
 <LI><a href="#[11c5d1c]">__scatterload</a>
 <LI><a href="#[11c5c4c]">__scatterload_rt2</a>
 <LI><a href="#[11c5c9c]">__scatterload_null</a>
 <LI><a href="#[11c6478]">__decompress</a>
 <LI><a href="#[11c6428]">__decompress1</a>
 <LI><a href="#[11c576c]">__scatterload_zeroinit</a>
 <LI><a href="#[b46514]">__user_initial_stackheap</a>
 <LI><a href="#[11b7acc]">_memcpy_lastbytes</a>
 <LI><a href="#[11b74d4]">_memcpy_lastbytes_aligned</a>
 <LI><a href="#[1269c48]">__ARM_call_via_r0</a>
 <LI><a href="#[1269c98]">__call_via_r0</a>
 <LI><a href="#[1269b7c]">__ARM_call_via_r1</a>
 <LI><a href="#[1269bcc]">__call_via_r1</a>
 <LI><a href="#[1269ab0]">__ARM_call_via_r2</a>
 <LI><a href="#[1269b00]">__call_via_r2</a>
 <LI><a href="#[12699e4]">__ARM_call_via_r3</a>
 <LI><a href="#[1269a34]">__call_via_r3</a>
 <LI><a href="#[12698e8]">__ARM_call_via_r4</a>
 <LI><a href="#[1269968]">__call_via_r4</a>
 <LI><a href="#[12697ec]">__ARM_call_via_r5</a>
 <LI><a href="#[126986c]">__call_via_r5</a>
 <LI><a href="#[12696f0]">__ARM_call_via_r6</a>
 <LI><a href="#[1269770]">__call_via_r6</a>
 <LI><a href="#[12695f4]">__ARM_call_via_r7</a>
 <LI><a href="#[1269674]">__call_via_r7</a>
 <LI><a href="#[127ef10]">_memset</a>
 <LI><a href="#[128e6c8]">_memset_w</a>
 <LI><a href="#[11b26dc]">__fpl_inf_d2f</a>
 <LI><a href="#[11b1c80]">__fpl_inf_dadd</a>
 <LI><a href="#[127d894]">__fpl_inf_dcmp</a>
 <LI><a href="#[127c3cc]">__fpl_inf_fcmp</a>
 <LI><a href="#[11b085c]">__fpl_inf_ddiv</a>
 <LI><a href="#[11af870]">__dflt_normalise</a>
 <LI><a href="#[11aef58]">__fpl_inf_dmul</a>
 <LI><a href="#[12890f8]">__fpl_inf_dsqrt</a>
 <LI><a href="#[11b1c04]">__fpl_inf_dsub</a>
 <LI><a href="#[1271070]">__fpl_inf_f2d</a>
 <LI><a href="#[12706d4]">__fpl_inf_fadd</a>
 <LI><a href="#[126f4bc]">__fpl_inf_fdiv</a>
 <LI><a href="#[126e8e0]">__fpl_inf_ffix</a>
 <LI><a href="#[126dda4]">__fpl_inf_ffixu</a>
 <LI><a href="#[126d2a0]">__fflt_normalise</a>
 <LI><a href="#[126c9b0]">__fpl_inf_fmul</a>
 <LI><a href="#[1283d08]">__fplib_config_pureend_doubles</a>
 <LI><a href="#[1270658]">__fpl_inf_fsub</a>
 <LI><a href="#[127b3dc]">__fpl_inf_scalbn</a>
 <LI><a href="#[b46c84]">Undef_Handler</a>
 <LI><a href="#[b46c0c]">SWI_Handler</a>
 <LI><a href="#[b46b90]">PAbt_Handler</a>
 <LI><a href="#[b46b14]">DAbt_Handler</a>
 <LI><a href="#[b46a9c]">IRQ_Handler</a>
 <LI><a href="#[b46a24]">FIQ_Handler</a>
 <LI><a href="#[11b6570]">__arm_div4</a>
 <LI><a href="#[11b64f8]">__arm_div8</a>
 <LI><a href="#[11b647c]">__arm_div_large</a>
 <LI><a href="#[11b2048]">_dadd1</a>
 <LI><a href="#[11b1e6c]">_dsub1</a>
 <LI><a href="#[1270a24]">_fadd1</a>
 <LI><a href="#[1270848]">_fsub1</a>
</UL>
<P>
<H3>
Mutually Recursive functions
</H3><UL>
 <LI><a href="#[109fb90]">DSP_CFG_VIRTUALIZER</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[109fc10]">DSP_CFG_PPM_Mode</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[109fc90]">DSP_CFG_PPM</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[109fd08]">DSP_CFG_MATRIX</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[109fd84]">DSP_CFG_DECODER</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[109fe00]">DSP_BOOT</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1193aec]">DSP_CFG_MCLK_FACTOR</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1193bf0]">DSP_CFG_AUDIO_SRC</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10b5108]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[b46c84]">Undef_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[b46c84]">Undef_Handler</a><BR>
 <LI><a href="#[b46c0c]">SWI_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[b46c0c]">SWI_Handler</a><BR>
 <LI><a href="#[b46b90]">PAbt_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[b46b90]">PAbt_Handler</a><BR>
 <LI><a href="#[b46b14]">DAbt_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[b46b14]">DAbt_Handler</a><BR>
 <LI><a href="#[b46a9c]">IRQ_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[b46a9c]">IRQ_Handler</a><BR>
 <LI><a href="#[b46a24]">FIQ_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[b46a24]">FIQ_Handler</a><BR>
</UL>
<BR>
<P><STRONG><a name="[b46694]"></a>Reset_Handler</STRONG> (ARM, 0 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[11b2e04]"></a>__main</STRONG> (ARM, 8 bytes, Stack size 0 bytes, __main.o(!!!main))
<BR><BR>[Stack]<UL><LI>Max Depth = 68 + Unknown Stack Size
<LI>Call Chain = __main -> __rt_entry -> __rt_lib_init -> _get_lc_ctype -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[11c5d1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
<LI><a href="#[12667f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11c5d1c]"></a>__scatterload</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[11b2e04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[11c5c4c]"></a>__scatterload_rt2</STRONG> (ARM, 48 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12667f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11c5c9c]"></a>__scatterload_null</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[11c6478]"></a>__decompress</STRONG> (ARM, 92 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[11c6428]"></a>__decompress1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[11c576c]"></a>__scatterload_zeroinit</STRONG> (ARM, 44 bytes, Stack size unknown bytes, __scatter_zi.o(!!handler_zi), UNUSED)

<P><STRONG><a name="[128b598]"></a>__ARM_argv_veneer</STRONG> (ARM, 16 bytes, Stack size 0 bytes, lib_init.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[b46514]"></a>__user_initial_stackheap</STRONG> (ARM, 0 bytes, Stack size unknown bytes, lpc2300.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1265e74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[b40638]"></a>Systeminit</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = Systeminit -> HardwareInit -> SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b40170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitRemoteRepeatKey
<LI><a href="#[b4026c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[b404c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[c21c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UartInit
<LI><a href="#[c21cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Timer0Init
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b405bc]"></a>ProcDimerOff</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = ProcDimerOff -> VfdSetDimerValue -> VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[c21b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
</UL>
<BR>[Called By]<UL><LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106d2b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[b40548]"></a>main</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = main -> Timer0_Handler -> RadioDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b40074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[b400ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[b401f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMsgQueue
<LI><a href="#[b402e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[b40364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMessage
<LI><a href="#[b403dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[b40638]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Systeminit
<LI><a href="#[c21b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[c21b88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
<LI><a href="#[c21c78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[c21d6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[c21de8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[c21e60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[1269c48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Address Reference Count : 1]<UL><LI> kernel.o(.text)
</UL>
<P><STRONG><a name="[c0110c]"></a>rs232_printf</STRONG> (Thumb, 62 bytes, Stack size 160 bytes, debug.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c01094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b8e44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[b40450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[ff7c8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[ff82c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTT_
<LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[ff9784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ1VFD_
<LI><a href="#[ff9800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[ff9884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_
<LI><a href="#[ff9900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_
<LI><a href="#[ff997c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_
<LI><a href="#[ff99f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_
<LI><a href="#[ff9a74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_
<LI><a href="#[ff9af0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_
<LI><a href="#[ff9b6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_
<LI><a href="#[ff9be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_
<LI><a href="#[ff9c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[ff9ce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[ff9d5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[ff9dd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[ffcacc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ2VFD_
<LI><a href="#[ffcb48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2_
<LI><a href="#[ffcc38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[ffcda4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[ffd3f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1DF_
<LI><a href="#[ffd46c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[ffd4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EU
<LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[ffd5d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[ffd6d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ES
<LI><a href="#[ffd748]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EE
<LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[ffd8bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ED
<LI><a href="#[ffd934]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1D
<LI><a href="#[ffd9ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1C
<LI><a href="#[ffda24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1A_
<LI><a href="#[ffdb14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[ffdc80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[bfd3a4]"></a>InitQueue</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, queue.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[10dc658]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
<LI><a href="#[10dc7c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>

<P><STRONG><a name="[bfd328]"></a>IsQueueEmpty</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b40450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[bfd0d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
<LI><a href="#[bfd1c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[1018730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[10187b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[bfd2b0]"></a>IsQueueFull</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bfd0d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
<LI><a href="#[bfd150]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InQueue
</UL>

<P><STRONG><a name="[bfd238]"></a>QueueFront</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, queue.o(.text), UNUSED)

<P><STRONG><a name="[bfd1c4]"></a>DeQueue</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DeQueue -> IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[bfd328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b40450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[1018730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[10187b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[bfd150]"></a>InQueue</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bfd2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10dc750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Isr (via Veneer)
<LI><a href="#[10dc8c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Isr (via Veneer)
</UL>

<P><STRONG><a name="[bfd0d0]"></a>GetQueueElementNum</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bfd2b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull
<LI><a href="#[bfd328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
</UL>
<BR>[Called By]<UL><LI><a href="#[bfd04c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementRemain
</UL>

<P><STRONG><a name="[bfd04c]"></a>GetQueueElementRemain</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bfd0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
</UL>

<P><STRONG><a name="[bfcfd0]"></a>GetQueueElement</STRONG> (Thumb, 48 bytes, Stack size 40 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[bf992c]"></a>SetDspPower</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 84<LI>Call Chain = SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf94dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[10b5108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[bf98b4]"></a>SetDspDelay</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf95d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[ff21a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>

<P><STRONG><a name="[bf9838]"></a>SetDspCorner</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[bf964c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner
</UL>
<BR>[Called By]<UL><LI><a href="#[be59bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
</UL>

<P><STRONG><a name="[bf97bc]"></a>SetDspSpkMode</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[bf93e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcSpkMode
</UL>
<BR>[Called By]<UL><LI><a href="#[be5a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[ffb194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[ffb20c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[ffb284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[ffb300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[ffb37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[ffb3f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[ffb474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[ffb4ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[ffbe90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[ffbf08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[ffbf80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[ffbffc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[ffc078]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[ffc0f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[ffc168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[ffc1e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
</UL>

<P><STRONG><a name="[bf9740]"></a>SetDspSignal</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf9460]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[ff2124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceTestSignal
</UL>

<P><STRONG><a name="[bf96c8]"></a>SetDspIrc</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = SetDspIrc -> DspProcIrc -> InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf9558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>
<BR>[Called By]<UL><LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[bf0cf8]"></a>HeadphoneDetect</STRONG> (Thumb, 154 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bf0b84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[bf1f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[bf0c74]"></a>GetEncoderSwitchThread</STRONG> (Thumb, 378 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetEncoderSwitchThread</UL>
<BR>[Calls]<UL><LI><a href="#[bf0a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseEncoderSwitchPlus
<LI><a href="#[bf0b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseEncoderSwitchMinus
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[bf0bfc]"></a>key_task</STRONG> (Thumb, 168 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = key_task -> GetPanelKeyThread -> read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bf0b84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
<LI><a href="#[bf1e04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[b401f0]"></a>InitMsgQueue</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, message.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1009f4c]"></a>PostMessage</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, message.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[100a688]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>

<P><STRONG><a name="[1009ed4]"></a>SendMessage</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[100a688]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bf0b84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
<LI><a href="#[ff68bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6938]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff69b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6a34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ff6ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[ff6b34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff6bac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[ff6c24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff6ca4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[1018d24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSavePreset
<LI><a href="#[1018da8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgTextDisplay
<LI><a href="#[102bbe4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[1048c7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDspChannel
<LI><a href="#[1048cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[1048d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[1048e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[106d138]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
</UL>

<P><STRONG><a name="[b40364]"></a>GetMessage</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetMessage</UL>
<BR>[Calls]<UL><LI><a href="#[100a704]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueEmpty
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[ffdef8]"></a>GetProtocolFloatValue</STRONG> (Thumb, 180 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = GetProtocolFloatValue -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1270608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff8154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[ff861c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[ff8698]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[ff8710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[ff878c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[ff8804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[ff8880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[ff88f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[ff8974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[ff8ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[ff8f40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[ff8fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[ff9038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[ff90b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[ff9130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[ff91ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[ff9228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[ffa234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[ffa2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[ffa32c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[ffa3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[ffa424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[ffa4a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[ffa51c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[ffa598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[ffa614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[ffa68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[ffa708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[ffa784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[ffa800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[ffa87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[ffa8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[ffa974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[ffa9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[ffaa6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[ffaae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[ffab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[ffabe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[ffac5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[ffacd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[ffad4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[ffadc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[ffae3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[ffaeb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[ffaf34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[ffafb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[ffb02c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[ffb0a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[ffb11c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[ffb9b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[ffba2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[ffbaa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[ffbb24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[ffbba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[ffbc1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[ffbc98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[ffbd14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
<LI><a href="#[ffc258]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[ffc2d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[ffc348]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[ffc3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[ffc438]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[ffc4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[ffc528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[ffc5a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
<LI><a href="#[ffc694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[ffc70c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[ffc784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[ffc7fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[ffc874]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[ffc8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[ffc964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[ffc9dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[ffcc38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[ffce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[ffcf10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[ffcf8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[ffd008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[ffd084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[ffd100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[ffd17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[ffd1f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[ffd46c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
</UL>

<P><STRONG><a name="[ffde74]"></a>IsProtocolStringValid</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff8060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
<LI><a href="#[ffca54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
</UL>

<P><STRONG><a name="[ffddfc]"></a>ProcCmdSPU</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffdd78]"></a>GetCurrentDecodeStatus</STRONG> (Thumb, 68 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ffdc80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[ffdcf8]"></a>GetPcmDecodeMode</STRONG> (Thumb, 126 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetPcmDecodeMode</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffd4e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EU
<LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[ffdc80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[ffdc80]"></a>ProcCmdZ1_</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ffdcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[ffdd78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurrentDecodeStatus
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffdc04]"></a>GetZone1Channel</STRONG> (Thumb, 158 bytes, Stack size 8 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetZone1Channel</UL>
<BR>[Calls]<UL><LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
</UL>

<P><STRONG><a name="[ffdb8c]"></a>ProcCmdZ1S</STRONG> (Thumb, 272 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1S -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff67d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[ffdc04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffdb14]"></a>ProcCmdZ1P</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1P -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6b34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff6f1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1PowerOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffda9c]"></a>ProcCmdZ1M</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ProcCmdZ1M -> MsgSetMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffda24]"></a>ProcCmdZ1A_</STRONG> (Thumb, 118 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1A_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd9ac]"></a>ProcCmdZ1C</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1C -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd934]"></a>ProcCmdZ1D</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1D -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd8bc]"></a>ProcCmdZ1ED</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ED -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff765c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd838]"></a>GetDolby2ChDecodeMode</STRONG> (Thumb, 108 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
</UL>

<P><STRONG><a name="[ffd7c0]"></a>ProcCmdZ1EF</STRONG> (Thumb, 244 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EF -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff755c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[ff76d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ffd838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDolby2ChDecodeMode
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd748]"></a>ProcCmdZ1EE</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EE -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd6d0]"></a>ProcCmdZ1ES</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ES -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd64c]"></a>GetDolby5ChDecodeMode</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ffd5d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
</UL>

<P><STRONG><a name="[ffd5d4]"></a>ProcCmdZ1EX</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EX -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff76d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[ffd64c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDolby5ChDecodeMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd55c]"></a>ProcCmdZ1E</STRONG> (Thumb, 388 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1E -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff755c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[ff75e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ffdcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd4e4]"></a>ProcCmdZ1EU</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EU -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ffdcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd46c]"></a>ProcCmdZ1VM</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VM -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6e9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126e810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd3f0]"></a>ProcCmdZ1DF_</STRONG> (Thumb, 214 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1DF_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd374]"></a>ProtocolSetEq</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff73e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ffa234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[ffa2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[ffa32c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[ffa3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[ffa424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[ffa4a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[ffa51c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[ffa598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[ffce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[ffcf10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[ffcf8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[ffd008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[ffd084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[ffd100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[ffd17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[ffd1f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
</UL>

<P><STRONG><a name="[ffd2f0]"></a>IsProtocolEqBandValid</STRONG> (Thumb, 58 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsProtocolEqBandValid</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffa234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[ffa2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[ffa32c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[ffa3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[ffa424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[ffa4a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[ffa51c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[ffa598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[ffce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[ffcf10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[ffcf8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[ffd008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[ffd084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[ffd100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[ffd17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[ffd1f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
</UL>

<P><STRONG><a name="[ffd274]"></a>IsBalanceValid</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsBalanceValid</UL>
<BR>[Calls]<UL><LI><a href="#[126bcb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[126c260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffa234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[ffa2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[ffa32c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[ffa3a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[ffa424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[ffa4a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[ffa51c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[ffa598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[ffa9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[ffaa6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[ffaae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[ffab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[ffabe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[ffac5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[ffacd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[ffad4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[ffc694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[ffc70c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[ffc784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[ffc7fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[ffc874]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[ffc8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[ffc964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[ffc9dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[ffce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[ffcf10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[ffcf8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[ffd008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[ffd084]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[ffd100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[ffd17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[ffd1f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
</UL>

<P><STRONG><a name="[ffd1f8]"></a>ProcCmdZ1EQL</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd17c]"></a>ProcCmdZ1EQC</STRONG> (Thumb, 164 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQC -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd100]"></a>ProcCmdZ1EQR</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd084]"></a>ProcCmdZ1EQSR</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffd008]"></a>ProcCmdZ1EQBSR</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQBSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcf8c]"></a>ProcCmdZ1EQBSL</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQBSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcf10]"></a>ProcCmdZ1EQSL</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffce94]"></a>ProcCmdZ1EQSW</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSW -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffce1c]"></a>ProcCmdZ1EQ</STRONG> (Thumb, 148 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQ -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff7374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcda4]"></a>ProcCmdZ2P</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2P -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6b34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff6e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcd28]"></a>GetZone2Channel</STRONG> (Thumb, 108 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetZone2Channel</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
</UL>

<P><STRONG><a name="[ffccb0]"></a>ProcCmdZ2S</STRONG> (Thumb, 608 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2S -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff5ca0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff5d1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff7184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[ffcd28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetZone2Channel
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcc38]"></a>ProcCmdZ2V</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2V -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6e9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126e810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcbc0]"></a>ProcCmdZ2M</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ProcCmdZ2M -> MsgSetMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcb48]"></a>ProcCmdZ2_</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffcacc]"></a>ProCmdZ2VFD_</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProCmdZ2VFD_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffca54]"></a>ProcCmdRSN</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdRSN -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5e94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[ffde74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolStringValid
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc9dc]"></a>ProcCmdSLL</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc964]"></a>ProcCmdSLC</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc8ec]"></a>ProcCmdSLR</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc874]"></a>ProcCmdSLSR</STRONG> (Thumb, 126 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc7fc]"></a>ProcCmdSLSL</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc784]"></a>ProcCmdSLBR</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLBR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc70c]"></a>ProcCmdSLBL</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLBL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc694]"></a>ProcCmdSLSW</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSW -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc618]"></a>IsDistanceValid</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsDistanceValid</UL>
<BR>[Calls]<UL><LI><a href="#[126ab44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[126c260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff8154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[ffadc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[ffae3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[ffaeb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[ffaf34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[ffafb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[ffb02c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[ffb0a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[ffb11c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[ffc258]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[ffc2d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[ffc348]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[ffc3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[ffc438]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[ffc4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[ffc528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[ffc5a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
</UL>

<P><STRONG><a name="[ffc5a0]"></a>ProcCmdSPL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc528]"></a>ProcCmdSPC</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPC -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc4b0]"></a>ProcCmdSPR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc438]"></a>ProcCmdSPSR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPSR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc3c0]"></a>ProcCmdSPSL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPSL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc348]"></a>ProcCmdSPBR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPBR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc2d0]"></a>ProcCmdSPBL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPBL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc258]"></a>ProcCmdSPs</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPs -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc1e0]"></a>ProcCmdSZL</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc168]"></a>ProcCmdSZR</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc0f0]"></a>ProcCmdSZSL</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffc078]"></a>ProcCmdSZSR</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbffc]"></a>ProcCmdSZSBL</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSBL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbf80]"></a>ProcCmdSZSBR</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSBR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbf08]"></a>ProcCmdSZC</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZC -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbe90]"></a>ProcCmdSZS</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZS -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbe10]"></a>IsCrossoverValid</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = IsCrossoverValid</UL>
<BR>[Calls]<UL><LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffa614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[ffa68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[ffa708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[ffa784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[ffa800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[ffa87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[ffa8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[ffa974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[ffb9b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[ffba2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[ffbaa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[ffbb24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[ffbba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[ffbc1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[ffbc98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[ffbd14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>

<P><STRONG><a name="[ffbd90]"></a>GetCrossoverPoint</STRONG> (Thumb, 116 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ffa614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[ffa68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[ffa708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[ffa784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[ffa800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[ffa87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[ffa8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[ffa974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[ffb9b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[ffba2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[ffbaa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[ffbb24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[ffbba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[ffbc1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[ffbc98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[ffbd14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>

<P><STRONG><a name="[ffbd14]"></a>ProcCmdSZXFL</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbc98]"></a>ProcCmdSZXFC</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFC -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbc1c]"></a>ProcCmdSZXFR</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbba0]"></a>ProcCmdSZXSR</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbb24]"></a>ProcCmdSZXSL</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffbaa8]"></a>ProcCmdSZXSBR</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSBR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffba2c]"></a>ProcCmdSZXSBL</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSBL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb9b4]"></a>ProcCmdSZX</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZX -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb938]"></a>ProcCmdZ1LPS</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 392 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1LPS -> ChangeListenProfileMode -> SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[ff7a20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb8c0]"></a>ProcCmdSSPL</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb848]"></a>ProcCmdSSPC</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPC -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb7d0]"></a>ProcCmdSSPR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb754]"></a>ProcCmdSSPSR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb6d8]"></a>ProcCmdSSPSL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb65c]"></a>ProcCmdSSPSBR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSBR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb5e0]"></a>ProcCmdSSPSBL</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSBL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb564]"></a>ProcCmdSSPSW</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSW -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb4ec]"></a>ProcCmdMSZL</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb474]"></a>ProcCmdMSZR</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb3f8]"></a>ProcCmdMSZSL</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb37c]"></a>ProcCmdMSZSR</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb300]"></a>ProcCmdMSZSBL</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSBL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb284]"></a>ProcCmdMSZSBR</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSBR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb20c]"></a>ProcCmdMSZC</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZC -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb194]"></a>ProcCmdMSZS</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZS -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb11c]"></a>ProcCmdMSPL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb0a4]"></a>ProcCmdMSPC</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPC -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffb02c]"></a>ProcCmdMSPR</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffafb0]"></a>ProcCmdMSPSR</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPSR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffaf34]"></a>ProcCmdMSPSL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPSL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffaeb8]"></a>ProcCmdMSPBR</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPBR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffae3c]"></a>ProcCmdMSPBL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPBL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffadc4]"></a>ProcCmdMSPs</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPs -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffad4c]"></a>ProcCmdMSLL</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffacd4]"></a>ProcCmdMSLC</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffac5c]"></a>ProcCmdMSLR</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffabe0]"></a>ProcCmdMSLSR</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffab64]"></a>ProcCmdMSLSL</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffaae8]"></a>ProcCmdMSLBR</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLBR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffaa6c]"></a>ProcCmdMSLBL</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLBL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa9f0]"></a>ProcCmdMSLSW</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSW -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa974]"></a>ProcCmdMSZXFL</STRONG> (Thumb, 126 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa8f8]"></a>ProcCmdMSZXFC</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFC -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa87c]"></a>ProcCmdMSZXFR</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa800]"></a>ProcCmdMSZXSR</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa784]"></a>ProcCmdMSZXSBR</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSBR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa708]"></a>ProcCmdMSZXSBL</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSBL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa68c]"></a>ProcCmdMSZXSL</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa614]"></a>ProcCmdMSZX</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZX -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[ffbd90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[ffbe10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa598]"></a>ProcCmdMZ1EQL</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa51c]"></a>ProcCmdMZ1EQC</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQC -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa4a0]"></a>ProcCmdMZ1EQR</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa424]"></a>ProcCmdMZ1EQSR</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa3a8]"></a>ProcCmdMZ1EQBSR</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQBSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa32c]"></a>ProcCmdMZ1EQBSL</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQBSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa2b0]"></a>ProcCmdMZ1EQSL</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa234]"></a>ProcCmdMZ1EQSW</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSW -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ffd274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[ffd2f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[ffd374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa1b8]"></a>ProcCmdMSSPL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa13c]"></a>ProcCmdMSSPC</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPC -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa0c0]"></a>ProcCmdMSSPR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ffa044]"></a>ProcCmdMSSPSR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9fc8]"></a>ProcCmdMSSPSL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9f4c]"></a>ProcCmdMSSPSBR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSBR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9ed0]"></a>ProcCmdMSSPSBL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSBL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9e54]"></a>ProcCmdMSSPSW</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSW -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9dd8]"></a>ProcCmdZ1EMDIM</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMDIM -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9d5c]"></a>ProcCmdZ1EMP</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMP -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9ce0]"></a>ProcCmdZ1EMC</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMC -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff61f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9c64]"></a>ProcCmdZ1EMDEL</STRONG> (Thumb, 312 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMDEL -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff7930]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9be8]"></a>ProcCmdZ1VFL_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VFL_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9b6c]"></a>ProcCmdZ1VFR_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VFR_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9af0]"></a>ProcCmdZ1VC_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VC_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9a74]"></a>ProcCmdZ1VSL_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VSL_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff99f8]"></a>ProcCmdZ1VSR_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VSR_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff997c]"></a>ProcCmdZ1VBL_</STRONG> (Thumb, 246 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VBL_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9900]"></a>ProcCmdZ1VBR_</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VBR_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9884]"></a>ProcCmdZ1VS_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VS_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9800]"></a>Rs232UpdateStreamType</STRONG> (Thumb, 1962 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Rs232UpdateStreamType -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff9784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ1VFD_
</UL>

<P><STRONG><a name="[ff9784]"></a>ProCmdZ1VFD_</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProCmdZ1VFD_ -> Rs232UpdateStreamType -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff9800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9708]"></a>ProcCmdZ1IN1</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff968c]"></a>ProcCmdZ1IN2</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9610]"></a>ProcCmdZ1IN3</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9594]"></a>ProcCmdZ1IN4</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9518]"></a>ProcCmdZ1IN5</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff949c]"></a>ProcCmdZ1IN6</STRONG> (Thumb, 460 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9420]"></a>ProcCmdZ1IN7</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff93a4]"></a>ProcCmdZ1IN8</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9324]"></a>IsAnalogLevelValid</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsAnalogLevelValid</UL>
<BR>[Calls]<UL><LI><a href="#[126bcb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[126c260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff8ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[ff8f40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[ff8fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[ff9038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[ff90b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[ff9130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[ff91ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[ff9228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
</UL>

<P><STRONG><a name="[ff92a4]"></a>FindLevelPosition</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = FindLevelPosition -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[126ab44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[126b0d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[126b664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[126e810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff8ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[ff8f40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[ff8fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[ff9038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[ff90b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[ff9130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[ff91ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[ff9228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
</UL>

<P><STRONG><a name="[ff9228]"></a>ProcCmdZ1SAL1</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff91ac]"></a>ProcCmdZ1SAL2</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9130]"></a>ProcCmdZ1SAL3</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff90b4]"></a>ProcCmdZ1SAL4</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff9038]"></a>ProcCmdZ1SAL5</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8fbc]"></a>ProcCmdZ1SAL6</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8f40]"></a>ProcCmdZ1SAL7</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8ec4]"></a>ProcCmdZ1SAL8</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff92a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[ff9324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8e48]"></a>ProcCmdZ1ACN1</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8dcc]"></a>ProcCmdZ1ACN2</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8d50]"></a>ProcCmdZ1ACN3</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8cd4]"></a>ProcCmdZ1ACN4</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8c58]"></a>ProcCmdZ1ACN5</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8bdc]"></a>ProcCmdZ1ACN6</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8b60]"></a>ProcCmdZ1ACN7</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8ae4]"></a>ProcCmdZ1ACN8</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8a68]"></a>ProcCmdZ1ACN7_1</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN7_1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff89ec]"></a>ProcCmdZ1ACNR</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACNR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8974]"></a>ProcCmdTAT</STRONG> (Thumb, 144 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6ab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff88f8]"></a>ProcCmdTAHDT</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAHDT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6ab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8880]"></a>ProcCmdTFT</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6ab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8804]"></a>ProcCmdTFHDT</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFHDT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6ab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff878c]"></a>ProcCmdTAP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8710]"></a>ProcCmdTAHDP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAHDP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8698]"></a>ProcCmdTFP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff861c]"></a>ProcCmdTFHDP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFHDP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff85a4]"></a>ProcCmdT</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ProcCmdT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8524]"></a>GetTunerPosition</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
</UL>

<P><STRONG><a name="[ff84ac]"></a>ProcCmdTAS</STRONG> (Thumb, 156 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAS -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[ff6da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ff8524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8430]"></a>ProcCmdTAHDS</STRONG> (Thumb, 158 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDS -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[ff6da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ff8524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff83b8]"></a>ProcCmdTAF</STRONG> (Thumb, 250 bytes, Stack size 40 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAF -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[ff6da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ff8524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff833c]"></a>ProcCmdTAHDF</STRONG> (Thumb, 210 bytes, Stack size 40 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDF -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[ff6da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ff8524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff82c4]"></a>ProcCmdTT_</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTT_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff824c]"></a>ProcCmdASSP</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASSP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff81d0]"></a>ProcCmdASHDMIAO</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdASHDMIAO -> SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff64ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8154]"></a>ProcCmdASAVD</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdASAVD -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff7930]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[ffc618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[ffdef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff80dc]"></a>ProcCmdASFP</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASFP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff8060]"></a>ProcCmdASRSN</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = ProcCmdASRSN -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5e94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[ff66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[ffde74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolStringValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7fe4]"></a>ProcCmdASIRC</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIRC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5e18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7f68]"></a>ProcCmdASIR2C</STRONG> (Thumb, 226 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIR2C -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7eec]"></a>ProcCmdASIRM</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIRM -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7e70]"></a>ProcCmdASIR2M</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIR2M -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7df8]"></a>ProcCmdASTO</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASTO -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7d7c]"></a>ProcCmdASAIS</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASAIS -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7d04]"></a>ProcCmdASDD</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASDD -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7c8c]"></a>ProcCmdASRD</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdASRD -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff6174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[ff7c18]"></a>StrCmp</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff7b9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
</UL>

<P><STRONG><a name="[ff7b9c]"></a>ProcRs232Msg</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = ProcRs232Msg</UL>
<BR>[Calls]<UL><LI><a href="#[ff7c18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StrCmp
<LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[b40450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
</UL>

<P><STRONG><a name="[b40450]"></a>C11Rs232</STRONG> (Thumb, 188 bytes, Stack size 8 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = C11Rs232 -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bfd1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[bfd328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[c01094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[c0110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff7b9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
</UL>
<BR>[Address Reference Count : 1]<UL><LI> main.o(.data)
</UL>
<P><STRONG><a name="[ff2598]"></a>SetSpeakerMode</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = SetSpeakerMode -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[ff251c]"></a>SetDistanceMode</STRONG> (Thumb, 336 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = SetDistanceMode -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff1da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[ff24a0]"></a>SetBalanceMode</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = SetBalanceMode -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[ff241c]"></a>SetCrossoverPointsMode</STRONG> (Thumb, 364 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368 + Unknown Stack Size
<LI>Call Chain = SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[ff19c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[ff23a4]"></a>Phase_Relay</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Phase_Relay</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
</UL>

<P><STRONG><a name="[ff6384]"></a>SetSpkPhase</STRONG> (Thumb, 358 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1ca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacInvert
<LI><a href="#[ff23a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be56cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[ff2324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[ff9e54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[ff9ed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[ff9f4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[ff9fc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[ffa044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[ffa0c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[ffa13c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[ffa1b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[ffb564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[ffb5e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[ffb65c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[ffb6d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[ffb754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[ffb7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[ffb848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[ffb8c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[10ecaf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
</UL>

<P><STRONG><a name="[ff2324]"></a>SetSpeakerPhaseMode</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SetSpeakerPhaseMode -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[ff22a8]"></a>SetPanoramaMode</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, setup_func.o(.text), UNUSED)

<P><STRONG><a name="[ff2224]"></a>SetPanoramaToDefault</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, setup_func.o(.text), UNUSED)

<P><STRONG><a name="[ff7a20]"></a>ChangeListenProfileMode</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 376 + Unknown Stack Size
<LI>Call Chain = ChangeListenProfileMode -> SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[ff1d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[ff2324]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[ff241c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[ff24a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[ff251c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode
<LI><a href="#[ff2598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerMode
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
</UL>
<BR>[Called By]<UL><LI><a href="#[ffb938]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1LPS
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[be63f8]"></a>AssignedInputSetup</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AssignedInputSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be58c0]"></a>SpkDimensionSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkDimensionSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5748]"></a>SpkPanoramaSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkPanoramaSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5650]"></a>SpkWidthSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkWidthSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff61f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff21a8]"></a>SetSpkDistance</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf98b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspDelay
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5840]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[be5940]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
</UL>

<P><STRONG><a name="[be5940]"></a>SpkDelaySetup</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 212 + Unknown Stack Size
<LI>Call Chain = SpkDelaySetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff21a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be56cc]"></a>SpkPhaseSetup</STRONG> (Thumb, 156 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkPhaseSetup -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1ac4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be57c8]"></a>SpkEqSetup</STRONG> (Thumb, 206 bytes, Stack size 32 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = SpkEqSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff73e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be59bc]"></a>SpkCrossoverSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 400 + Unknown Stack Size
<LI>Call Chain = SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[bf9838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspCorner
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ffa614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[ffa68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[ffa708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[ffa784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[ffa800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[ffa87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[ffa8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[ffa974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[ffb9b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[ffba2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[ffbaa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[ffbb24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[ffbba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[ffbc1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[ffbc98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[ffbd14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be62f8]"></a>AvSyncDelaySetup</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AvSyncDelaySetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff7930]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5ab8]"></a>SpkBlanceTestMode</STRONG> (Thumb, 378 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = SpkBlanceTestMode -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf9740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff1e2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
</UL>
<BR>[Called By]<UL><LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d8a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff2124]"></a>SetBalanceTestSignal</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 188<LI>Call Chain = SetBalanceTestSignal -> SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf9740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[106d820]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[be5b38]"></a>SpkBlanceSetup</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkBlanceSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 2]<UL><LI> menu_tbl.o(.data)
<LI> setup_menu.o(.text)
</UL>
<P><STRONG><a name="[be5fa0]"></a>LateSetup</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = LateSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5e28]"></a>PasswordModeSetup</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = PasswordModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5dac]"></a>PasswordSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = PasswordSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be6280]"></a>BrightSetup</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = BrightSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be6378]"></a>AutoInputSeekSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AutoInputSeekSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5000]"></a>Zone2InputSetup</STRONG> (Thumb, 340 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = Zone2InputSetup -> Zone2RadioMode -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff1750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff5ca0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff5d1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[ff6e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff20a8]"></a>GetVolumeIndex</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, setup_func.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be4e80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
</UL>

<P><STRONG><a name="[be4e80]"></a>Zone2VolumeSetup</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = Zone2VolumeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[ff20a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVolumeIndex
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be6018]"></a>IrControlSetup</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = IrControlSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5e18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be4f80]"></a>Zone2IrControlSetup</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = Zone2IrControlSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be4f00]"></a>Zone2IrModeSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = Zone2IrModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5d30]"></a>RearIrModeSetup</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = RearIrModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be507c]"></a>TriggerSetup</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = TriggerSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5cb0]"></a>RestoreDefaultSetup</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = RestoreDefaultSetup -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5a3c]"></a>SpkConfigSetup</STRONG> (Thumb, 138 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 400 + Unknown Stack Size
<LI>Call Chain = SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[bf97bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ffb194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[ffb20c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[ffb284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[ffb300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[ffb37c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[ffb3f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[ffb474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[ffb4ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[ffbe90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[ffbf08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[ffbf80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[ffbffc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[ffc078]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[ffc0f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[ffc168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[ffc1e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5840]"></a>SpkDistanceSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 212 + Unknown Stack Size
<LI>Call Chain = SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff21a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ffadc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[ffae3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[ffaeb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[ffaf34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[ffafb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[ffb02c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[ffb0a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[ffb11c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[ffc258]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[ffc2d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[ffc348]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[ffc3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[ffc438]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[ffc4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[ffc528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[ffc5a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff2028]"></a>SetAnalogInLevel</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = SetAnalogInLevel -> Set2ChVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
</UL>

<P><STRONG><a name="[be6478]"></a>AnalogLevelSetup</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AnalogLevelSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff2028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff1fac]"></a>SetAnalogInMode</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, setup_func.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be64f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
</UL>

<P><STRONG><a name="[be64f8]"></a>AnalogInSetup</STRONG> (Thumb, 154 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AnalogInSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1fac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInMode
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be6110]"></a>HDMIInAudioSetup</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = HDMIInAudioSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff64ec]"></a>SetHdmiAudioOut</STRONG> (Thumb, 128 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1bb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[be6190]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[ff81d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[be6190]"></a>HDMIAUIDOOUT</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = HDMIAUIDOOUT -> SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff64ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff1f28]"></a>SetMasterVolumeLevel</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = SetMasterVolumeLevel -> SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[be5ea8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
</UL>

<P><STRONG><a name="[be5ea8]"></a>MasterVolumeLevel</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = MasterVolumeLevel -> SetMasterVolumeLevel -> SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[ff66e0]"></a>ReadName</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = ReadName -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[be5f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[be6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
<LI><a href="#[ff8060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
</UL>

<P><STRONG><a name="[ff5e94]"></a>WriteName</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[be5f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[be6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
<LI><a href="#[ff8060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
<LI><a href="#[ffca54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
</UL>

<P><STRONG><a name="[ff1eb0]"></a>ChanegName</STRONG> (Thumb, 94 bytes, Stack size 12 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ChanegName</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[be6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
</UL>

<P><STRONG><a name="[be6094]"></a>InputNameSetup</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = InputNameSetup -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[ff5e94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[ff66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[be5f28]"></a>LogoSetup</STRONG> (Thumb, 104 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = LogoSetup -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[ff5e94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[ff66e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[106e0f0]"></a>ReadPwd</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = ReadPwd -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[106d91c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[106e078]"></a>WritePwd</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
</UL>

<P><STRONG><a name="[106dff8]"></a>read_curr_option</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = read_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[106d528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[106dd74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
</UL>

<P><STRONG><a name="[106df78]"></a>write_curr_option</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = write_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
</UL>

<P><STRONG><a name="[106def8]"></a>execute_curr_option</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = execute_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[106d528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[106de78]"></a>load_default_option</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = load_default_option</UL>
<BR>[Calls]<UL><LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[106ddf4]"></a>Inquire_restrict_option</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Inquire_restrict_option</UL>
<BR>[Calls]<UL><LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[106dd74]"></a>MenuLoadCurOption</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = MenuLoadCurOption -> read_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[106dff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[106dcf8]"></a>MenuFindPage</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, setup_menu.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be5bb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[106da10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[106dc7c]"></a>MenuCaptionShow</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = MenuCaptionShow -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[106dc00]"></a>MenuHeaderShow</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = MenuHeaderShow -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[106da8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[106db80]"></a>VfdShowMenuOption</STRONG> (Thumb, 60 bytes, Stack size 48 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b8e44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[106db04]"></a>MenuItemShow</STRONG> (Thumb, 1136 bytes, Stack size 80 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[106db80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[106dc7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
<LI><a href="#[106ddf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[106dff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[11b0798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv (via Veneer)
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106da8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[106da8c]"></a>MenuDisplay</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[106db04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[106dc00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
</UL>
<BR>[Called By]<UL><LI><a href="#[be5bb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[106d334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[106da10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[be5bb4]"></a>SetupMenuDisplay</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = SetupMenuDisplay -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106dcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuFindPage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[106da10]"></a>SetupMenuInit</STRONG> (Thumb, 90 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b404c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106dcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuFindPage
</UL>
<BR>[Called By]<UL><LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[106d91c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[106d994]"></a>VfdInitDispPwd</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = VfdInitDispPwd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d91c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[106d91c]"></a>SetupInit</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[106d994]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[106da10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
<LI><a href="#[106e0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadPwd
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[106d8a4]"></a>SetupExit</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = SetupExit -> SpkBlanceTestMode -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[be5ab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff6758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[106d230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
</UL>
<BR>[Called By]<UL><LI><a href="#[be5c34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[106d820]"></a>SetupMenuProcBalance</STRONG> (Thumb, 216 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = SetupMenuProcBalance -> SetBalanceTestSignal -> SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff1e2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[ff2124]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceTestSignal
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
</UL>
<BR>[Called By]<UL><LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[106d7a4]"></a>ProcSetupUpKey</STRONG> (Thumb, 312 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ProcSetupUpKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff7a20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[106d138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[106d820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106dd74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
<LI><a href="#[106ddf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[106d724]"></a>ProcSetupDownKey</STRONG> (Thumb, 328 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ProcSetupDownKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff7a20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[106d138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[106d820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106dd74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
<LI><a href="#[106ddf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[106d6a4]"></a>ProcSetupLeftKey</STRONG> (Thumb, 432 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = ProcSetupLeftKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[106d138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[106df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[106dff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[106d624]"></a>ProcSetupRightKey</STRONG> (Thumb, 444 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = ProcSetupRightKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[106d138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[106df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[106dff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[106d5a4]"></a>ProcSetupEnterKey</STRONG> (Thumb, 282 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ProcSetupEnterKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b404c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[be5ab8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[ff7a20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[106d138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[106d230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[106d994]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[106df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[be5c34]"></a>SetupExitMenu</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = SetupExitMenu -> SetupExit -> SpkBlanceTestMode -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[106d8a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
<LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[106d528]"></a>SetupLoadEeprom</STRONG> (Thumb, 554 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetupLoadEeprom -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[106dff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b400ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
</UL>

<P><STRONG><a name="[ff6174]"></a>SetupLoadDefault</STRONG> (Thumb, 238 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[106de78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;load_default_option
<LI><a href="#[106def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[106df78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[106e078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b400ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[be5cb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[ff7c8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[106d4ac]"></a>PwdKeyService</STRONG> (Thumb, 448 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = PwdKeyService -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[be5c34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[106d994]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[106da10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[106e078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106d430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[106d430]"></a>SetupKeyService</STRONG> (Thumb, 356 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = SetupKeyService -> PwdKeyService -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[be5c34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[106d4ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[106d5a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d624]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[106d724]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[106d8a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Called By]<UL><LI><a href="#[106d2b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[106d3b0]"></a>SetupFlashHandler</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SetupFlashHandler -> MsgSetFlash -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[106d138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[106d334]"></a>UpdateVfdFlash</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = UpdateVfdFlash -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[106d1b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVfdbufferChar
<LI><a href="#[106da8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[106d2b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[106d2b4]"></a>SetupProcMessage</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = SetupProcMessage -> Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b405bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[106cfc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106d334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[106d430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[ff7010]"></a>IsCurFocusTid</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[1034fc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1048a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[1064690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundProcMessage
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[106d0bc]"></a>SetCurFocusTid</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff67d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[102bb68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[1047754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[1047be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[106d8a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[106d91c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[ff7278]"></a>GetCurFocusTid</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be5c34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[c21de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[c21e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[ffdc04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel
<LI><a href="#[1047be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106d91c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[10bb678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[c21e60]"></a>ProcMessage</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = ProcMessage</UL>
<BR>[Calls]<UL><LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[c21b88]"></a>VfdRefresh</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = VfdRefresh -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1061014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[1061188]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
</UL>

<P><STRONG><a name="[106d1b0]"></a>GetVfdbufferChar</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[106d334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
</UL>

<P><STRONG><a name="[1061188]"></a>SetVfdOwner</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = SetVfdOwner -> VfdRefresh -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[c21b88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
</UL>
<BR>[Called By]<UL><LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[106110c]"></a>VfdTimerHandler</STRONG> (Thumb, 94 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10fd990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[1061090]"></a>SetVfdDispMode</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5f8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
</UL>

<P><STRONG><a name="[ff17d0]"></a>VfdDisplay</STRONG> (Thumb, 114 bytes, Stack size 104 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1061014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b6eb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy (via Veneer)
<LI><a href="#[11b8e44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[be5cb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[10188b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1018aa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b508]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[102b880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
<LI><a href="#[102b97c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[102b9f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayConnectHelp
<LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[104881c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[1048990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[1048a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[1048a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[1048b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106d334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[106d994]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[106db80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[106dc00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
<LI><a href="#[106dc7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
</UL>

<P><STRONG><a name="[106d040]"></a>VfdDisplayBlank</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1061014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[11b7ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff67d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1018aa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b508]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[102bb68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[104881c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[1048990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[1048a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[1048b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106d994]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[106da8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[ff5f8c]"></a>VfdTempDisp</STRONG> (Thumb, 114 bytes, Stack size 104 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1061014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[1061090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdDispMode
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b6eb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy (via Veneer)
<LI><a href="#[11b8e44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ffce1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[1048a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[ff5f0c]"></a>VfdTempDispBlank</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = VfdTempDispBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1061014]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[11b7ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ffce1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[1048a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[ff6e9c]"></a>IsZone1VolumeValid</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ffcc38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[ffd46c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[ff6bac]"></a>MsgSetMute</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ffcbc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2M
<LI><a href="#[ffda9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1M
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048e00]"></a>MsgSetStream</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetStream -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[10bb678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[1150d38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[1150db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[1150e34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
<LI><a href="#[1150eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
</UL>

<P><STRONG><a name="[ff6c24]"></a>MsgSetInputSource</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetInputSource -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[be63f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[be64f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[ff8a68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[ff8ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[ff8b60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[ff8bdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[ff8c58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[ff8cd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[ff8d50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[ff8dcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[ff8e48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[ff93a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[ff9420]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[ff949c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[ff9518]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[ff9594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[ff9610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[ff968c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[ff9708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[102bb68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048d80]"></a>MsgSetDSPSetting</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDSPSetting -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[ff755c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[1047edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[1047fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048050]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[10480cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[1048148]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[10481c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[1048cfc]"></a>MsgSetDSPHDMISetting</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDSPHDMISetting -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1047e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[1047edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
</UL>

<P><STRONG><a name="[1048c7c]"></a>MsgSetDspChannel</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDspChannel -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[ff6b34]"></a>MsgSetPower</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetPower -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ffcda4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[ffdb14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[ff6938]"></a>MsgSetVfdShow</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[be5c34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[c21de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff861c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[ff8698]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[ff8710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[ff878c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[ffd5d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1018838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TextDisplayExit
<LI><a href="#[101b4c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveExit
<LI><a href="#[102bb68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[1034fc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1047de4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[1047e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[1047edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[1047f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[1047fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048050]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[10481c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[1048b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RefreshHandle
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[10fd990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[ff6ca4]"></a>MsgSetDimer</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDimer -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[be6280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[ff80dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[bf0b84]"></a>MsgSetKey</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[bf0bfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;key_task
<LI><a href="#[bf0cf8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HeadphoneDetect
<LI><a href="#[bf1e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;proc_key_hold
<LI><a href="#[bf1f00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;proc_key_press
</UL>

<P><STRONG><a name="[ff68bc]"></a>MsgSetVolume</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetVolume -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[ffcc38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[ffd46c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[106d138]"></a>MsgSetFlash</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetFlash -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[106d3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupFlashHandler
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[106d724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[106d7a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[ff6f1c]"></a>IsZone1PowerOn</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ffdb14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[1048c04]"></a>SetRefresh</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1048a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
</UL>

<P><STRONG><a name="[1048b88]"></a>RefreshHandle</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RefreshHandle -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
</UL>
<BR>[Called By]<UL><LI><a href="#[10fd990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[1048b10]"></a>ShowVersion</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ShowVersion -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048a8c]"></a>VfdUpdateVolumeValue</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = VfdUpdateVolumeValue -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[1048c04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRefresh
</UL>
<BR>[Called By]<UL><LI><a href="#[1048990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[1048a0c]"></a>VfdUpdateStreamType</STRONG> (Thumb, 2724 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = VfdUpdateStreamType -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1048990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[1048990]"></a>VfdUpdateZone1</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = VfdUpdateZone1 -> VfdUpdateStreamType -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1048a0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[1048a8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[ff7184]"></a>GetSrcName</STRONG> (Thumb, 76 bytes, Stack size 4 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetSrcName</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[1034fc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
</UL>

<P><STRONG><a name="[1048914]"></a>SelectSource</STRONG> (Thumb, 328 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 240 + Unknown Stack Size
<LI>Call Chain = SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1046fa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[1047570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[10477d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[1047ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[1047c60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[1047ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
</UL>

<P><STRONG><a name="[1048898]"></a>ProcInputSelect</STRONG> (Thumb, 180 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256 + Unknown Stack Size
<LI>Call Chain = ProcInputSelect -> SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff7184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048914]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[104881c]"></a>PowerOnDisplay</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[ff18c4]"></a>SetMasterVolumeValue</STRONG> (Thumb, 388 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[1048798]"></a>GetVolumeEepromSetValue</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[104871c]"></a>SystemPowerOn</STRONG> (Thumb, 142 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b40074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[c21b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[ff18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1046f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[1047028]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemReset
<LI><a href="#[10470a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[104720c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoPowerOn
<LI><a href="#[10474f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[10475e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
<LI><a href="#[1047660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitCs8416
<LI><a href="#[10476d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[104881c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[10486a0]"></a>SystemPowerOff</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = SystemPowerOff -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b40074]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[c21d6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10470a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[1047474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
</UL>

<P><STRONG><a name="[1048628]"></a>Zone1Mute</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Zone1Mute</UL>
<BR>[Calls]<UL><LI><a href="#[ff1ac4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[1047288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[1047380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
</UL>

<P><STRONG><a name="[10485ac]"></a>SetAutoseekFlag</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetAutoseekFlag -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048530]"></a>IsAutoSeekOn</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = IsAutoSeekOn -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[10484b4]"></a>IsEverAutoseek</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = IsEverAutoseek -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[104843c]"></a>SeekSelect</STRONG> (Thumb, 178 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SeekSelect -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff65e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff7184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[1047ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
</UL>

<P><STRONG><a name="[10483c0]"></a>ProcAutoSeekSur</STRONG> (Thumb, 568 bytes, Stack size 32 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = ProcAutoSeekSur -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6b34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047b6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[104843c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048340]"></a>ProcZone1PowerOn</STRONG> (Thumb, 164 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = ProcZone1PowerOn -> ProcAutoSeekSur -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff64ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1046fa0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[1047190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[10483c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[10484b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsEverAutoseek
<LI><a href="#[1048530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAutoSeekOn
<LI><a href="#[10485ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[104871c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[10482c0]"></a>ProcZone1PowerOff</STRONG> (Thumb, 110 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ProcZone1PowerOff -> SystemPowerOff -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[1048628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[10486a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[b400ec]"></a>LoadSystemStartupValue</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = LoadSystemStartupValue -> SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[106d528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1048240]"></a>Zone1ProcAutoSeek</STRONG> (Thumb, 382 bytes, Stack size 40 bytes, zone1_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6b34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047b6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[104843c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[10481c4]"></a>PcmProcCesKey</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = PcmProcCesKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[ff75e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048148]"></a>Ac3ProcCesKey</STRONG> (Thumb, 204 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = Ac3ProcCesKey -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff76d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[10480cc]"></a>DtsProcCesKey</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DtsProcCesKey -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff765c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1048050]"></a>PcmProcNeoKey</STRONG> (Thumb, 84 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = PcmProcNeoKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[ff75e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1047fd4]"></a>PcmProcPliiKey</STRONG> (Thumb, 202 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = PcmProcPliiKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[ff75e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1047f58]"></a>PcmProcSurKey</STRONG> (Thumb, 230 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = PcmProcSurKey -> DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[ff755c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[10479d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1047edc]"></a>Ac3ProcPliiKey</STRONG> (Thumb, 260 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = Ac3ProcPliiKey -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff76d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048cfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1047e60]"></a>DtsProcPliiKey</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DtsProcPliiKey -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff765c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048cfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1047de4]"></a>Ac3ProcSurKey</STRONG> (Thumb, 244 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = Ac3ProcSurKey -> DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff755c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[1047a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_MULTI
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1047d6c]"></a>IsHidenKey</STRONG> (Thumb, 148 bytes, Stack size 4 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsHidenKey</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[106cfc0]"></a>Zone1ProcMessage</STRONG> (Thumb, 1172 bytes, Stack size 32 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 792 + Unknown Stack Size
<LI>Call Chain = Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b405bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[be6280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[c21b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[ff19c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6e9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[ff6f1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1PowerOn
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[10478cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1047950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[10482c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[1048340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[1048628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[1048798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVolumeEepromSetValue
<LI><a href="#[1048898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[1048990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[1048a0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[1048a8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[104afe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106d2b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[ff6e20]"></a>IsZone2PowerOn</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, zone2_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ffcda4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[1035148]"></a>IsZone2VolumeValid</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, zone2_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[10350c8]"></a>ProcZone2PowerOn</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = ProcZone2PowerOn -> SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff1750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[ff7184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[1047190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[104871c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>
<BR>[Called By]<UL><LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[1035048]"></a>ProcZone2PowerOff</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ProcZone2PowerOff -> SystemPowerOff -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[10349e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[1034ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[1047190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[10486a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[1061188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
</UL>
<BR>[Called By]<UL><LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[1034fc4]"></a>Zone2ProcInputSelect</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = Zone2ProcInputSelect -> Zone2SelectChannel -> Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[ff7184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[1034ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[ff5ca0]"></a>Zone2RadioMode</STRONG> (Thumb, 244 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = Zone2RadioMode -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff6da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1034a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[1034ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[1034b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[1034be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1034ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[1064590]"></a>Zone2ProcMessage</STRONG> (Thumb, 580 bytes, Stack size 32 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = Zone2ProcMessage -> ProcZone2PowerOn -> SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b405bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[ff1848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[10349e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[1034fc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[1035048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[10350c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[1035148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2VolumeValid
<LI><a href="#[103612c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[102bbe4]"></a>MsgSetIrc</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetIrc -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[102b880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
<LI><a href="#[1047be4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
</UL>

<P><STRONG><a name="[1047be4]"></a>AutoSoundInit</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = AutoSoundInit -> MsgSetIrc -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[102bb68]"></a>AutoSoundExit</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = AutoSoundExit -> VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[1047c60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[102b880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
</UL>

<P><STRONG><a name="[102baf0]"></a>InitSpkPara</STRONG> (Thumb, 142 bytes, Stack size 0 bytes, auto_sound.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[102ba74]"></a>IsAnySpkValid</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, auto_sound.o(.text), UNUSED)

<P><STRONG><a name="[102b9f4]"></a>DisplayConnectHelp</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = DisplayConnectHelp -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[102b97c]"></a>DisplayNA</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
</UL>

<P><STRONG><a name="[102b900]"></a>GetIrc2EqValue</STRONG> (Thumb, 1022 bytes, Stack size 656 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 780<LI>Call Chain = GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[102b090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value
<LI><a href="#[102b288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[11b268c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[126b0d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[126b664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[1270608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
</UL>

<P><STRONG><a name="[102b880]"></a>ASProcSetupConfig</STRONG> (Thumb, 246 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = ASProcSetupConfig -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[102b800]"></a>ASProcSpeakerCheck</STRONG> (Thumb, 924 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = ASProcSpeakerCheck -> DisplayConnectHelp -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf96c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[102b114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[102b194]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSpkDistance
<LI><a href="#[102b210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[102b288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[102b380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[102b404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume
<LI><a href="#[102b9f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayConnectHelp
<LI><a href="#[102baf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitSpkPara
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[1047c60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[1047ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11aef08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul (via Veneer)
<LI><a href="#[11b268c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[126ab44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[102b780]"></a>ASProcSetDistance</STRONG> (Thumb, 532 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = ASProcSetDistance -> DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[102b97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11b0798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv (via Veneer)
<LI><a href="#[11b268c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b83b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[102b700]"></a>ASProcSetBalance</STRONG> (Thumb, 994 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 820 + Unknown Stack Size
<LI>Call Chain = ASProcSetBalance -> GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf96c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[102b090]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value
<LI><a href="#[102b114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[102b288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[102b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue
<LI><a href="#[102b900]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
<LI><a href="#[102b97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11aef08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul (via Veneer)
<LI><a href="#[11b19d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dsub (via Veneer)
<LI><a href="#[11b268c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b83b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[126ab44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[126b0d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[102b68c]"></a>sort</STRONG> (Thumb, 58 bytes, Stack size 4 bytes, auto_sound.o(.text), UNUSED)

<P><STRONG><a name="[102b604]"></a>ASProcSetCrossoverPoints</STRONG> (Thumb, 580 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = ASProcSetCrossoverPoints -> DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf96c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[102b114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[102b97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[102b588]"></a>ASProcSetRoomEQ</STRONG> (Thumb, 836 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ASProcSetRoomEQ -> DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf96c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[102b114]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[102b97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[ff72f4]"></a>FindBalancePosition</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = FindBalancePosition -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[126b0d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[126b664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[126e810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffa9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[ffaa6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[ffaae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[ffab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[ffabe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[ffac5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[ffacd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[ffad4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[ffc694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[ffc70c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[ffc784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[ffc7fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[ffc874]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[ffc8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[ffc964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[ffc9dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[ffd374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[102b508]"></a>SPK_Phase_Display</STRONG> (Thumb, 112 bytes, Stack size 48 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = SPK_Phase_Display -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[102b484]"></a>ASProcSetSpeakerphase</STRONG> (Thumb, 2606 bytes, Stack size 24 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ASProcSetSpeakerphase -> SPK_Phase_Display -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[be56cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[be57c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[be5840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[be59bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[be5a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[be5b38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff72f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[102b508]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[102b97c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[102bb68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[102bbe4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[102dba8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[11b6a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[11b83b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1270454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fsub (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[1064690]"></a>AutoSoundProcMessage</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = AutoSoundProcMessage</UL>
<BR>[Calls]<UL><LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[1018ea0]"></a>SetRadioStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1018630]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
<LI><a href="#[101b44c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveInit
<LI><a href="#[101b4c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveExit
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018e24]"></a>GetRadioStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6f98]"></a>IsFreqValid</STRONG> (Thumb, 114 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[ff8804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[ff8880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[ff88f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[ff8974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6ab8]"></a>MsgSetRadioFreq</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetRadioFreq -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ff8804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[ff8880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[ff88f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[ff8974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
</UL>

<P><STRONG><a name="[ff69b4]"></a>MsgSetRadioSearch</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ff85a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdT
<LI><a href="#[ff8804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[ff8880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[ff88f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[ff8974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6a34]"></a>MsgSetRadioLoadPreset</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = MsgSetRadioLoadPreset -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff861c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[ff8698]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[ff8710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[ff878c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[1018da8]"></a>MsgTextDisplay</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = MsgTextDisplay -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[1018d24]"></a>MsgSetRadioSavePreset</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetRadioSavePreset -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1009ed4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[10186b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[ff6664]"></a>SaveFmPreset</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ff6da4]"></a>LoadRadioPreset</STRONG> (Thumb, 242 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = LoadRadioPreset -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018ca4]"></a>IsTunerIfCorrect</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, radio_task.o(.text), UNUSED)

<P><STRONG><a name="[1018c24]"></a>ISValidTunerPostion</STRONG> (Thumb, 300 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018ba8]"></a>RadioDisplay</STRONG> (Thumb, 652 bytes, Stack size 56 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = RadioDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff6e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[11b83b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018b28]"></a>GetTextDispBuffer</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetTextDispBuffer</UL>
<BR>[Called By]<UL><LI><a href="#[1018aa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018aa8]"></a>Radio_Text_Display</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = Radio_Text_Display -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1018b28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTextDispBuffer
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018a2c]"></a>RadioChangeMode</STRONG> (Thumb, 810 bytes, Stack size 16 bytes, radio_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[1018530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[1034ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[1034b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[1034be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1034ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[10477d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[1047ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[1047ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
</UL>

<P><STRONG><a name="[ff6758]"></a>RadioInit</STRONG> (Thumb, 450 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = RadioInit -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b404c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[1018530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[1034ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[1034b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[1034be8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1034ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[10477d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[1047ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[1047ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[106d8a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>

<P><STRONG><a name="[ff67d0]"></a>RadioExit</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = RadioExit -> VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1034ce0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[106d230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
</UL>
<BR>[Called By]<UL><LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[1034f44]"></a>CalcRadioPosition</STRONG> (Thumb, 302 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[10186b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10189b0]"></a>CalcRadioFreq</STRONG> (Thumb, 166 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018930]"></a>CalcCurrenTunerFreq</STRONG> (Thumb, 28 bytes, Stack size 4 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = CalcCurrenTunerFreq</UL>
<BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10188b4]"></a>UpdateSaveVfd</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = UpdateSaveVfd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10186b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[101b44c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveInit
</UL>

<P><STRONG><a name="[1018838]"></a>TextDisplayExit</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = TextDisplayExit -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
</UL>
<BR>[Called By]<UL><LI><a href="#[1018630]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
</UL>

<P><STRONG><a name="[10187b4]"></a>C11_Tuner_SIS_Change</STRONG> (Thumb, 384 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = C11_Tuner_SIS_Change -> Tuner_Req_Radio_Monitor_Command</UL>
<BR>[Calls]<UL><LI><a href="#[bfd1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[bfd328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[1018420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1018730]"></a>C11_Tuner_PSD_Change</STRONG> (Thumb, 474 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = C11_Tuner_PSD_Change -> DeQueue -> IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[bfd1c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[bfd328]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10186b4]"></a>PreProcSaveKey</STRONG> (Thumb, 234 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = PreProcSaveKey -> UpdateSaveVfd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10188b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[1018d24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSavePreset
<LI><a href="#[101b4c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveExit
<LI><a href="#[1034f44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
</UL>
<BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[1018630]"></a>PreProcTextDisplayKey</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = PreProcTextDisplayKey -> TextDisplayExit -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[1018838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TextDisplayExit
<LI><a href="#[1018ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[10185b4]"></a>RadioKeyService</STRONG> (Thumb, 954 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = RadioKeyService -> RadioDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff67d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[1018630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
<LI><a href="#[10186b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[1018ba8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[1018da8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgTextDisplay
<LI><a href="#[1018e24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRadioStatus
<LI><a href="#[101b44c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveInit
<LI><a href="#[101b53c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcDigitKey
<LI><a href="#[1034f44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1064610]"></a>RadioProcMessage</STRONG> (Thumb, 1910 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 808 + Unknown Stack Size
<LI>Call Chain = RadioProcMessage -> Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b405bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff6664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff69b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[ff6da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff6f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10182a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[1018320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Up
<LI><a href="#[10183a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Down
<LI><a href="#[1018420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[10184ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
<LI><a href="#[10185b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[1018730]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[10187b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
<LI><a href="#[1018930]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcCurrenTunerFreq
<LI><a href="#[10189b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioFreq
<LI><a href="#[1018aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[1018b28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTextDispBuffer
<LI><a href="#[1018ba8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[1018c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ISValidTunerPostion
<LI><a href="#[1018e24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRadioStatus
<LI><a href="#[1018ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
<LI><a href="#[101b6a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_freq
<LI><a href="#[1034a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[1034b68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[1034f44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[1048a0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[1061188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[106cfc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[c21de8]"></a>RadioLoop</STRONG> (Thumb, 144 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RadioLoop -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10dc840]"></a>SetUart0Baudrate</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = SetUart0Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10dc7c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>

<P><STRONG><a name="[10dc7c8]"></a>Uart0Init</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Uart0Init -> SetUart0Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[bfd3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[10dc840]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetUart0Baudrate
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UartInit
</UL>

<P><STRONG><a name="[c01094]"></a>Uart0Send</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, uart.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[c0110c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>

<P><STRONG><a name="[10dc6d0]"></a>SetUart1Baudrate</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10dc658]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
</UL>

<P><STRONG><a name="[10dc658]"></a>Uart1Init</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Uart1Init -> SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[bfd3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[10dc6d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetUart1Baudrate
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UartInit
</UL>

<P><STRONG><a name="[10dc5e0]"></a>Uart1Send</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, uart.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10182a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[1018320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Up
<LI><a href="#[10183a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Down
<LI><a href="#[1018420]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[10184ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
<LI><a href="#[1034a60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[1034ae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[1034b68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[10c2598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Freq
<LI><a href="#[10c2614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Ext_Reset
<LI><a href="#[10c2690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Stop_Seek
<LI><a href="#[10c270c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Band_Command
</UL>

<P><STRONG><a name="[c21c00]"></a>UartInit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = UartInit -> Uart1Init -> SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[10dc658]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
<LI><a href="#[10dc7c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>
<BR>[Called By]<UL><LI><a href="#[b40638]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[10dc8c0]"></a>Uart0Isr</STRONG> (ARM, 68 bytes, Stack size 32 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Uart0Isr -> InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bfd150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uart.o(.text)
</UL>
<P><STRONG><a name="[10dc750]"></a>Uart1Isr</STRONG> (ARM, 84 bytes, Stack size 32 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Uart1Isr -> InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bfd150]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uart.o(.text)
</UL>
<P><STRONG><a name="[10d3560]"></a>Cs8416WriteByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = Cs8416WriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d3274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1047660]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitCs8416
</UL>

<P><STRONG><a name="[10d34e4]"></a>Cs8416ReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d32f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10d336c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsCs8416Unlock
<LI><a href="#[10d33e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[10d3468]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
</UL>

<P><STRONG><a name="[10d3468]"></a>Cs8416GetFreq</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = Cs8416GetFreq -> Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d34e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[10d33e8]"></a>CheckCs8416Unlock</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = CheckCs8416Unlock -> Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10d34e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[10c954c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[10d336c]"></a>IsCs8416Unlock</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, cs8416.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10d34e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>

<P><STRONG><a name="[1047660]"></a>InitCs8416</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = InitCs8416 -> Cs8416WriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d3560]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10ecc60]"></a>SelectDSD</STRONG> (Thumb, 186 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10ecbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>

<P><STRONG><a name="[10ecbe8]"></a>write_word</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10ec910]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[10ecc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
</UL>
<BR>[Called By]<UL><LI><a href="#[10ecb6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>

<P><STRONG><a name="[10ecb6c]"></a>Pcm1796Write</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[10ecbe8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1ca8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacInvert
<LI><a href="#[ff78bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[102b380]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[1047570]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[10475e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
</UL>

<P><STRONG><a name="[ff1ca8]"></a>DacInvert</STRONG> (Thumb, 182 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = DacInvert -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[10ecb6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
</UL>

<P><STRONG><a name="[102b380]"></a>Auto_Setup_DAC_Phase</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = Auto_Setup_DAC_Phase -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ecb6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[10ecaf0]"></a>InitDACPhase</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = InitDACPhase -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff6384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10475e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
</UL>

<P><STRONG><a name="[ff78bc]"></a>DacMute</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = DacMute -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[10ecb6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[be5cb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[ff7c8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[106d820]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[10475e8]"></a>InitDACReg</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = InitDACReg -> InitDACPhase -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10ecaf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
<LI><a href="#[10ecb6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10eca78]"></a>DSD_Choose</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DSD_Choose</UL>
<BR>[Calls]<UL><LI><a href="#[10eca00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Select
</UL>
<BR>[Called By]<UL><LI><a href="#[1047570]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
</UL>

<P><STRONG><a name="[1047570]"></a>InitDSDMode</STRONG> (Thumb, 158 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = InitDSDMode -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[10eca78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Choose
<LI><a href="#[10ecb6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[b402e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[10bb678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
</UL>

<P><STRONG><a name="[ff7464]"></a>EepromWriteByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, eeprom.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d3274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b400ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[be4e80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[be4f00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrModeSetup
<LI><a href="#[be4f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[be507c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TriggerSetup
<LI><a href="#[be5650]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[be56cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[be5748]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[be57c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[be5840]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[be58c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[be5940]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
<LI><a href="#[be59bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[be5a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[be5b38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[be5d30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RearIrModeSetup
<LI><a href="#[be5dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordSetup
<LI><a href="#[be5e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordModeSetup
<LI><a href="#[be5ea8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
<LI><a href="#[be5fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[be6018]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[be6110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIInAudioSetup
<LI><a href="#[be6190]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[be6280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[be62f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[be6378]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoInputSeekSetup
<LI><a href="#[be63f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[be6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
<LI><a href="#[be64f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[ff18c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[ff5e94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[ff6664]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[ff7d04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
<LI><a href="#[ff7d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAIS
<LI><a href="#[ff7df8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASTO
<LI><a href="#[ff7e70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2M
<LI><a href="#[ff7eec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRM
<LI><a href="#[ff7f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
<LI><a href="#[ff7fe4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[ff80dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
<LI><a href="#[ff8154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[ff81d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
<LI><a href="#[ff824c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASSP
<LI><a href="#[ff89ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACNR
<LI><a href="#[ff8a68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[ff8ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[ff8b60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[ff8bdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[ff8c58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[ff8cd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[ff8d50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[ff8dcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[ff8e48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[ff8ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[ff8f40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[ff8fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[ff9038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[ff90b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[ff9130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[ff91ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[ff9228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[ff93a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[ff9420]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[ff949c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[ff9518]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[ff9594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[ff9610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[ff968c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[ff9708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
<LI><a href="#[ff9c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[ff9ce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[ff9d5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[ff9dd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[ff9e54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[ff9ed0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[ff9f4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[ff9fc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[ffa044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[ffa0c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[ffa13c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[ffa1b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[ffa9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[ffaa6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[ffaae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[ffab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[ffabe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[ffac5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[ffacd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[ffad4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[ffb564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[ffb5e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[ffb65c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[ffb6d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[ffb754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[ffb7d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[ffb848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[ffb8c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[ffc694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[ffc70c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[ffc784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[ffc7fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[ffc874]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[ffc8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[ffc964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[ffc9dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[ffd374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[1034fc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[10485ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106e078]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;WritePwd
</UL>

<P><STRONG><a name="[ff74e0]"></a>EepromReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, eeprom.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d32f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b400ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[be4e80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[be4f00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrModeSetup
<LI><a href="#[be4f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[be507c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TriggerSetup
<LI><a href="#[be5650]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[be56cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[be5748]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[be57c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[be5840]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[be58c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[be5940]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
<LI><a href="#[be59bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[be5a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[be5b38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[be5d30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RearIrModeSetup
<LI><a href="#[be5dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordSetup
<LI><a href="#[be5e28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordModeSetup
<LI><a href="#[be5ea8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
<LI><a href="#[be5fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[be6018]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[be6110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIInAudioSetup
<LI><a href="#[be6190]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[be6280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[be62f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[be6378]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoInputSeekSetup
<LI><a href="#[be63f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[be6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
<LI><a href="#[be64f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[ff1750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff2324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[ff241c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[ff24a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[ff2598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerMode
<LI><a href="#[ff6384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[ff66e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff6da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[ff9884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_
<LI><a href="#[ff9900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_
<LI><a href="#[ff997c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_
<LI><a href="#[ff99f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_
<LI><a href="#[ff9a74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_
<LI><a href="#[ff9af0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_
<LI><a href="#[ff9b6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_
<LI><a href="#[ff9be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_
<LI><a href="#[ff9c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[ff9ce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[ff9d5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[ff9dd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1046fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[10484b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsEverAutoseek
<LI><a href="#[1048530]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAutoSeekOn
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106d528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[106e0f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadPwd
<LI><a href="#[10ecaf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
</UL>

<P><STRONG><a name="[10ec820]"></a>wait_timer</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, i2cdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10cc510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[10d3274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[10d32f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[10e23a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[10e2424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[10e2774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[10e27f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[10e286c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[10e28e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10e295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10ecbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[10fbbe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
<LI><a href="#[10fc110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[1114b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[111520c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>

<P><STRONG><a name="[10e2424]"></a>I2CWriteNByte</STRONG> (Thumb, 128 bytes, Stack size 40 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10e27f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[10e286c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[10e28e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[1117c14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[1117c8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
</UL>

<P><STRONG><a name="[10e23a8]"></a>I2CReadNByte</STRONG> (Thumb, 162 bytes, Stack size 48 bytes, i2cdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10e2774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[10e27f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[10e286c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[10e28e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10e295c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>

<P><STRONG><a name="[10d3274]"></a>I2C_bytewrite</STRONG> (Thumb, 148 bytes, Stack size 48 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88 + Unknown Stack Size
<LI>Call Chain = I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10e27f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[10e286c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[10e28e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1bb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[ff7464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[ff77cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[10d3560]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
</UL>

<P><STRONG><a name="[10d32f0]"></a>I2C_byteread</STRONG> (Thumb, 188 bytes, Stack size 48 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88 + Unknown Stack Size
<LI>Call Chain = I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10e2774]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[10e27f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[10e286c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[10e28e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10e295c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[ff708c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff74e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[10d34e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>

<P><STRONG><a name="[bf0a08]"></a>read165</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, ic165.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = read165</UL>
<BR>[Calls]<UL><LI><a href="#[10de38c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort1
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[bf1f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[10fbbe0]"></a>Ext4094Sendbyte</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10fb5f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094Cs
<LI><a href="#[10fc110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[10fbae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>

<P><STRONG><a name="[10fbb64]"></a>Ext4094SetBit</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Ext4094SetBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbbe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[10fb6e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[10fb764]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[10fb7e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[10fb86c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[10fb8f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[10fb96c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[10fb9e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[10fba64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[10fbae8]"></a>Ext4094ClearBit</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbbe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[10fb6e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[10fb764]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[10fb7e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[10fb86c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[10fb8f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[10fb96c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[10fb9e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[10fba64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[10fba64]"></a>Set_SLSR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_SLSR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10fb9e8]"></a>Set_HDMI_ISR</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_HDMI_ISR -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[1047754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
</UL>

<P><STRONG><a name="[10fb96c]"></a>Set_HDMI_RST</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10474f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10fb8f0]"></a>Set_UART_SEL</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_UART_SEL -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[1047754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
</UL>

<P><STRONG><a name="[10fb86c]"></a>Set_Zone2_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_Zone2_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10fb7e8]"></a>Set_FLFR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_FLFR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10fb764]"></a>Set_CENLFE_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_CENLFE_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10fb6e0]"></a>Set_SBLSBR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fbae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[10fbb64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10474f4]"></a>LPC2132HwReset</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = LPC2132HwReset -> Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10fb96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
</UL>
<BR>[Called By]<UL><LI><a href="#[1047754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10476d8]"></a>IC4094_Default</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = IC4094_Default -> Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10fb578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094OE
<LI><a href="#[10fb6e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[10fb764]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[10fb7e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[10fb86c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[10fb8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[10fb96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[10fb9e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[10fba64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[1047754]"></a>HDMI_Software_Update</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = HDMI_Software_Update -> LPC2132HwReset -> Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10474f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[106d0bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[10fb8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[10fb9e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[ff1948]"></a>SetIoport0</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[ff23a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay
<LI><a href="#[102b380]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[10ecbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[10ecc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
<LI><a href="#[10f6198]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[10f665c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[1114b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[111520c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>

<P><STRONG><a name="[10f6b10]"></a>SensePort0</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f5588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SenseDspBusy
<LI><a href="#[10f5604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>

<P><STRONG><a name="[10ec988]"></a>SetIoport1</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bf0a08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read165
<LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10ecc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
<LI><a href="#[10f6198]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[10f665c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[1114b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[111520c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>

<P><STRONG><a name="[10de38c]"></a>SensePort1</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bf0a08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read165
</UL>

<P><STRONG><a name="[10ec910]"></a>SetIoport2</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10ecbe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[10f665c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
</UL>

<P><STRONG><a name="[10f6a98]"></a>SensePort2</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[10f6a20]"></a>SetIoport3</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[10f69a8]"></a>SensePort3</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[10ec898]"></a>SetIoport4</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10ecc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
<LI><a href="#[10f665c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
</UL>

<P><STRONG><a name="[10f6930]"></a>SensePort4</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[10470a0]"></a>SystemPower</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[b40074]"></a>PowerLed</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10f6844]"></a>InitPower</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1034ce0]"></a>HDRadioPower</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff67d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1034fc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
</UL>

<P><STRONG><a name="[10f67c4]"></a>InitHDRaidoPower</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f674c]"></a>SetResetPin</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1047028]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemReset
</UL>

<P><STRONG><a name="[10f66d0]"></a>InitResetPin</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1047028]"></a>SystemReset</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SystemReset</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10f674c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetResetPin
</UL>
<BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10f665c]"></a>InitDac</STRONG> (Thumb, 122 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitDac</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[10ec910]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f656c]"></a>SetMas9116Cs0</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f6284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[10f64f0]"></a>SetMas9116Cs1</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f6284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[10f6474]"></a>SetMas9116Cs2</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f6284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[10f63f8]"></a>SetMas9116Cs3</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f6284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[10f637c]"></a>SetMas9116Cs4</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f6284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[10f6300]"></a>SetMas9116Cs5</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f6284]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>

<P><STRONG><a name="[10f6284]"></a>SelectMas9116</STRONG> (Thumb, 132 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SelectMas9116</UL>
<BR>[Calls]<UL><LI><a href="#[10f6300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[10f637c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[10f63f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[10f6474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[10f64f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[10f656c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
</UL>
<BR>[Called By]<UL><LI><a href="#[1114b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[10f6198]"></a>InitMas9116</STRONG> (Thumb, 68 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMas9116</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f611c]"></a>SetMax335Data</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10cc510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[10f5bcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
</UL>

<P><STRONG><a name="[10f60a0]"></a>SetMax335Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10cc510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[10f5bcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
</UL>

<P><STRONG><a name="[10f6024]"></a>SetMax335Cs1</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5fa8]"></a>SetMax335Cs2</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5f2c]"></a>SetMax335Cs3</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5eb0]"></a>SetMax335Cs4</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5e34]"></a>SetMax335Cs5</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5db8]"></a>SetMax335Cs6</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5d3c]"></a>SetMax335Cs7</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5cc0]"></a>SetMax335Cs8</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[10f5c44]"></a>SelectMax335</STRONG> (Thumb, 144 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SelectMax335</UL>
<BR>[Calls]<UL><LI><a href="#[10f5cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs8
<LI><a href="#[10f5d3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs7
<LI><a href="#[10f5db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs6
<LI><a href="#[10f5e34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs5
<LI><a href="#[10f5eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs4
<LI><a href="#[10f5f2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs3
<LI><a href="#[10f5fa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs2
<LI><a href="#[10f6024]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs1
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6004]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
</UL>

<P><STRONG><a name="[10f5bcc]"></a>InitMAS335</STRONG> (Thumb, 72 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMAS335</UL>
<BR>[Calls]<UL><LI><a href="#[10f60a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[10f611c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[ff1ac4]"></a>Set7CH1Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be56cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[1047474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[1048628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[10f5ad4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[10f5b50]"></a>SetZone2Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10349e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[10f5ad4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[1047380]"></a>SetBalance_Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1047474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[1048628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[10f5ad4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[1047288]"></a>SetHeadphoneMute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1047474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[1048628]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[10f5ad4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
</UL>

<P><STRONG><a name="[10349e8]"></a>Zone2Mute</STRONG> (Thumb, 26 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone2Mute</UL>
<BR>[Calls]<UL><LI><a href="#[10f5b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[10f5ad4]"></a>InitMuteControl</STRONG> (Thumb, 72 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMuteControl</UL>
<BR>[Calls]<UL><LI><a href="#[ff1ac4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[1047288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[1047380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
<LI><a href="#[10f5b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1047474]"></a>PowerOffMuteControl</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = PowerOffMuteControl</UL>
<BR>[Calls]<UL><LI><a href="#[ff1ac4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[1047288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[1047380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>

<P><STRONG><a name="[10f5a60]"></a>Init165</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[bf0a7c]"></a>SenseEncoderSwitchPlus</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bf0c74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
</UL>

<P><STRONG><a name="[bf0b00]"></a>SenseEncoderSwitchMinus</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bf0c74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
</UL>

<P><STRONG><a name="[10f59e0]"></a>InitEncoderSwitch</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1047ae8]"></a>DSP_Input_Stream_Select</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[10f595c]"></a>Init_Dsp_Input_Select</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10eca00]"></a>DSD_Select</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10eca78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Choose
</UL>

<P><STRONG><a name="[10f58e0]"></a>Init_DSD_Select</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f5860]"></a>SenseAnalogSignal</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[10c85c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
</UL>

<P><STRONG><a name="[10fb5f0]"></a>Set4094Cs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10fbbe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>

<P><STRONG><a name="[10fb578]"></a>Set4094OE</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10476d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[10fb500]"></a>SetData4094</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10fc110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>

<P><STRONG><a name="[10fb668]"></a>Set4094Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10fc110]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>

<P><STRONG><a name="[10f57e8]"></a>Init4094</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f5770]"></a>SetDspReset</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f567c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
</UL>

<P><STRONG><a name="[10f56f4]"></a>InitDspResetPin</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f567c]"></a>DSPHwReset</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DSPHwReset</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10f5770]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspReset
</UL>
<BR>[Called By]<UL><LI><a href="#[bf94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
<LI><a href="#[114275c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>

<P><STRONG><a name="[10f5604]"></a>SenseDspIrq</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10f6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[10b1c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b508c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10b5938]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[111f49c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[114275c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>

<P><STRONG><a name="[10f5588]"></a>SenseDspBusy</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SenseDspBusy</UL>
<BR>[Calls]<UL><LI><a href="#[10f6b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[10b5108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10f5510]"></a>Set_Spi_Cs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10b508c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10b5108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[10f5320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
</UL>

<P><STRONG><a name="[10f5498]"></a>Set_Spi_Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10b508c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10b5108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[10b5938]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[10b59b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[10f5320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
</UL>

<P><STRONG><a name="[10f541c]"></a>Set_Spi_MOSI</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10b59b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[10f5320]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
</UL>

<P><STRONG><a name="[10f53a0]"></a>Sense_Spi_MISO</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10b5938]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
</UL>

<P><STRONG><a name="[10f5320]"></a>Init_Dsp_Spi_Pin</STRONG> (Thumb, 64 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Init_Dsp_Spi_Pin</UL>
<BR>[Calls]<UL><LI><a href="#[10f541c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_MOSI
<LI><a href="#[10f5498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[10f5510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10d309c]"></a>set_sda</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[10d3110]"></a>set_scl</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[10d3184]"></a>sense_sda</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[10d31fc]"></a>sense_scl</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[10f52a8]"></a>set_vfd_sda</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[10f5230]"></a>set_vfd_scl</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[10f51b4]"></a>sense_vfd_sda</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[10f5138]"></a>sense_vfd_scl</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[10e5a60]"></a>set_sda1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[10e5ad8]"></a>set_scl1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[10e5b50]"></a>sense_sda1</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[10e5bc8]"></a>sense_scl1</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[10f50c0]"></a>set_sda2</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[10f5048]"></a>set_scl2</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[10f4fd0]"></a>sense_sda2</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[10f4f58]"></a>sense_scl2</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[10f4edc]"></a>set_sda_hdmi</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[10f4e60]"></a>set_scl_hdmi</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f4cf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[10f4de4]"></a>sense_sda_hdmi</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[10f4d68]"></a>sense_scl_hdmi</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[10f4cf0]"></a>I2cPinInit</STRONG> (Thumb, 164 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = I2cPinInit</UL>
<BR>[Calls]<UL><LI><a href="#[10d309c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda
<LI><a href="#[10d3110]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl
<LI><a href="#[10e5a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda1
<LI><a href="#[10e5ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl1
<LI><a href="#[10f4e60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl_hdmi
<LI><a href="#[10f4edc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda_hdmi
<LI><a href="#[10f5048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl2
<LI><a href="#[10f50c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda2
<LI><a href="#[10f5230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_vfd_scl
<LI><a href="#[10f52a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_vfd_sda
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[10f4c78]"></a>EnableEint0</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[10f4bfc]"></a>DisableEint0</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[10f4b84]"></a>EnableEint1</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5e18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[10f4b08]"></a>DisableEint1</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5e18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[10f4a90]"></a>EnableEint2</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5c24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
</UL>

<P><STRONG><a name="[10f4a14]"></a>DisableEint2</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5c24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
</UL>

<P><STRONG><a name="[10f499c]"></a>EnableEint3</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5e18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[10f4920]"></a>DisableEint3</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff5e18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[ff5e18]"></a>Zone1SelectIr</STRONG> (Thumb, 140 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone1SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[10f4920]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint3
<LI><a href="#[10f499c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint3
<LI><a href="#[10f4b08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint1
<LI><a href="#[10f4b84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint1
</UL>
<BR>[Called By]<UL><LI><a href="#[be6018]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[ff7fe4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[10f48a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;remote_config
</UL>

<P><STRONG><a name="[10f48a4]"></a>remote_config</STRONG> (Thumb, 60 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = remote_config -> Zone1SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[ff5e18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[ff5c24]"></a>Zone2SelectIr</STRONG> (Thumb, 84 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone2SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[10f4a14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint2
<LI><a href="#[10f4a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint2
</UL>
<BR>[Called By]<UL><LI><a href="#[be4f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[ff7f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
</UL>

<P><STRONG><a name="[c21d6c]"></a>SetIoStandby</STRONG> (Thumb, 180 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SetIoStandby</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[10ec910]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[10f5cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs8
<LI><a href="#[10f5d3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs7
<LI><a href="#[10f5db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs6
<LI><a href="#[10f5e34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs5
<LI><a href="#[10f5eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs4
<LI><a href="#[10f5f2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs3
<LI><a href="#[10f5fa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs2
<LI><a href="#[10f6024]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs1
<LI><a href="#[10f60a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[10f611c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
<LI><a href="#[10f6300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[10f637c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[10f63f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[10f6474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[10f64f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[10f656c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>

<P><STRONG><a name="[104720c]"></a>SetIoPowerOn</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[b4026c]"></a>HardwareInit</STRONG> (Thumb, 90 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = HardwareInit -> SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10470a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[1047190]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[1047ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[10f48a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;remote_config
<LI><a href="#[10f4cf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
<LI><a href="#[10f5320]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
<LI><a href="#[10f56f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDspResetPin
<LI><a href="#[10f57e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init4094
<LI><a href="#[10f58e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_DSD_Select
<LI><a href="#[10f595c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Input_Select
<LI><a href="#[10f59e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitEncoderSwitch
<LI><a href="#[10f5a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init165
<LI><a href="#[10f5ad4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[10f5bcc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
<LI><a href="#[10f6198]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[10f665c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[10f66d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitResetPin
<LI><a href="#[10f67c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitHDRaidoPower
<LI><a href="#[10f6844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitPower
</UL>
<BR>[Called By]<UL><LI><a href="#[b40638]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[10f6b88]"></a>exint3</STRONG> (ARM, 200 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint3 -> ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[10f47a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[10f68bc]"></a>exint2</STRONG> (ARM, 236 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint2 -> ir2_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[10f4824]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[10f65e8]"></a>exint1</STRONG> (ARM, 236 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint1 -> ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[10f47a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[10f6210]"></a>exint0</STRONG> (ARM, 200 bytes, Stack size 40 bytes, ioport.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10f47a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>

<P><STRONG><a name="[1107bf4]"></a>repeat_IRkey_allowed</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, ir.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b404c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[10f47a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips
</UL>

<P><STRONG><a name="[b40170]"></a>InitRemoteRepeatKey</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = InitRemoteRepeatKey</UL>
<BR>[Calls]<UL><LI><a href="#[11b7ed8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b40638]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[b404c8]"></a>AddRemoteRepeatKey</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = AddRemoteRepeatKey</UL>
<BR>[Calls]<UL><LI><a href="#[1107bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;repeat_IRkey_allowed
</UL>
<BR>[Called By]<UL><LI><a href="#[b40638]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106da10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[106d230]"></a>DeleteRemoteRepeatKey</STRONG> (Thumb, 102 bytes, Stack size 4 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = DeleteRemoteRepeatKey</UL>
<BR>[Called By]<UL><LI><a href="#[ff67d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[106d5a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[106d8a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>

<P><STRONG><a name="[1107b6c]"></a>zone2_repeat_IRkey_allowed</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ir.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10f47a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips
<LI><a href="#[10f4824]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips
</UL>

<P><STRONG><a name="[10f47a8]"></a>ir_core_philips</STRONG> (Thumb, 714 bytes, Stack size 48 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[1107b6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;zone2_repeat_IRkey_allowed
<LI><a href="#[1107bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;repeat_IRkey_allowed
<LI><a href="#[11af820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d (via Veneer)
<LI><a href="#[126bcb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[126c260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10f6210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint0 (via Veneer)
<LI><a href="#[10f65e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint1 (via Veneer)
<LI><a href="#[10f6b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint3 (via Veneer)
</UL>

<P><STRONG><a name="[10f4824]"></a>ir2_core_philips</STRONG> (Thumb, 622 bytes, Stack size 48 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ir2_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[1107b6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;zone2_repeat_IRkey_allowed
<LI><a href="#[11af820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d (via Veneer)
<LI><a href="#[126bcb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[126c260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10f68bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint2 (via Veneer)
</UL>

<P><STRONG><a name="[ff7848]"></a>DelayMs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[be5cb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff755c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[ff7c8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1018aa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[1034be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1047028]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemReset
<LI><a href="#[1047308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[10474f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1047fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[10486a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[1048b10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[106d820]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[10a4440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
<LI><a href="#[10b1c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[10c85c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
<LI><a href="#[10d33e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[10f567c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[111f49c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[11424dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
<LI><a href="#[114275c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[c21c78]"></a>Timer0_Handler</STRONG> (Thumb, 170 bytes, Stack size 8 bytes, timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = Timer0_Handler -> RadioDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[bf0bfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;key_task
<LI><a href="#[bf0c74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
<LI><a href="#[bfd3a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1018420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[1018730]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[1018aa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[1018ba8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[106d3b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupFlashHandler
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[c21cf4]"></a>Timer0Init</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40638]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[10fd990]"></a>timer0_irq</STRONG> (ARM, 552 bytes, Stack size 24 bytes, timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = timer0_irq -> RefreshHandle -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow (via Veneer)
<LI><a href="#[1048b88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RefreshHandle (via Veneer)
<LI><a href="#[106110c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTimerHandler (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> timer.o(.text)
</UL>
<P><STRONG><a name="[1117c8c]"></a>VfdSendNByte</STRONG> (Thumb, 46 bytes, Stack size 88 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10e2424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1061014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>

<P><STRONG><a name="[1117c14]"></a>VfdSendByte</STRONG> (Thumb, 42 bytes, Stack size 80 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10e2424]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[c21b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[1061014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>

<P><STRONG><a name="[1061014]"></a>VfdUpdateBuffer</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1117c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[1117c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[c21b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
<LI><a href="#[ff17d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5f0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[106d040]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
</UL>

<P><STRONG><a name="[c21b08]"></a>VfdSetDimerValue</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = VfdSetDimerValue -> VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1117c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[b405bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[1114b94]"></a>CalcMas9116Volume</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1270608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1114b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[1114b18]"></a>Mas9116SetGain</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[10f6284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[1114b94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume
<LI><a href="#[111520c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[ff6568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[ff65e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[102b404]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume
</UL>

<P><STRONG><a name="[1114a9c]"></a>Mas9116Reset</STRONG> (Thumb, 138 bytes, Stack size 8 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Mas9116Reset -> Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[10f6300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[10f637c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[10f63f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[10f6474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[10f64f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[10f656c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
<LI><a href="#[111520c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
</UL>
<BR>[Called By]<UL><LI><a href="#[1046f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
</UL>

<P><STRONG><a name="[ff1848]"></a>SetZone2Volume</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SetZone2Volume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[1114b18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>
<BR>[Called By]<UL><LI><a href="#[be4e80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[ff65e8]"></a>Set2ChVolume</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = Set2ChVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[1114b18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2028]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel
<LI><a href="#[ff8ec4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[ff8f40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[ff8fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[ff9038]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[ff90b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[ff9130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[ff91ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[ff9228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[ff6568]"></a>SetBalanceVolume</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[1114b18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[1270608]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5b38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[ff1a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[ff24a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[ffa9f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[ffaa6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[ffaae8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[ffab64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[ffabe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[ffac5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[ffacd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[ffad4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[ffc694]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[ffc70c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[ffc784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[ffc7fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[ffc874]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[ffc8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[ffc964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[ffc9dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
</UL>

<P><STRONG><a name="[ff1a44]"></a>Set7Ch1MainVolume</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = Set7Ch1MainVolume -> SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[ff6568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[ff1f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[102bb68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[1047118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[106d8a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>

<P><STRONG><a name="[102b404]"></a>AutoSoundSetVolume</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = AutoSoundSetVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[1114b18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[1047118]"></a>SoftMute</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = SoftMute -> Set7Ch1MainVolume -> SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[ff1a44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1047e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[1047edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[1047fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048050]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[10bb678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[1046f28]"></a>VolumeInit</STRONG> (Thumb, 12 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = VolumeInit -> Mas9116Reset -> Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[1114a9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
</UL>
<BR>[Called By]<UL><LI><a href="#[104871c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10cc510]"></a>Max335SendByte</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10f60a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[10f611c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6004]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
</UL>

<P><STRONG><a name="[ff63fc]"></a>SetMax335Switch</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SetMax335Switch</UL>
<BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ff1750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff5d1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[1018530]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1047c60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[1047ce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[10c8550]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
</UL>

<P><STRONG><a name="[ff6004]"></a>UpdateMax335</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[10cc510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[10f5c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>
<BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ff1750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff5d1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[1018530]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1047c60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[1047ce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[10c8550]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
</UL>

<P><STRONG><a name="[ff77cc]"></a>DigiSendByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d3274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1047190]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
<LI><a href="#[10c8644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2DigiSelectChannel
<LI><a href="#[10c86c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelectChannel
</UL>

<P><STRONG><a name="[1047190]"></a>SetTrigerOut</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b4026c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[1035048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[10482c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[10c86c8]"></a>DigitalInSelectChannel</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10c954c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[10c8644]"></a>Zone2DigiSelectChannel</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
</UL>

<P><STRONG><a name="[10c85c8]"></a>CheckAnalogIn</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CheckAnalogIn</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10f5860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseAnalogSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[10c954c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[10c8550]"></a>AnalogInOff</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInOff -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[1046fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[1047b6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[10c84c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSelectInputChannel
</UL>

<P><STRONG><a name="[ff5d1c]"></a>Zone2AnalogInOff</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Zone2AnalogInOff -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ff1750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[1018530]"></a>AnalogInSelectChannel</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInSelectChannel -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[10c954c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[ff1750]"></a>Zone2SelectChannel</STRONG> (Thumb, 232 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = Zone2SelectChannel -> Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff5d1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[10c8644]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2DigiSelectChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[1034fc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[10350c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
</UL>

<P><STRONG><a name="[1047c60]"></a>AnalogInputTypeSelect</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInputTypeSelect -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[102bb68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[10c954c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[1047ce4]"></a>Analog7CH1OutSelectChannel</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Analog7CH1OutSelectChannel -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[10c954c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[10c84c8]"></a>SystemSelectInputChannel</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, channel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10c8550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[10c954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[1046fa0]"></a>SystemSearchInputChannel</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff74e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[10c8550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[10c954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[1048340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[1047b6c]"></a>CheckInput</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = CheckInput -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10c8550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[10c954c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[10483c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
</UL>

<P><STRONG><a name="[1018420]"></a>Tuner_Req_Radio_Monitor_Command</STRONG> (Thumb, 140 bytes, Stack size 40 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Tuner_Req_Radio_Monitor_Command</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[c21c78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[10187b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10c270c]"></a>Tuner_Band_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Band_Command</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[1034be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[1018320]"></a>Tuner_Req_Tune_Up</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Req_Tune_Up</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10183a0]"></a>Tuner_Req_Tune_Down</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Req_Tune_Down</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10c2690]"></a>Tuner_Stop_Seek</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Tuner_Stop_Seek</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[1034be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[10182a0]"></a>Tuner_Seek_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Seek_Command</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[1034be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10184ac]"></a>Tuner_HDSEEK_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_HDSEEK_Command</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[1034be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1034b68]"></a>Tuner_Mute_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Mute_Command</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1034ae8]"></a>Tuner_Volume_Init</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Tuner_Volume_Init</UL>
<BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[10c2614]"></a>Tuner_Ext_Reset</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, tuner.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>

<P><STRONG><a name="[10c2598]"></a>Tuner_Req_Freq</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tuner.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>

<P><STRONG><a name="[10c251c]"></a>FreqCheckSum</STRONG> (Thumb, 28 bytes, Stack size 4 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = FreqCheckSum</UL>
<BR>[Called By]<UL><LI><a href="#[1034a60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
</UL>

<P><STRONG><a name="[1034a60]"></a>Tuner_Write_Freq_Command</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36 + Unknown Stack Size
<LI>Call Chain = Tuner_Write_Freq_Command -> FreqCheckSum</UL>
<BR>[Calls]<UL><LI><a href="#[10c251c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FreqCheckSum
<LI><a href="#[10dc5e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
<LI><a href="#[11b61c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[1034be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1034be8]"></a>InitTuner</STRONG> (Thumb, 226 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 44 + Unknown Stack Size
<LI>Call Chain = InitTuner -> Tuner_Write_Freq_Command -> FreqCheckSum</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10182a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[10184ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
<LI><a href="#[1034a60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[10c2690]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Stop_Seek
<LI><a href="#[10c270c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Band_Command
</UL>
<BR>[Called By]<UL><LI><a href="#[ff5ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[ff1bb4]"></a>HdmiSendByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d3274]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff64ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[10477d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[ff708c]"></a>HdmiReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = HdmiReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10d32f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b402e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[10bb678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[10bb6f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[10477d8]"></a>HDMI_Port_Select</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = HDMI_Port_Select -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff1bb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[1018a2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[10bb6f0]"></a>HDMI_Loop</STRONG> (Thumb, 278 bytes, Stack size 16 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = HDMI_Loop -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1047ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[10d33e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[10d3468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[b402e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[10bb678]"></a>DSD_Loop</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = DSD_Loop -> HdmiReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff7278]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1047570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
</UL>
<BR>[Called By]<UL><LI><a href="#[b402e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[10bb600]"></a>HDMI_Busy</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = HDMI_Busy -> DSP_API_Read -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10bb584]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
</UL>
<BR>[Called By]<UL><LI><a href="#[b402e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[b402e8]"></a>HDMI_DSD_Loop</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = HDMI_DSD_Loop -> HDMI_Loop -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[1047570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[10bb600]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Busy
<LI><a href="#[10bb678]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[10bb6f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[10b5188]"></a>Delay_SPI</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dsp_spi.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10b508c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>

<P><STRONG><a name="[10b5108]"></a>DspSpiWriteNByte</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 108<LI>Call Chain = DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10b59b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[10f5498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[10f5510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
<LI><a href="#[10f5588]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspBusy
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[102b210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[102b288]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[10479d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO
<LI><a href="#[1047a60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_MULTI
<LI><a href="#[109f904]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[109fa0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE
<LI><a href="#[109fa90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Channel
<LI><a href="#[109fb0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Test_Duration
<LI><a href="#[109fb90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[109fc10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fc90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fd08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[109fd84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[109fe00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10a43c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDelay
<LI><a href="#[10a44c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DLYAUXCNTL
<LI><a href="#[10a4540]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EXT_BUFF_SIZE
<LI><a href="#[10a45c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EXT_BUFF_ADDR
<LI><a href="#[10a4640]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Max_Setting
<LI><a href="#[10a46c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Unit
<LI><a href="#[10a4740]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_MAIN_PPM_CONTROL
<LI><a href="#[10acbd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10acc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10accf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[10acd78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[10ace00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[10ace8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[10acf14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[10acf9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[10ad024]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[10ad0ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[10ad134]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[10ad1c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[10ad24c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[10ad2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
<LI><a href="#[10ad358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER
<LI><a href="#[10ad3d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_HPF_CONTROL
<LI><a href="#[10ad460]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_5XOVER_CONTROL
<LI><a href="#[10ad4e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
<LI><a href="#[10bb584]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
<LI><a href="#[10c8448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[111f49c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[111f594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[111f610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_POSTGAIN
<LI><a href="#[111f68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CH_PREATTENUATION
<LI><a href="#[111f714]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Flash
<LI><a href="#[111f790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Bands
<LI><a href="#[111f80c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Channels
<LI><a href="#[111f888]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Config
<LI><a href="#[111f904]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
<LI><a href="#[1132020]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[11320ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
<LI><a href="#[11321b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Speaker_Select
<LI><a href="#[1132234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Control
<LI><a href="#[1132334]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[11323b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[11423d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDTSHDChannel
<LI><a href="#[1155cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolbyPLIIX
<LI><a href="#[1155d40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DIMENSION_CONFIGURATION
<LI><a href="#[1155dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1155e64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CNOTROL_REGISTER
<LI><a href="#[1155eec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_Control
<LI><a href="#[1159170]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION
<LI><a href="#[1159200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1159290]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CONTROL_REGISTER
<LI><a href="#[1159318]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[115939c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
<LI><a href="#[115c5c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadRegist
<LI><a href="#[115c644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadCrossbar
<LI><a href="#[115c6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolby
<LI><a href="#[115c7bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[115c838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[115c8b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
<LI><a href="#[115c93c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_STEREO_MODE_CONTROL
<LI><a href="#[115c9c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_Control
<LI><a href="#[1164f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadSgen
<LI><a href="#[1164fd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CHANNEL_SIGNAL_SELECT
<LI><a href="#[1169dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadOS
<LI><a href="#[1169e24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB_Debug
<LI><a href="#[1169eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_Debug
<LI><a href="#[116c524]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Max_EQ_Fc
<LI><a href="#[1171dbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC_1_Test_Signal
<LI><a href="#[1171e40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Tx_Channel
<LI><a href="#[1171ec0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Gain
<LI><a href="#[1171f38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC_1_Control
<LI><a href="#[1193aec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[1193b6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode_Pl2x
<LI><a href="#[1193bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[1193c70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_OUTPUT_FS
<LI><a href="#[1196f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[1196f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Decode_Mode_Control
<LI><a href="#[119700c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Control
</UL>

<P><STRONG><a name="[10b508c]"></a>DspSpiReadNByte</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Delay_SPI
<LI><a href="#[10b5938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[10b59b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
<LI><a href="#[10f5498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[10f5510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
<LI><a href="#[10f5604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[10b1c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[111f49c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[11427d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>

<P><STRONG><a name="[10ad568]"></a>ConvertDbValue</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[11b268c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[1268e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pow (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1271020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acbd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10acc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10accf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[10acd78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[10ace00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[10ace8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[10acf14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[10acf9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[10ad024]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[10ad0ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[10ad134]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[10ad1c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[10ad24c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[10ad2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
</UL>

<P><STRONG><a name="[10ad4e8]"></a>DSP_BASS_CONTROL</STRONG> (Thumb, 174 bytes, Stack size 40 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DSP_BASS_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10aca68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BassOn
<LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad460]"></a>DSP_BASS_MGR_5XOVER_CONTROL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_BASS_MGR_5XOVER_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad3d8]"></a>DSP_BASS_MGR_HPF_CONTROL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_BASS_MGR_HPF_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad358]"></a>DSP_SET_BASS_CORNER</STRONG> (Thumb, 304 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_SET_BASS_CORNER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff19c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>

<P><STRONG><a name="[10ad2d4]"></a>DSP_BASS_INPUT_LEVEL</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_INPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad24c]"></a>DSP_BASS_LFE_OUTPUT_LEVEL</STRONG> (Thumb, 206 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_LFE_OUTPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad1c0]"></a>DSP_BASS_FRONT_SUM_OUTPUT_LEVEL</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_FRONT_SUM_OUTPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad134]"></a>DSP_BASS_BACK_SUM_OUTPUT_LEVEL</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_BACK_SUM_OUTPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad0ac]"></a>DSP_BASS_SUM1_INPUT_LEVEL</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM1_INPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ad024]"></a>DSP_BASS_SUM2_INPUT_LEVEL</STRONG> (Thumb, 160 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM2_INPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acf9c]"></a>DSP_BASS_SUM3_INPUT_LEVLE</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM3_INPUT_LEVLE -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acf14]"></a>DSP_BASS_SUM4_INPUT_LEVLE</STRONG> (Thumb, 174 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM4_INPUT_LEVLE -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ace8c]"></a>DSP_BASS_SUM5_INPUT_LEVLE</STRONG> (Thumb, 190 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM5_INPUT_LEVLE -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10ace00]"></a>DSP_BASS_X_INPUT_LEVEL_FRONT</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_X_INPUT_LEVEL_FRONT -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acd78]"></a>DSP_BASS_X_INPUT_LEVEL_BACK</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10accf0]"></a>DSP_BASS_INPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = DSP_BASS_INPUT_SUB_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acc60]"></a>DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acbd0]"></a>DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10ad568]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acb54]"></a>ConfigSpkMode</STRONG> (Thumb, 512 bytes, Stack size 48 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10acadc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10acadc]"></a>C11SetBass</STRONG> (Thumb, 584 bytes, Stack size 24 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10acb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode
<LI><a href="#[10acbd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10acc60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10accf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[10acd78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[10ace00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[10ace8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[10acf14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[10acf9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[10ad024]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[10ad0ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[10ad134]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[10ad1c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[10ad24c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[10ad2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
<LI><a href="#[10ad3d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_HPF_CONTROL
<LI><a href="#[10ad460]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_5XOVER_CONTROL
<LI><a href="#[10ad4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[ff19c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>

<P><STRONG><a name="[10aca68]"></a>BassOn</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, bassmanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10ad4e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
</UL>

<P><STRONG><a name="[ff19c0]"></a>SetBassManagerSpeaker</STRONG> (Thumb, 206 bytes, Stack size 8 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10acadc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
<LI><a href="#[10ad358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER
</UL>
<BR>[Called By]<UL><LI><a href="#[bf93e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSpkMode
<LI><a href="#[bf964c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner
<LI><a href="#[ff241c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[10a4740]"></a>DSP_MAIN_PPM_CONTROL</STRONG> (Thumb, 152 bytes, Stack size 32 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_MAIN_PPM_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10a4440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>

<P><STRONG><a name="[10a46c4]"></a>DSP_Delay_Unit</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[ff1da4]"></a>DSP_Delay_Channel_Setting</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bf95d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay
<LI><a href="#[ff251c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode
<LI><a href="#[ff7930]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[10a4440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>

<P><STRONG><a name="[10a4640]"></a>DSP_Delay_Max_Setting</STRONG> (Thumb, 182 bytes, Stack size 24 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10a45c0]"></a>DSP_EXT_BUFF_ADDR</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10a4540]"></a>DSP_EXT_BUFF_SIZE</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10a44c4]"></a>DSP_DLYAUXCNTL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10a4440]"></a>DSP_Delay_Firmware_Init</STRONG> (Thumb, 104 bytes, Stack size 8 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DSP_Delay_Firmware_Init -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff1da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10a4740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_MAIN_PPM_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[ff7930]"></a>DSP_AV_Delay</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DSP_AV_Delay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff1da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
</UL>
<BR>[Called By]<UL><LI><a href="#[be62f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[ff8154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[ff9c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
</UL>

<P><STRONG><a name="[10a43c4]"></a>DspReadDelay</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[115c9c4]"></a>DSP_AC3_Control</STRONG> (Thumb, 140 bytes, Stack size 24 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[115c93c]"></a>DSP_AC3_STEREO_MODE_CONTROL</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[115c8b4]"></a>DSP_AC3_COMPRESSION_CONTROL</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = DSP_AC3_COMPRESSION_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[115c73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[115c838]"></a>DSP_AC3_CUT_X</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_AC3_CUT_X -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[115c73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[115c7bc]"></a>DSP_AC3_BOOST_Y</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_AC3_BOOST_Y -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[115c73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[115c73c]"></a>DSP_AC3_DRC_INIT</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = DSP_AC3_DRC_INIT -> DSP_AC3_BOOST_Y -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[115c7bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[115c838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[115c8b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[115c6c0]"></a>DspReadDolby</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[115c644]"></a>DspReadCrossbar</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[115c5c8]"></a>DspReadRegist</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[115939c]"></a>DSP_PLII_Control</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[11590ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Firmware_Cfg
</UL>

<P><STRONG><a name="[1159318]"></a>DSP_PLII_DECODE_MODE</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_DECODE_MODE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff61f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[ff6274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[ff6300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[11590ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Firmware_Cfg
</UL>

<P><STRONG><a name="[1159290]"></a>DSP_PLII_CONTROL_REGISTER</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_CONTROL_REGISTER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
</UL>

<P><STRONG><a name="[1159200]"></a>DSP_PLII_CENTER_WIDTH_CONFIGURATION</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_CENTER_WIDTH_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff61f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
</UL>

<P><STRONG><a name="[1159170]"></a>DSP_PLII_DIMENSION_CONFIGURATION</STRONG> (Thumb, 170 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_DIMENSION_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
</UL>

<P><STRONG><a name="[11590ec]"></a>DSP_PLII_Firmware_Cfg</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, dolbyprologicii.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1159318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[115939c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
</UL>

<P><STRONG><a name="[1155eec]"></a>DSP_PLIIx_Control</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10479d4]"></a>DSP_PLIIx_DECODE_MODE_STEREO</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLIIx_DECODE_MODE_STEREO -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1047f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
</UL>

<P><STRONG><a name="[1155e64]"></a>DSP_PLIIx_CNOTROL_REGISTER</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1155dd0]"></a>DSP_PLIIx_CENTER_WIDTH_CONFIGURATION</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1155d40]"></a>DSP_PLIIx_DIMENSION_CONFIGURATION</STRONG> (Thumb, 170 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1047a60]"></a>DSP_PLIIx_DECODE_MODE_MULTI</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLIIx_DECODE_MODE_MULTI -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1047de4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
</UL>

<P><STRONG><a name="[1155cc0]"></a>DspReadDolbyPLIIX</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1150fa8]"></a>ClearDspBuffer</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dsp_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[1150f2c]"></a>AnalyseDspMsg</STRONG> (Thumb, 222 bytes, Stack size 24 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 232 + Unknown Stack Size
<LI>Call Chain = AnalyseDspMsg -> DspProcUnsolicitedMsg -> ProcAutodetecResponse -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1150c34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
<LI><a href="#[1150d38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[1150db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[1150e34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
<LI><a href="#[1150eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
<LI><a href="#[11b7a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b403dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[b403dc]"></a>DspLoop</STRONG> (Thumb, 222 bytes, Stack size 16 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 272 + Unknown Stack Size
<LI>Call Chain = DspLoop -> ProcInputSelect -> SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048898]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[1048c7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDspChannel
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[10b508c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10d3468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
<LI><a href="#[10f5604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[10f5860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseAnalogSignal
<LI><a href="#[1150f2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
<LI><a href="#[1150fa8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClearDspBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[102b090]"></a>ReConvert_8_24_Value</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ReConvert_8_24_Value</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
</UL>

<P><STRONG><a name="[102b300]"></a>ConvertBalanceValue</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ConvertBalanceValue -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[126e810]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
</UL>

<P><STRONG><a name="[11429d0]"></a>ArrayToDWORD</STRONG> (Thumb, 112 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11427d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>

<P><STRONG><a name="[1142954]"></a>ArrayToHWORD</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[10b1c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
</UL>

<P><STRONG><a name="[ff61f4]"></a>Set_Prologic2Width</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = Set_Prologic2Width -> DSP_PLII_CENTER_WIDTH_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1159200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1159318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
</UL>
<BR>[Called By]<UL><LI><a href="#[be5650]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[ff9ce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
</UL>

<P><STRONG><a name="[ff6300]"></a>Set_Prologic2Dimension</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = Set_Prologic2Dimension -> DSP_PLII_DIMENSION_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1159170]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION
<LI><a href="#[1159318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
</UL>
<BR>[Called By]<UL><LI><a href="#[be58c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[ff9dd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
</UL>

<P><STRONG><a name="[ff6274]"></a>Set_Prologic2Panorama_On_Or_Off</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = Set_Prologic2Panorama_On_Or_Off -> DSP_PLII_CONTROL_REGISTER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1159290]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CONTROL_REGISTER
<LI><a href="#[1159318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[115939c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[be5748]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[ff9d5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
</UL>

<P><STRONG><a name="[bf93e4]"></a>DspProcSpkMode</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[ff19c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>
<BR>[Called By]<UL><LI><a href="#[bf97bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>

<P><STRONG><a name="[bf95d0]"></a>DspProcDelay</STRONG> (Thumb, 312 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff1da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bf98b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspDelay
</UL>

<P><STRONG><a name="[bf964c]"></a>DspProcCorner</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[ff19c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspCorner
</UL>

<P><STRONG><a name="[bf9460]"></a>DspProcSignal</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[109f990]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_ENABLE
<LI><a href="#[109fa0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9740]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
</UL>

<P><STRONG><a name="[bf9558]"></a>DspProcIrc</STRONG> (Thumb, 206 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspProcIrc -> InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[ff78bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[109fa90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Channel
<LI><a href="#[109fb0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Test_Duration
<LI><a href="#[109ff00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[1132130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
<LI><a href="#[11321b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Speaker_Select
<LI><a href="#[1132234]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[bf96c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
</UL>

<P><STRONG><a name="[1047308]"></a>SetDh2On</STRONG> (Thumb, 164 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SetDh2On -> Change_DSP_VIRTUALIZER_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[109ff00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[11428d4]"></a>DspChannelOut5_1</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspChannelOut5_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1132020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[11320ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[1047950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
</UL>

<P><STRONG><a name="[1142854]"></a>DspChannelOut7_1</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1132020]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[11320ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[1047950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[11424dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[1047950]"></a>DspChannelOutSetting</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspChannelOutSetting -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1142854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[11428d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[10478cc]"></a>DspLoadDefaultSetting</STRONG> (Thumb, 196 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 360<LI>Call Chain = DspLoadDefaultSetting -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[ff19c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[ff1d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047118]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[1048cfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[109fc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[109ff00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10a4440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[11427d8]"></a>CheckDspMessage</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b508c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[11429d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ArrayToDWORD
</UL>
<BR>[Called By]<UL><LI><a href="#[114275c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>

<P><STRONG><a name="[114275c]"></a>DspMasterBoot</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10f5604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[10f567c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[11427d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[bf94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>

<P><STRONG><a name="[bf94dc]"></a>DspProcPower</STRONG> (Thumb, 132 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[109fe78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[10f567c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[114275c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>
<BR>[Called By]<UL><LI><a href="#[bf992c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
</UL>

<P><STRONG><a name="[10c8448]"></a>DSPFirmwareWrite</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[109f990]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_ENABLE
<LI><a href="#[10acb54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
<LI><a href="#[1132130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
<LI><a href="#[1142660]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllMono
<LI><a href="#[11426dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllStereo
</UL>

<P><STRONG><a name="[11426dc]"></a>SetMixerAllStereo</STRONG> (Thumb, 178 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = SetMixerAllStereo -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[ff755c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>

<P><STRONG><a name="[1142660]"></a>SetMixerAllMono</STRONG> (Thumb, 232 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[ff755c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>

<P><STRONG><a name="[ff755c]"></a>DspSetCrossbarEffect</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[109ff00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[109ff88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[1142660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllMono
<LI><a href="#[11426dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllStereo
</UL>
<BR>[Called By]<UL><LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[1047de4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[1047f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
</UL>

<P><STRONG><a name="[ff71fc]"></a>GetNormalFreq</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff9800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[1047f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[1047fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048050]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[10481c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[1048a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[ff75e0]"></a>DspDecodePcm</STRONG> (Thumb, 360 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[109fb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[109fd08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[109ff88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[1142854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[11428d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[1047fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048050]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[10481c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[ff76d8]"></a>DspDecodeAc3</STRONG> (Thumb, 728 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[109fb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[109fc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fd08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[11322b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
<LI><a href="#[1142854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[115c73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffd5d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[1047edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[1048148]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[114255c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
<LI><a href="#[11425e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[11425e0]"></a>AC3_Cfg_Change_Deal</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = AC3_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff76d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Called By]<UL><LI><a href="#[1150eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
</UL>

<P><STRONG><a name="[1150eb0]"></a>AnalyseAc3Cfg</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseAc3Cfg -> AC3_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[11425e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[114255c]"></a>TureHD_Cfg_Change_Deal</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = TureHD_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff76d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Called By]<UL><LI><a href="#[1150d38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
</UL>

<P><STRONG><a name="[1150d38]"></a>AnalyseTureHDCfg</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseTureHDCfg -> TureHD_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[114255c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[ff765c]"></a>DspDecodeDTS</STRONG> (Thumb, 636 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[109fb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[109fc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fd08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[109fd84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[109ff00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[109ff88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[1142854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ffd8bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ED
<LI><a href="#[1047e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[10480cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[1142458]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
<LI><a href="#[11424dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[11424dc]"></a>DTS_Cfg_Change_Deal</STRONG> (Thumb, 120 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DTS_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff765c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1142854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
</UL>
<BR>[Called By]<UL><LI><a href="#[1150e34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
</UL>

<P><STRONG><a name="[1150e34]"></a>AnalyseDtsCfg</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseDtsCfg -> DTS_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[11424dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[1142458]"></a>DtsHD_Cfg_Change_Deal</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = DtsHD_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff765c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>
<BR>[Called By]<UL><LI><a href="#[1150db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
</UL>

<P><STRONG><a name="[10b1c64]"></a>ReadDsp</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = ReadDsp -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10b508c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10f5604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[1142954]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ArrayToHWORD
</UL>
<BR>[Called By]<UL><LI><a href="#[102b210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[102b288]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[10a43c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDelay
<LI><a href="#[10bb584]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
<LI><a href="#[11423d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDTSHDChannel
<LI><a href="#[1155cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolbyPLIIX
<LI><a href="#[115c5c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadRegist
<LI><a href="#[115c644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadCrossbar
<LI><a href="#[115c6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolby
<LI><a href="#[1164f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadSgen
<LI><a href="#[1169dac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadOS
<LI><a href="#[1196f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
</UL>

<P><STRONG><a name="[11423d8]"></a>DspReadDTSHDChannel</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, dspdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1150db8]"></a>AnalyseDtsHDCfg</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseDtsHDCfg -> DtsHD_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1142458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[109ffe0]"></a>ProcAutodetecResponse</STRONG> (Thumb, 986 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcAutodetecResponse -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[bf992c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[ff1bb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff75e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1047ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[1048d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[1048e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1142854]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[115c73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1150c34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
</UL>

<P><STRONG><a name="[1150c34]"></a>DspProcUnsolicitedMsg</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = DspProcUnsolicitedMsg -> ProcAutodetecResponse -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[109ffe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>
<BR>[Called By]<UL><LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[ff6478]"></a>SetLate</STRONG> (Thumb, 118 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = SetLate -> DSP_TRUEHD_Boost_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[109f904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[1132334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[11323b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[115c7bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[115c838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[115c8b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[ff7d04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
<LI><a href="#[ffd9ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1C
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[111fa70]"></a>CALC_EQ_FC</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CALC_EQ_FC</UL>
<BR>[Calls]<UL><LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[111f9f8]"></a>CALC_EQ_Q</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CALC_EQ_Q</UL>
<BR>[Calls]<UL><LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[111f980]"></a>CALC_EQ_G</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = CALC_EQ_G</UL>
<BR>[Calls]<UL><LI><a href="#[126ab44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[111f904]"></a>DSP_Eq_Control</STRONG> (Thumb, 146 bytes, Stack size 32 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1d20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[ff7374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
</UL>

<P><STRONG><a name="[111f888]"></a>DSP_Eq_Config</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[111f80c]"></a>DSP_Eq_Channels</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[111f790]"></a>DSP_Eq_Bands</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[111f714]"></a>DSP_Eq_Flash</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[111f68c]"></a>DSP_EQ_CH_PREATTENUATION</STRONG> (Thumb, 222 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[111f610]"></a>DSP_EQ_POSTGAIN</STRONG> (Thumb, 226 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[111f594]"></a>DSP_EQ_CHANGER</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_EQ_CHANGER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[ff73e8]"></a>EqModuleconfig</STRONG> (Thumb, 452 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[111f594]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[111f904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
<LI><a href="#[111f980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G
<LI><a href="#[111f9f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q
<LI><a href="#[111fa70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be57c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[ffd374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
</UL>

<P><STRONG><a name="[111f514]"></a>DSP_Power_on_config</STRONG> (Thumb, 442 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff71fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[111f594]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[111f980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G
<LI><a href="#[111f9f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q
<LI><a href="#[111fa70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC
<LI><a href="#[126d18c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1d20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
</UL>

<P><STRONG><a name="[ff1d20]"></a>DSP_EQ_Firmware_Init</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DSP_EQ_Firmware_Init -> DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[111f514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
<LI><a href="#[111f904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[ff7374]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[ff7a20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[ff7374]"></a>EqOn</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = EqOn -> DSP_EQ_Firmware_Init -> DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff1d20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[111f904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[ffce1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[111f49c]"></a>DspReadEq</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[10b508c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[10f5604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>

<P><STRONG><a name="[1171fb8]"></a>Convert_8_24_Value</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Convert_8_24_Value</UL>
<BR>[Calls]<UL><LI><a href="#[126c960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1132130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
</UL>

<P><STRONG><a name="[1132130]"></a>InitMicParameter</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[1171fb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1171f38]"></a>DSP_IRC_1_Control</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109fa90]"></a>DSP_Rx_Channel</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_Rx_Channel -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1171ec0]"></a>DSP_Rx_Gain</STRONG> (Thumb, 84 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1171e40]"></a>DSP_IRC1_Tx_Channel</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109fb0c]"></a>DSP_IRC1_Test_Duration</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_IRC1_Test_Duration -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1171dbc]"></a>DSP_IRC_1_Test_Signal</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[102b288]"></a>DspReadIrc1</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[102b194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSpkDistance
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
<LI><a href="#[1171d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsIrc1ValidResult
</UL>

<P><STRONG><a name="[102b194]"></a>GetSpkDistance</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = GetSpkDistance -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[102b288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
</UL>
<BR>[Called By]<UL><LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[1171d3c]"></a>IsIrc1ValidResult</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[102b288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
</UL>

<P><STRONG><a name="[1132234]"></a>Dsp_IRC2_Control</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = Dsp_IRC2_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[11321b0]"></a>Dsp_IRC2_Speaker_Select</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = Dsp_IRC2_Speaker_Select -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[116c524]"></a>Dsp_IRC2_Max_EQ_Fc</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc2_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[102b210]"></a>DspReadIrc2</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DspReadIrc2 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[102b114]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[102b114]"></a>IsIrc2ValidResult</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = IsIrc2ValidResult -> DspReadIrc2 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[102b210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
</UL>
<BR>[Called By]<UL><LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[11320ac]"></a>OS_OUTPUT_MODE_CONTROL</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, os_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = OS_OUTPUT_MODE_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1142854]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[11428d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>

<P><STRONG><a name="[1132020]"></a>OS_OUTPUT_MODE_CONTROL_FOR_DSPB</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, os_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1142854]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[11428d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>

<P><STRONG><a name="[1169eb8]"></a>OS_OUTPUT_MODE_CONTROL_Debug</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1169e24]"></a>OS_OUTPUT_MODE_CONTROL_FOR_DSPB_Debug</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1169dac]"></a>DspReadOS</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109f990]"></a>DSP_SGEN_ENABLE</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, signalgenerator.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10c8448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9460]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>

<P><STRONG><a name="[109fa0c]"></a>DSP_SGEN_CHANNEL_ENABLE</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, signalgenerator.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_SGEN_CHANNEL_ENABLE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9460]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>

<P><STRONG><a name="[1164fd0]"></a>DSP_CHANNEL_SIGNAL_SELECT</STRONG> (Thumb, 222 bytes, Stack size 32 bytes, signalgenerator.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1164f58]"></a>DspReadSgen</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, signalgenerator.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[119700c]"></a>DSP_TRUEHD_Control</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1196f80]"></a>DSP_TRUEHD_Decode_Mode_Control</STRONG> (Thumb, 166 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1132334]"></a>DSP_TRUEHD_DRC_Control</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = DSP_TRUEHD_DRC_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[11322b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[11323b8]"></a>DSP_TRUEHD_Cut_Scalefactor</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[11322b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[109f904]"></a>DSP_TRUEHD_Boost_Scalefactor</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_TRUEHD_Boost_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[11322b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[11322b4]"></a>DSP_TRUEHD_DRC_INIT</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = DSP_TRUEHD_DRC_INIT -> DSP_TRUEHD_Boost_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[109f904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[1132334]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[11323b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
</UL>
<BR>[Called By]<UL><LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>

<P><STRONG><a name="[1196f04]"></a>DspReadTRUEHD</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[109fe00]"></a>DSP_BOOT</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + In Cycle
<LI>Call Chain = DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[109ff88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[11939ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
<LI><a href="#[1193a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[1193c70]"></a>DSP_CFG_OUTPUT_FS</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1193bf0]"></a>DSP_CFG_AUDIO_SRC</STRONG> (Thumb, 172 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_AUDIO_SRC -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[11939ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
</UL>

<P><STRONG><a name="[109fd84]"></a>DSP_CFG_DECODER</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_DECODER -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>

<P><STRONG><a name="[109fd08]"></a>DSP_CFG_MATRIX</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_MATRIX -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
</UL>

<P><STRONG><a name="[109fb90]"></a>DSP_CFG_VIRTUALIZER</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_VIRTUALIZER -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>

<P><STRONG><a name="[109fc90]"></a>DSP_CFG_PPM</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_PPM -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[1193a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[109fc10]"></a>DSP_CFG_PPM_Mode</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_PPM_Mode -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[1193a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[1193b6c]"></a>DSP_CFG_PPM_Mode_Pl2x</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1193aec]"></a>DSP_CFG_MCLK_FACTOR</STRONG> (Thumb, 168 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_MCLK_FACTOR -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff1e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[109ff00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[11939ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
</UL>

<P><STRONG><a name="[ff1e2c]"></a>Change_DSP_Decoder_Code</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Change_DSP_Decoder_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[109fd84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1193aec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[1193bf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[be5ab8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[106d820]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[109ff88]"></a>Change_DSP_MATRIX_Code</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Change_DSP_MATRIX_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[109fc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fd08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
</UL>
<BR>[Called By]<UL><LI><a href="#[ff755c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>

<P><STRONG><a name="[109ff00]"></a>Change_DSP_VIRTUALIZER_Code</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Change_DSP_VIRTUALIZER_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[109fb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[109fc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fd84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1193aec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[1193bf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
</UL>
<BR>[Called By]<UL><LI><a href="#[bf9558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[ff755c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[1047308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[10478cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[1193a6c]"></a>Change_DSP_PPM_Code</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[109fc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
</UL>

<P><STRONG><a name="[109fe78]"></a>Change_Input_Audio_Source</STRONG> (Thumb, 414 bytes, Stack size 8 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Change_Input_Audio_Source -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[ff7848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1048628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[109fb90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[109fc10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[109fc90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[109fd08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[109fd84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1193aec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[1193bf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[bf94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>

<P><STRONG><a name="[11939ec]"></a>DSP_Update_Flash</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[109fe00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1193aec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[1193bf0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
</UL>

<P><STRONG><a name="[10bb584]"></a>DSP_API_Read</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_API_Read -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10b1c64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10b5108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10bb600]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Busy
</UL>

<P><STRONG><a name="[11b99d0]"></a>_printf_pre_padding</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, _printf_pad.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_pre_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[1262828]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[1262e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[126339c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[1280a80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[11b994c]"></a>_printf_post_padding</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, _printf_pad.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[1262828]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[1262e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[126339c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[1280a80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[11b94dc]"></a>_printf_int_dec</STRONG> (Thumb, 98 bytes, Stack size 72 bytes, _printf_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = _printf_int_dec -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1262828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[12637a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
<LI><a href="#[12637f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_signed
<LI><a href="#[127ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_udiv10 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11b8e44]"></a>vsprintf</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, vsprintf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[127f33c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[127f8ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[c0110c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff17d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5f8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[106db80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
</UL>

<P><STRONG><a name="[11b83b4]"></a>__0sprintf</STRONG> (Thumb, 40 bytes, Stack size 32 bytes, __0sprintf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = __0sprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[127f33c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[127f8ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
</UL>

<P><STRONG><a name="[11b7ed8]"></a>__aeabi_memset</STRONG> (ARM, 16 bytes, Stack size 0 bytes, aeabi_memset.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[127ef10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[b40170]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitRemoteRepeatKey (via Veneer)
<LI><a href="#[ff5f0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank (via Veneer)
<LI><a href="#[106d040]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank (via Veneer)
</UL>

<P><STRONG><a name="[11b7a7c]"></a>__aeabi_memcpy</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memcpy.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage (via Veneer)
<LI><a href="#[be5f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup (via Veneer)
<LI><a href="#[be6094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup (via Veneer)
<LI><a href="#[ffca54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN (via Veneer)
<LI><a href="#[1009ed4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage (via Veneer)
<LI><a href="#[1009f4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage (via Veneer)
<LI><a href="#[1150f2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg (via Veneer)
</UL>

<P><STRONG><a name="[11b7a04]"></a>__rt_memcpy</STRONG> (ARM, 212 bytes, Stack size 0 bytes, rt_memcpy.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b7408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[11b7acc]"></a>_memcpy_lastbytes</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy.o(.text), UNUSED)

<P><STRONG><a name="[11b7408]"></a>__aeabi_memcpy4</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_memcpy4</UL>
<BR>[Called By]<UL><LI><a href="#[ff1bb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte (via Veneer)
<LI><a href="#[ff708c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte (via Veneer)
<LI><a href="#[ff7464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte (via Veneer)
<LI><a href="#[ff74e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte (via Veneer)
<LI><a href="#[ff77cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte (via Veneer)
<LI><a href="#[102b508]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display (via Veneer)
<LI><a href="#[10d34e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte (via Veneer)
<LI><a href="#[10d3560]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte (via Veneer)
<LI><a href="#[1117c14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte (via Veneer)
<LI><a href="#[1117c8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte (via Veneer)
<LI><a href="#[11b7a04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_memcpy
</UL>

<P><STRONG><a name="[11b7458]"></a>__aeabi_memcpy8</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11b738c]"></a>__rt_memcpy_w</STRONG> (ARM, 100 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11b74d4]"></a>_memcpy_lastbytes_aligned</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[11b6eb8]"></a>strncpy</STRONG> (ARM, 108 bytes, Stack size 8 bytes, strncpy.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strncpy</UL>
<BR>[Calls]<UL><LI><a href="#[127eec0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[ff17d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay (via Veneer)
<LI><a href="#[ff5f8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp (via Veneer)
</UL>

<P><STRONG><a name="[11b6a14]"></a>strlen</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, strlen.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strlen</UL>
<BR>[Called By]<UL><LI><a href="#[c0110c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[ff17d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5f8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[102b508]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[102b604]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[106db80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
</UL>

<P><STRONG><a name="[11b62e4]"></a>__aeabi_idiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text), UNUSED)

<P><STRONG><a name="[11b6294]"></a>__aeabi_idivmod</STRONG> (ARM, 364 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[12659f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idiv0
</UL>
<BR>[Called By]<UL><LI><a href="#[b40364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage (via Veneer)
<LI><a href="#[bfcfd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElement (via Veneer)
<LI><a href="#[bfd150]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
<LI><a href="#[bfd1c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DeQueue (via Veneer)
<LI><a href="#[bfd2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull (via Veneer)
<LI><a href="#[bfd328]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty (via Veneer)
<LI><a href="#[1009ed4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage (via Veneer)
<LI><a href="#[1009f4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage (via Veneer)
<LI><a href="#[100a688]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull (via Veneer)
<LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay (via Veneer)
<LI><a href="#[102b090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value (via Veneer)
<LI><a href="#[102b300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[1048240]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek (via Veneer)
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey (via Veneer)
<LI><a href="#[12753e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
<LI><a href="#[1280bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp (via Veneer)
</UL>

<P><STRONG><a name="[11b3544]"></a>__use_two_region_memory</STRONG> (ARM, 4 bytes, Stack size 0 bytes, stkheap2.o(.text), UNUSED)

<P><STRONG><a name="[11b34bc]"></a>__rt_stackheap_init</STRONG> (ARM, 60 bytes, Stack size 24 bytes, stkheap2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = __rt_stackheap_init -> __user_setup_stackheap</UL>
<BR>[Calls]<UL><LI><a href="#[1264b18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_storage
<LI><a href="#[1265e74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>
<BR>[Called By]<UL><LI><a href="#[12667f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11b3434]"></a>__rt_heap_extend</STRONG> (ARM, 24 bytes, Stack size 8 bytes, stkheap2.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b3618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[126a0d0]"></a>__ARM_switch8</STRONG> (ARM, 24 bytes, Stack size 0 bytes, switch8.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[be5000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup (via Veneer)
<LI><a href="#[be64f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup (via Veneer)
<LI><a href="#[bf95d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay (via Veneer)
<LI><a href="#[bf964c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner (via Veneer)
<LI><a href="#[ff1ca8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacInvert (via Veneer)
<LI><a href="#[ff1da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting (via Veneer)
<LI><a href="#[ff1e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code (via Veneer)
<LI><a href="#[ff1eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChanegName (via Veneer)
<LI><a href="#[ff21a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance (via Veneer)
<LI><a href="#[ff23a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay (via Veneer)
<LI><a href="#[ff241c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode (via Veneer)
<LI><a href="#[ff251c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode (via Veneer)
<LI><a href="#[ff6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault (via Veneer)
<LI><a href="#[ff6384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase (via Veneer)
<LI><a href="#[ff6478]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate (via Veneer)
<LI><a href="#[ff7184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSrcName (via Veneer)
<LI><a href="#[ff75e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm (via Veneer)
<LI><a href="#[ff765c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS (via Veneer)
<LI><a href="#[ff76d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3 (via Veneer)
<LI><a href="#[ff9800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType (via Veneer)
<LI><a href="#[ff9c64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL (via Veneer)
<LI><a href="#[ff9ce0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC (via Veneer)
<LI><a href="#[ff9dd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM (via Veneer)
<LI><a href="#[ffca54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN (via Veneer)
<LI><a href="#[ffccb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S (via Veneer)
<LI><a href="#[ffcd28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone2Channel (via Veneer)
<LI><a href="#[ffd2f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid (via Veneer)
<LI><a href="#[ffd3f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1DF_ (via Veneer)
<LI><a href="#[ffd55c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E (via Veneer)
<LI><a href="#[ffd7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF (via Veneer)
<LI><a href="#[ffdb8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S (via Veneer)
<LI><a href="#[ffdc04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel (via Veneer)
<LI><a href="#[ffdcf8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode (via Veneer)
<LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService (via Veneer)
<LI><a href="#[1018730]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change (via Veneer)
<LI><a href="#[10187b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change (via Veneer)
<LI><a href="#[101b53c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcDigitKey (via Veneer)
<LI><a href="#[103612c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey (via Veneer)
<LI><a href="#[10479d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO (via Veneer)
<LI><a href="#[1047d6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey (via Veneer)
<LI><a href="#[1047edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey (via Veneer)
<LI><a href="#[1048898]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect (via Veneer)
<LI><a href="#[1048a0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType (via Veneer)
<LI><a href="#[104afe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey (via Veneer)
<LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage (via Veneer)
<LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage (via Veneer)
<LI><a href="#[106d4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService (via Veneer)
<LI><a href="#[106d528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom (via Veneer)
<LI><a href="#[106d624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey (via Veneer)
<LI><a href="#[106d6a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey (via Veneer)
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[106dd74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption (via Veneer)
<LI><a href="#[109fa0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE (via Veneer)
<LI><a href="#[109fe00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT (via Veneer)
<LI><a href="#[109fe78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source (via Veneer)
<LI><a href="#[109ffe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse (via Veneer)
<LI><a href="#[10a4640]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Max_Setting (via Veneer)
<LI><a href="#[10acb54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode (via Veneer)
<LI><a href="#[10acd78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK (via Veneer)
<LI><a href="#[10ace00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT (via Veneer)
<LI><a href="#[10ace8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE (via Veneer)
<LI><a href="#[10ad24c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL (via Veneer)
<LI><a href="#[10ad2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL (via Veneer)
<LI><a href="#[10ad358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER (via Veneer)
<LI><a href="#[10ecc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD (via Veneer)
<LI><a href="#[10f5c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335 (via Veneer)
<LI><a href="#[111f610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_POSTGAIN (via Veneer)
<LI><a href="#[111f68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CH_PREATTENUATION (via Veneer)
<LI><a href="#[1155d40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DIMENSION_CONFIGURATION (via Veneer)
<LI><a href="#[1155dd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CENTER_WIDTH_CONFIGURATION (via Veneer)
<LI><a href="#[1159170]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION (via Veneer)
<LI><a href="#[1159200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION (via Veneer)
<LI><a href="#[1159318]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE (via Veneer)
<LI><a href="#[1164fd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CHANNEL_SIGNAL_SELECT (via Veneer)
<LI><a href="#[1193bf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC (via Veneer)
<LI><a href="#[1193c70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_OUTPUT_FS (via Veneer)
<LI><a href="#[1196f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Decode_Mode_Control (via Veneer)
</UL>

<P><STRONG><a name="[126a054]"></a>__rt_switch8</STRONG> (ARM, 0 bytes, Stack size 0 bytes, switch8.o(.text), UNUSED)

<P><STRONG><a name="[1269c48]"></a>__ARM_call_via_r0</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40548]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[10e2774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[10e295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
</UL>

<P><STRONG><a name="[1269c98]"></a>__call_via_r0</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1269b7c]"></a>__ARM_call_via_r1</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[c21e60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[1064690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundProcMessage
<LI><a href="#[10e2774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[10e27f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[10e286c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[10e28e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10e295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1269bcc]"></a>__call_via_r1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1269ab0]"></a>__ARM_call_via_r2</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff7b9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
<LI><a href="#[11b994c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[11b99d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[1262828]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[1262e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
<LI><a href="#[1280a80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[12902c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_outstr_char
</UL>

<P><STRONG><a name="[1269b00]"></a>__call_via_r2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[12699e4]"></a>__ARM_call_via_r3</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[106ddf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[106de78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;load_default_option
<LI><a href="#[106def8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[106df78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[106dff8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[126339c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
<LI><a href="#[128fae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
</UL>

<P><STRONG><a name="[1269a34]"></a>__call_via_r3</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[12698e8]"></a>__ARM_call_via_r4</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1269968]"></a>__call_via_r4</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[12697ec]"></a>__ARM_call_via_r5</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[126986c]"></a>__call_via_r5</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[12696f0]"></a>__ARM_call_via_r6</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1269770]"></a>__call_via_r6</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[12695f4]"></a>__ARM_call_via_r7</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1269674]"></a>__call_via_r7</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1268e90]"></a>pow</STRONG> (ARM, 3604 bytes, Stack size 216 bytes, pow.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[11aef08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[11af734]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2d
<LI><a href="#[11b0798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv
<LI><a href="#[11b19d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dsub
<LI><a href="#[11b1a98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_drsub
<LI><a href="#[11b1b88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
<LI><a href="#[1263d44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[1268d9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copysign
<LI><a href="#[126bcb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple
<LI><a href="#[12796dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sqrt
<LI><a href="#[1279f74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
<LI><a href="#[127b45c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scalbn
</UL>
<BR>[Called By]<UL><LI><a href="#[10ad568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[1268e14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__softfp_pow
</UL>

<P><STRONG><a name="[1268e14]"></a>__softfp_pow</STRONG> (ARM, 4 bytes, Stack size 0 bytes, pow.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1268e90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[12667f4]"></a>__rt_entry</STRONG> (ARM, 76 bytes, Stack size 16 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 68 + Unknown Stack Size
<LI>Call Chain = __rt_entry -> __rt_lib_init -> _get_lc_ctype -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[11b34bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
<LI><a href="#[1289934]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_lib_init
<LI><a href="#[1289d88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_stackheap_init
<LI><a href="#[128b4cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
<LI><a href="#[128eb94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit (via BX)
</UL>
<BR>[Called By]<UL><LI><a href="#[11b2e04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__main
<LI><a href="#[11c5c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
</UL>

<P><STRONG><a name="[12666ac]"></a>__rt_exit</STRONG> (ARM, 20 bytes, Stack size 8 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __rt_exit -> __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[128b47c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[128eb94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (via Veneer)
</UL>

<P><STRONG><a name="[1266634]"></a>__rt_abort</STRONG> (ARM, 8 bytes, Stack size 0 bytes, kernel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12790b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>

<P><STRONG><a name="[1265e74]"></a>__user_setup_stackheap</STRONG> (ARM, 96 bytes, Stack size 8 bytes, sys_stackheap_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __user_setup_stackheap</UL>
<BR>[Calls]<UL><LI><a href="#[b46514]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_initial_stackheap
<LI><a href="#[1278bdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[11b34bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[12659f0]"></a>__aeabi_idiv0</STRONG> (ARM, 4 bytes, Stack size 0 bytes, aeabi_idiv0.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b6294]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod
</UL>

<P><STRONG><a name="[1264b18]"></a>__rt_stackheap_storage</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_stackheap_storage_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b34bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[1263d94]"></a>__read_errno</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, _rserrno.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1277a68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr (via Veneer)
</UL>

<P><STRONG><a name="[1263d44]"></a>__set_errno</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, _rserrno.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __set_errno</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1277a68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow (via Veneer)
<LI><a href="#[12796dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt (via Veneer)
</UL>

<P><STRONG><a name="[12637f4]"></a>_printf_truncate_signed</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, _printf_truncate.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[12637a4]"></a>_printf_truncate_unsigned</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, _printf_truncate.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[1261c10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[12621ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>

<P><STRONG><a name="[126339c]"></a>_printf_str</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, _printf_str.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = _printf_str -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11b994c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[11b99d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1262e6c]"></a>_printf_wctomb</STRONG> (Thumb, 190 bytes, Stack size 56 bytes, _printf_wctomb.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = _printf_wctomb -> _wcrtomb -> __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[11b994c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[11b99d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[128fae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1262828]"></a>_printf_int_common</STRONG> (Thumb, 168 bytes, Stack size 40 bytes, _printf_intcommon.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11b994c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[11b99d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[11b94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[1261768]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[1261c10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[12621ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>

<P><STRONG><a name="[12621ec]"></a>_printf_longlong_hex</STRONG> (Thumb, 182 bytes, Stack size 88 bytes, _printf_longlong_hex.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_hex -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1262828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[12637a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1261c10]"></a>_printf_longlong_oct</STRONG> (Thumb, 138 bytes, Stack size 64 bytes, _printf_longlong_oct.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_oct -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1262828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[12637a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1261768]"></a>_printf_longlong_dec</STRONG> (Thumb, 124 bytes, Stack size 80 bytes, _printf_longlong_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_dec -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1262828]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[1275a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[128103c]"></a>_printf_charcount</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, _printf_charcount.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1280b48]"></a>__lib_sel_fp_printf</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, _printf_fp_dec.o(.text), UNUSED)

<P><STRONG><a name="[1280ad0]"></a>_fp_display</STRONG> (Thumb, 806 bytes, Stack size 64 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[12766b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[1280bc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp
<LI><a href="#[1280c40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
<LI><a href="#[1287bf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__mathlib_classify (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1280a80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[1280a80]"></a>_printf_fp_dec_real</STRONG> (Thumb, 234 bytes, Stack size 56 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11b994c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[11b99d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[1280ad0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>
<BR>[Called By]<UL><LI><a href="#[126a598]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec (via Veneer)
</UL>

<P><STRONG><a name="[127f8ec]"></a>_printf_char_common</STRONG> (Thumb, 44 bytes, Stack size 88 bytes, _printf_char_common.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[12718b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>
<BR>[Called By]<UL><LI><a href="#[11b83b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11b8e44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>

<P><STRONG><a name="[127f33c]"></a>_sputc</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, _sputc.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b83b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11b8e44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Address Reference Count : 2]<UL><LI> __0sprintf.o(.text)
<LI> vsprintf.o(.text)
</UL>
<P><STRONG><a name="[127eec0]"></a>__aeabi_memclr</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b6eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>

<P><STRONG><a name="[127ee48]"></a>__rt_memclr</STRONG> (ARM, 64 bytes, Stack size 0 bytes, rt_memclr.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[128e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[127ef10]"></a>_memset</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b7ed8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>

<P><STRONG><a name="[127ea18]"></a>__rt_udiv10</STRONG> (ARM, 44 bytes, Stack size 0 bytes, rtudiv10.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b94dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec (via Veneer)
</UL>

<P><STRONG><a name="[1279f74]"></a>__kernel_poly</STRONG> (ARM, 248 bytes, Stack size 24 bytes, poly.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[11aef08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[11b1b88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
</UL>
<BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[12796dc]"></a>sqrt</STRONG> (ARM, 100 bytes, Stack size 16 bytes, sqrt.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = sqrt -> _dsqrt</UL>
<BR>[Calls]<UL><LI><a href="#[1263d44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[126c260]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple
<LI><a href="#[12890a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsqrt
</UL>
<BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[1279660]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__softfp_sqrt
</UL>

<P><STRONG><a name="[1279660]"></a>__softfp_sqrt</STRONG> (ARM, 4 bytes, Stack size 0 bytes, sqrt.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12796dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[12790b8]"></a>_sys_exit</STRONG> (ARM, 20 bytes, Stack size 0 bytes, sys_exit.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1266634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_abort
</UL>

<P><STRONG><a name="[1278ab4]"></a>__user_libspace</STRONG> (ARM, 8 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[1278bdc]"></a>__user_perproc_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1265e74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[1278b54]"></a>__user_perthread_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[1277a68]"></a>__aeabi_errno_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_errno_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1263d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[1263d94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__read_errno (via Veneer)
</UL>

<P><STRONG><a name="[1277af4]"></a>__rt_errno_addr_intlibspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_errno_addr_intlibspace.o(.text), UNUSED)

<P><STRONG><a name="[12766b8]"></a>__rt_locale</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_locale_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1280ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (via Veneer)
<LI><a href="#[1286e3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
<LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[1275a08]"></a>_ll_udiv10</STRONG> (ARM, 160 bytes, Stack size 12 bytes, lludiv10.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _ll_udiv10</UL>
<BR>[Called By]<UL><LI><a href="#[1261768]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec (via Veneer)
<LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[12753e8]"></a>_btod_etento</STRONG> (Thumb, 202 bytes, Stack size 72 bytes, bigflt0.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1274450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul (via Veneer)
<LI><a href="#[12744a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[12718b8]"></a>__printf</STRONG> (Thumb, 740 bytes, Stack size 48 bytes, __printf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384 + Unknown Stack Size
<LI>Call Chain = __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[11b94dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[1261768]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[1261c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[12621ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
<LI><a href="#[1262e6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[126339c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
<LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[126a598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec (via Veneer)
<LI><a href="#[12717c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wc (Weak Reference)
<LI><a href="#[127183c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_mbtowc (Weak Reference)
<LI><a href="#[127acdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex (via Veneer)
<LI><a href="#[128103c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_charcount
</UL>
<BR>[Called By]<UL><LI><a href="#[127f8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>

<P><STRONG><a name="[12902c0]"></a>_printf_outstr_char</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, _printf_outstr_char.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_outstr_char</UL>
<BR>[Calls]<UL><LI><a href="#[1269ab0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[128fec4]"></a>_printf_input_char</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, _printf_input_char.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[128fae4]"></a>_wcrtomb</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, _wcrtomb.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = _wcrtomb -> __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[12699e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
<LI><a href="#[1286e3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1262e6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
</UL>

<P><STRONG><a name="[128f17c]"></a>_get_lc_numeric</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, lc_numeric_c.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1285bd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[128eb94]"></a>exit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = exit -> __rt_exit -> __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[12666ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
<LI><a href="#[128eac4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_call_atexit_fns (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[12667f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[128e5d0]"></a>__aeabi_memclr4</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[128e64c]"></a>__aeabi_memclr8</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[128e554]"></a>__rt_memclr_w</STRONG> (ARM, 84 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[128e6c8]"></a>_memset_w</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[127ee48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_memclr
</UL>

<P><STRONG><a name="[128b4cc]"></a>__rt_lib_init</STRONG> (Thumb, 188 bytes, Stack size 40 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = __rt_lib_init -> _get_lc_ctype -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[12766b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[1281180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype
<LI><a href="#[1283e14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init (via Veneer)
<LI><a href="#[128ab40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_signal_init (Weak Reference)
<LI><a href="#[128abbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_rand_init (Weak Reference)
<LI><a href="#[128ac34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio (Weak Reference)
<LI><a href="#[128aca8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_user_alloc (Weak Reference)
<LI><a href="#[128ad28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc (Weak Reference)
<LI><a href="#[128ada0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_getenv_init (Weak Reference)
<LI><a href="#[128ae1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_time (Weak Reference)
<LI><a href="#[128ae98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_monetary (Weak Reference)
<LI><a href="#[128af94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_collate (Weak Reference)
<LI><a href="#[128b010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_trap_init (Weak Reference)
<LI><a href="#[128b08c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_clock_init (Weak Reference)
<LI><a href="#[128b104]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_atexit_init (Weak Reference)
<LI><a href="#[128b1fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cpp_initialize__aeabi_ (Weak Reference)
<LI><a href="#[128b284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__alloca_initialize (Weak Reference)
<LI><a href="#[128b304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_DescSize (Weak Reference)
<LI><a href="#[128b380]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_exceptions_init (Weak Reference)
<LI><a href="#[128b598]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_argv_veneer (via Veneer)
<LI><a href="#[128f17c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric
</UL>
<BR>[Called By]<UL><LI><a href="#[12667f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry (via Veneer)
</UL>

<P><STRONG><a name="[128b47c]"></a>__rt_lib_shutdown</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[128aa40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio (Weak Reference)
<LI><a href="#[128aabc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminate_user_alloc (Weak Reference)
<LI><a href="#[128b180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[12666ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
</UL>

<P><STRONG><a name="[1289d88]"></a>_platform_post_stackheap_init</STRONG> (ARM, 12 bytes, Stack size 0 bytes, boardinit2.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[12667f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[1289934]"></a>_platform_post_lib_init</STRONG> (ARM, 16 bytes, Stack size 8 bytes, boardinit3.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _platform_post_lib_init</UL>
<BR>[Called By]<UL><LI><a href="#[12667f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[1287bf8]"></a>__mathlib_classify</STRONG> (ARM, 56 bytes, Stack size 8 bytes, classify.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __mathlib_classify</UL>
<BR>[Calls]<UL><LI><a href="#[12838ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_fpclassify
</UL>
<BR>[Called By]<UL><LI><a href="#[1280ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (via Veneer)
</UL>

<P><STRONG><a name="[1287734]"></a>__support_dtoi</STRONG> (ARM, 96 bytes, Stack size 16 bytes, dtoi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __support_dtoi</UL>
<BR>[Calls]<UL><LI><a href="#[127b45c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scalbn
</UL>
<BR>[Called By]<UL><LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[12872a0]"></a>__I_use_semihosting</STRONG> (ARM, 0 bytes, Stack size 0 bytes, use_no_semi.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> sys_exit.o(.text)
</UL>
<P><STRONG><a name="[1287218]"></a>__use_no_semihosting_swi</STRONG> (ARM, 4 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[1286e3c]"></a>__rt_ctype_table</STRONG> (ARM, 24 bytes, Stack size 8 bytes, rt_ctype_table.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[12766b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
</UL>
<BR>[Called By]<UL><LI><a href="#[128fae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb (via Veneer)
</UL>

<P><STRONG><a name="[1285bd8]"></a>strcmp</STRONG> (ARM, 156 bytes, Stack size 4 bytes, strcmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = strcmp</UL>
<BR>[Called By]<UL><LI><a href="#[1281180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (via Veneer)
<LI><a href="#[128f17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (via Veneer)
</UL>

<P><STRONG><a name="[1284228]"></a>__ARM_get_argv</STRONG> (Thumb, 6 bytes, Stack size 4 bytes, no_argv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __ARM_get_argv</UL>
<BR>[Address Reference Count : 1]<UL><LI> lib_init.o(.emb_text)
</UL>
<P><STRONG><a name="[12838ac]"></a>__ARM_fpclassify</STRONG> (ARM, 44 bytes, Stack size 0 bytes, fpclassify.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1287bf8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__mathlib_classify
</UL>

<P><STRONG><a name="[12825a8]"></a>__rt_fp_status_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_fp_status_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1283e14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[1281180]"></a>_get_lc_ctype</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, lc_ctype_c.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _get_lc_ctype -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1285bd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rt_ctype_table.o(.text)
</UL>
<P><STRONG><a name="[11b6218]"></a>__aeabi_uidiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv), UNUSED)

<P><STRONG><a name="[11b61c8]"></a>__aeabi_uidivmod</STRONG> (ARM, 28 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv))
<BR><BR>[Calls]<UL><LI><a href="#[11b647c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div_large
<LI><a href="#[11b64f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div8
<LI><a href="#[11b6570]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div4
</UL>
<BR>[Called By]<UL><LI><a href="#[ff6664]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset (via Veneer)
<LI><a href="#[ff82c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTT_ (via Veneer)
<LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[10188b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd (via Veneer)
<LI><a href="#[1018ba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay (via Veneer)
<LI><a href="#[1034a60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command (via Veneer)
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage (via Veneer)
<LI><a href="#[10dc6d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetUart1Baudrate (via Veneer)
<LI><a href="#[10dc840]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetUart0Baudrate (via Veneer)
</UL>

<P><STRONG><a name="[12744f0]"></a>_btod_d2e</STRONG> (ARM, 56 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e))
<BR><BR>[Calls]<UL><LI><a href="#[12743d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>
<BR>[Called By]<UL><LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[1274358]"></a>_d2e_denorm_low</STRONG> (ARM, 84 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e_denorm_low))
<BR><BR>[Called By]<UL><LI><a href="#[12743d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>

<P><STRONG><a name="[12743d4]"></a>_d2e_norm_op1</STRONG> (ARM, 104 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e_norm_op1))
<BR><BR>[Calls]<UL><LI><a href="#[1274358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_denorm_low
</UL>
<BR>[Called By]<UL><LI><a href="#[12744f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e
</UL>

<P><STRONG><a name="[1274080]"></a>__btod_div_common</STRONG> (ARM, 716 bytes, Stack size 24 bytes, btod.o(CL$$btod_div_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __btod_div_common</UL>
<BR>[Called By]<UL><LI><a href="#[12744a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[12741f4]"></a>_e2e</STRONG> (ARM, 220 bytes, Stack size 24 bytes, btod.o(CL$$btod_e2e))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = _e2e</UL>
<BR>[Called By]<UL><LI><a href="#[1274450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
<LI><a href="#[12744a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[12744a0]"></a>_btod_ediv</STRONG> (ARM, 52 bytes, Stack size 24 bytes, btod.o(CL$$btod_ediv))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _btod_ediv -> __btod_div_common</UL>
<BR>[Calls]<UL><LI><a href="#[1274080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_div_common
<LI><a href="#[12741f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[12753e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
<LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[1274450]"></a>_btod_emul</STRONG> (ARM, 52 bytes, Stack size 24 bytes, btod.o(CL$$btod_emul))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1274100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_mult_common
<LI><a href="#[12741f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[12753e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
<LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[1274100]"></a>__btod_mult_common</STRONG> (ARM, 616 bytes, Stack size 16 bytes, btod.o(CL$$btod_mult_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __btod_mult_common</UL>
<BR>[Called By]<UL><LI><a href="#[1274450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
</UL>

<P><STRONG><a name="[1268d9c]"></a>copysign</STRONG> (ARM, 16 bytes, Stack size 0 bytes, pow.o(i.copysign))
<BR><BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11b268c]"></a>__aeabi_d2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, d2f.o(x$fpl$d2f))
<BR><BR>[Called By]<UL><LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[10ad568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[11b2618]"></a>_d2f</STRONG> (ARM, 168 bytes, Stack size 0 bytes, d2f.o(x$fpl$d2f), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127de2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>

<P><STRONG><a name="[11b26dc]"></a>__fpl_inf_d2f</STRONG> (ARM, 0 bytes, Stack size unknown bytes, d2f.o(x$fpl$d2f), UNUSED)

<P><STRONG><a name="[11b1b88]"></a>__aeabi_dadd</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dadd))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_dadd</UL>
<BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[1279f74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
</UL>

<P><STRONG><a name="[11b1b14]"></a>_dadd</STRONG> (ARM, 452 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b1e6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127e344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11b1c80]"></a>__fpl_inf_dadd</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)

<P><STRONG><a name="[127e344]"></a>__fpl_dcheck_NaN2</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dcheck.o(x$fpl$dcheck), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12889f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[11aee94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dmul
<LI><a href="#[11b0724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv
<LI><a href="#[11b1960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[11b1b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd
<LI><a href="#[127d98c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[127de2c]"></a>__fpl_dcheck_NaN1</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dcheck1.o(x$fpl$dcheck1))
<BR><BR>[Calls]<UL><LI><a href="#[12889f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[11b2618]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2f
<LI><a href="#[127b45c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;scalbn
<LI><a href="#[12890a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsqrt
</UL>

<P><STRONG><a name="[127d98c]"></a>__fpl_dcmp_InfNaN</STRONG> (ARM, 128 bytes, Stack size 4 bytes, dcmpin.o(x$fpl$dcmpinfnan), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127e344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
<LI><a href="#[12884f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[126bc38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drcmple
<LI><a href="#[126c1ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dcmple
</UL>

<P><STRONG><a name="[127d894]"></a>__fpl_inf_dcmp</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dcmpin.o(x$fpl$dcmpinfnan), UNUSED)

<P><STRONG><a name="[127c448]"></a>__fpl_fcmp_InfNaN</STRONG> (ARM, 100 bytes, Stack size 0 bytes, fcmpin.o(x$fpl$dcmpinfnan), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127cd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
<LI><a href="#[12884f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[126aacc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_frcmple
<LI><a href="#[126b064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fcmple
<LI><a href="#[126b5f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fcmpeq
</UL>

<P><STRONG><a name="[127c3cc]"></a>__fpl_inf_fcmp</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fcmpin.o(x$fpl$dcmpinfnan), UNUSED)

<P><STRONG><a name="[11b0798]"></a>__aeabi_ddiv</STRONG> (ARM, 0 bytes, Stack size 16 bytes, ddiv.o(x$fpl$ddiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_ddiv</UL>
<BR>[Called By]<UL><LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11b0724]"></a>_ddiv</STRONG> (ARM, 464 bytes, Stack size 16 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b06a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ddiv_mantissas
<LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127e344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11b085c]"></a>__fpl_inf_ddiv</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ddiv.o(x$fpl$ddiv), UNUSED)

<P><STRONG><a name="[11b06a8]"></a>_ddiv_mantissas</STRONG> (ARM, 608 bytes, Stack size 28 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b0724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv
</UL>

<P><STRONG><a name="[11af734]"></a>__aeabi_i2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dflt))
<BR><BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11af6c0]"></a>_dflt</STRONG> (ARM, 88 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dflt), UNUSED)

<P><STRONG><a name="[11af870]"></a>__dflt_normalise</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dflt_noclz.o(x$fpl$dflt), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11af7ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dfltu
</UL>

<P><STRONG><a name="[11af820]"></a>__aeabi_ui2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dfltu))
<BR><BR>[Called By]<UL><LI><a href="#[10f47a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[10f4824]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
</UL>

<P><STRONG><a name="[11af7ac]"></a>_dfltu</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dfltu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11af870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__dflt_normalise
</UL>

<P><STRONG><a name="[126c260]"></a>__aeabi_cdcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dleqf.o(x$fpl$dleqf))
<BR><BR>[Called By]<UL><LI><a href="#[ff9324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[ffc618]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[ffd274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[10f47a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[10f4824]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
<LI><a href="#[12796dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[126c1ec]"></a>_dcmple</STRONG> (ARM, 132 bytes, Stack size 0 bytes, dleqf.o(x$fpl$dleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[127d98c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[11aef08]"></a>__aeabi_dmul</STRONG> (ARM, 0 bytes, Stack size 16 bytes, dmul.o(x$fpl$dmul))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_dmul</UL>
<BR>[Called By]<UL><LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[1279f74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
</UL>

<P><STRONG><a name="[11aee94]"></a>_dmul</STRONG> (ARM, 460 bytes, Stack size 16 bytes, dmul.o(x$fpl$dmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127e344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11aef58]"></a>__fpl_inf_dmul</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dmul.o(x$fpl$dmul), UNUSED)

<P><STRONG><a name="[126bcb0]"></a>__aeabi_cdrcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, drleqf.o(x$fpl$drleqf))
<BR><BR>[Called By]<UL><LI><a href="#[ff9324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[ffd274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[10f47a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[10f4824]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
<LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[126bc38]"></a>_drcmple</STRONG> (ARM, 156 bytes, Stack size 0 bytes, drleqf.o(x$fpl$drleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[127d98c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[11b1a98]"></a>__aeabi_drsub</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$drsb))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_drsub</UL>
<BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11b1a24]"></a>_drsb</STRONG> (ARM, 24 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$drsb), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b1e6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[11b2048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
</UL>

<P><STRONG><a name="[12890a8]"></a>_dsqrt</STRONG> (ARM, 384 bytes, Stack size 16 bytes, dsqrt.o(x$fpl$dsqrt))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _dsqrt</UL>
<BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127de2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>
<BR>[Called By]<UL><LI><a href="#[12796dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[12890f8]"></a>__fpl_inf_dsqrt</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dsqrt.o(x$fpl$dsqrt), UNUSED)

<P><STRONG><a name="[11b19d4]"></a>__aeabi_dsub</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dsub))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_dsub</UL>
<BR>[Called By]<UL><LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11b1960]"></a>_dsub</STRONG> (ARM, 572 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2048]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
<LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127e344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11b1c04]"></a>__fpl_inf_dsub</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)

<P><STRONG><a name="[127d360]"></a>__dunder</STRONG> (ARM, 272 bytes, Stack size 4 bytes, dunder.o(x$fpl$dunder), UNUSED)

<P><STRONG><a name="[127d310]"></a>__dunder_d</STRONG> (ARM, 4 bytes, Stack size 0 bytes, dunder.o(x$fpl$dunder), UNUSED)

<P><STRONG><a name="[1271020]"></a>__aeabi_f2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, f2d.o(x$fpl$f2d))
<BR><BR>[Called By]<UL><LI><a href="#[ff9324]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[ff9884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_ (via Veneer)
<LI><a href="#[ff9900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_ (via Veneer)
<LI><a href="#[ff997c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_ (via Veneer)
<LI><a href="#[ff99f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_ (via Veneer)
<LI><a href="#[ff9a74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_ (via Veneer)
<LI><a href="#[ff9af0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_ (via Veneer)
<LI><a href="#[ff9b6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_ (via Veneer)
<LI><a href="#[ff9be8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_ (via Veneer)
<LI><a href="#[ffc618]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[ffd274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[102b780]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[10ad568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[1270fac]"></a>_f2d</STRONG> (ARM, 96 bytes, Stack size 0 bytes, f2d.o(x$fpl$f2d), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127c8b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[1271070]"></a>__fpl_inf_f2d</STRONG> (ARM, 0 bytes, Stack size unknown bytes, f2d.o(x$fpl$f2d), UNUSED)

<P><STRONG><a name="[1270608]"></a>__aeabi_fadd</STRONG> (ARM, 0 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fadd))
<BR><BR>[Called By]<UL><LI><a href="#[ff6568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume (via Veneer)
<LI><a href="#[ffdef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[1114b94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
</UL>

<P><STRONG><a name="[1270594]"></a>_fadd</STRONG> (ARM, 260 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1270848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fsub1
<LI><a href="#[127cd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[12706d4]"></a>__fpl_inf_fadd</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)

<P><STRONG><a name="[127cd48]"></a>__fpl_fcheck_NaN2</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fcheck.o(x$fpl$fcheck), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12889f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[126c8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fmul
<LI><a href="#[126f384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fdiv
<LI><a href="#[12703e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub
<LI><a href="#[1270594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd
<LI><a href="#[127c448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[127c8b4]"></a>__fpl_fcheck_NaN1</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fcheck1.o(x$fpl$fcheck1), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[12889f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[126dc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffixu
<LI><a href="#[126e79c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffix
<LI><a href="#[1270fac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_f2d
</UL>

<P><STRONG><a name="[126f3f8]"></a>__aeabi_fdiv</STRONG> (ARM, 0 bytes, Stack size 4 bytes, fdiv.o(x$fpl$fdiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __aeabi_fdiv</UL>
<BR>[Called By]<UL><LI><a href="#[ff72f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ffdef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[102b300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[102b588]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ (via Veneer)
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[102dba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[10ad568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[126f384]"></a>_fdiv</STRONG> (ARM, 476 bytes, Stack size 4 bytes, fdiv.o(x$fpl$fdiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127cd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[126f4bc]"></a>__fpl_inf_fdiv</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fdiv.o(x$fpl$fdiv), UNUSED)

<P><STRONG><a name="[126b664]"></a>__aeabi_cfcmpeq</STRONG> (ARM, 0 bytes, Stack size 0 bytes, feqf.o(x$fpl$feqf))
<BR><BR>[Called By]<UL><LI><a href="#[ff72f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
</UL>

<P><STRONG><a name="[126b5f0]"></a>_fcmpeq</STRONG> (ARM, 116 bytes, Stack size 0 bytes, feqf.o(x$fpl$feqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[127c448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[126e810]"></a>__aeabi_f2iz</STRONG> (ARM, 0 bytes, Stack size 0 bytes, ffix.o(x$fpl$ffix))
<BR><BR>[Called By]<UL><LI><a href="#[ff72f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ffcc38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V (via Veneer)
<LI><a href="#[ffd46c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM (via Veneer)
<LI><a href="#[102b300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
</UL>

<P><STRONG><a name="[126e79c]"></a>_ffix</STRONG> (ARM, 112 bytes, Stack size 0 bytes, ffix.o(x$fpl$ffix), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127c8b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[126e8e0]"></a>__fpl_inf_ffix</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ffix.o(x$fpl$ffix), UNUSED)

<P><STRONG><a name="[126dcd4]"></a>__aeabi_f2uiz</STRONG> (ARM, 0 bytes, Stack size 0 bytes, ffixu.o(x$fpl$ffixu))
<BR><BR>[Called By]<UL><LI><a href="#[ff8154]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD (via Veneer)
<LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[ff8430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS (via Veneer)
<LI><a href="#[ff84ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS (via Veneer)
<LI><a href="#[ff861c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP (via Veneer)
<LI><a href="#[ff8698]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP (via Veneer)
<LI><a href="#[ff8710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP (via Veneer)
<LI><a href="#[ff878c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP (via Veneer)
<LI><a href="#[ff8804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT (via Veneer)
<LI><a href="#[ff8880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT (via Veneer)
<LI><a href="#[ff88f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT (via Veneer)
<LI><a href="#[ff8974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT (via Veneer)
<LI><a href="#[ffa614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX (via Veneer)
<LI><a href="#[ffa68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL (via Veneer)
<LI><a href="#[ffa708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL (via Veneer)
<LI><a href="#[ffa784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR (via Veneer)
<LI><a href="#[ffa800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR (via Veneer)
<LI><a href="#[ffa87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR (via Veneer)
<LI><a href="#[ffa8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC (via Veneer)
<LI><a href="#[ffa974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL (via Veneer)
<LI><a href="#[ffadc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs (via Veneer)
<LI><a href="#[ffae3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL (via Veneer)
<LI><a href="#[ffaeb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR (via Veneer)
<LI><a href="#[ffaf34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL (via Veneer)
<LI><a href="#[ffafb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR (via Veneer)
<LI><a href="#[ffb02c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR (via Veneer)
<LI><a href="#[ffb0a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC (via Veneer)
<LI><a href="#[ffb11c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL (via Veneer)
<LI><a href="#[ffb9b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX (via Veneer)
<LI><a href="#[ffba2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL (via Veneer)
<LI><a href="#[ffbaa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR (via Veneer)
<LI><a href="#[ffbb24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL (via Veneer)
<LI><a href="#[ffbba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR (via Veneer)
<LI><a href="#[ffbc1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR (via Veneer)
<LI><a href="#[ffbc98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC (via Veneer)
<LI><a href="#[ffbd14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL (via Veneer)
<LI><a href="#[ffbe10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid (via Veneer)
<LI><a href="#[ffc258]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs (via Veneer)
<LI><a href="#[ffc2d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL (via Veneer)
<LI><a href="#[ffc348]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR (via Veneer)
<LI><a href="#[ffc3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL (via Veneer)
<LI><a href="#[ffc438]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR (via Veneer)
<LI><a href="#[ffc4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR (via Veneer)
<LI><a href="#[ffc528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC (via Veneer)
<LI><a href="#[ffc5a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL (via Veneer)
<LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase (via Veneer)
<LI><a href="#[102dba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[10ad568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[1114b94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[111f980]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
<LI><a href="#[111f9f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q (via Veneer)
<LI><a href="#[111fa70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC (via Veneer)
<LI><a href="#[1171fb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value (via Veneer)
</UL>

<P><STRONG><a name="[126dc60]"></a>_ffixu</STRONG> (ARM, 92 bytes, Stack size 0 bytes, ffixu.o(x$fpl$ffixu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127c8b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[126dda4]"></a>__fpl_inf_ffixu</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ffixu.o(x$fpl$ffixu), UNUSED)

<P><STRONG><a name="[126d18c]"></a>__aeabi_i2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$fflt))
<BR><BR>[Called By]<UL><LI><a href="#[be4e80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup (via Veneer)
<LI><a href="#[ff1a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume (via Veneer)
<LI><a href="#[ff2028]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel (via Veneer)
<LI><a href="#[ff72f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[ff73e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig (via Veneer)
<LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ffdef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[102b090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value (via Veneer)
<LI><a href="#[102b300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[102b404]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume (via Veneer)
<LI><a href="#[104843c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect (via Veneer)
<LI><a href="#[1048914]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource (via Veneer)
<LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage (via Veneer)
<LI><a href="#[111f514]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config (via Veneer)
</UL>

<P><STRONG><a name="[126d118]"></a>_fflt</STRONG> (ARM, 92 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$fflt), UNUSED)

<P><STRONG><a name="[126d2a0]"></a>__fflt_normalise</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fflt_noclz.o(x$fpl$fflt), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[126d1dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffltu
</UL>

<P><STRONG><a name="[126d250]"></a>__aeabi_ui2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$ffltu))
<BR><BR>[Called By]<UL><LI><a href="#[ffa614]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX (via Veneer)
<LI><a href="#[ffa68c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL (via Veneer)
<LI><a href="#[ffa708]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL (via Veneer)
<LI><a href="#[ffa784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR (via Veneer)
<LI><a href="#[ffa800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR (via Veneer)
<LI><a href="#[ffa87c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR (via Veneer)
<LI><a href="#[ffa8f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC (via Veneer)
<LI><a href="#[ffa974]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL (via Veneer)
<LI><a href="#[ffb9b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX (via Veneer)
<LI><a href="#[ffba2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL (via Veneer)
<LI><a href="#[ffbaa8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR (via Veneer)
<LI><a href="#[ffbb24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL (via Veneer)
<LI><a href="#[ffbba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR (via Veneer)
<LI><a href="#[ffbc1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR (via Veneer)
<LI><a href="#[ffbc98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC (via Veneer)
<LI><a href="#[ffbd14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL (via Veneer)
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[102dba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[106db04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
</UL>

<P><STRONG><a name="[126d1dc]"></a>_ffltu</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$ffltu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[126d2a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fflt_normalise
</UL>

<P><STRONG><a name="[126b0d8]"></a>__aeabi_cfcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fleqf.o(x$fpl$fleqf))
<BR><BR>[Called By]<UL><LI><a href="#[ff72f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[102b900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
</UL>

<P><STRONG><a name="[126b064]"></a>_fcmple</STRONG> (ARM, 116 bytes, Stack size 0 bytes, fleqf.o(x$fpl$fleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[127c448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[126c960]"></a>__aeabi_fmul</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fmul.o(x$fpl$fmul))
<BR><BR>[Called By]<UL><LI><a href="#[ff72f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[ff833c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[ff83b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[ff8804]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT (via Veneer)
<LI><a href="#[ff8880]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT (via Veneer)
<LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ffdef8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[102b300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[10ad568]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[1114b94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[111f980]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
<LI><a href="#[111f9f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q (via Veneer)
<LI><a href="#[111fa70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC (via Veneer)
<LI><a href="#[1171fb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value (via Veneer)
</UL>

<P><STRONG><a name="[126c8ec]"></a>_fmul</STRONG> (ARM, 260 bytes, Stack size 0 bytes, fmul.o(x$fpl$fmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127cd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[126c9b0]"></a>__fpl_inf_fmul</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fmul.o(x$fpl$fmul), UNUSED)

<P><STRONG><a name="[127bee4]"></a>__fpl_normalise2</STRONG> (ARM, 148 bytes, Stack size 0 bytes, fnorm2_noclz.o(x$fpl$fnorm2), UNUSED)

<P><STRONG><a name="[1283e14]"></a>_fp_init</STRONG> (ARM, 24 bytes, Stack size 8 bytes, fpinit.o(x$fpl$fpinit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _fp_init</UL>
<BR>[Calls]<UL><LI><a href="#[12825a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_fp_status_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[1283d08]"></a>__fplib_config_pureend_doubles</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[126ab44]"></a>__aeabi_cfrcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, frleqf.o(x$fpl$frleqf))
<BR><BR>[Called By]<UL><LI><a href="#[ff92a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ffc618]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[102b700]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[102b800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[111f980]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
</UL>

<P><STRONG><a name="[126aacc]"></a>_frcmple</STRONG> (ARM, 128 bytes, Stack size 0 bytes, frleqf.o(x$fpl$frleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[127c448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[1270454]"></a>__aeabi_fsub</STRONG> (ARM, 0 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fsub))
<BR><BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase (via Veneer)
<LI><a href="#[102dba8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
</UL>

<P><STRONG><a name="[12703e0]"></a>_fsub</STRONG> (ARM, 356 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1270a24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fadd1
<LI><a href="#[127cd48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[1270658]"></a>__fpl_inf_fsub</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)

<P><STRONG><a name="[127b9e8]"></a>__funder</STRONG> (ARM, 140 bytes, Stack size 0 bytes, funder.o(x$fpl$funder), UNUSED)

<P><STRONG><a name="[127b998]"></a>__funder_d</STRONG> (ARM, 4 bytes, Stack size 0 bytes, funder.o(x$fpl$funder), UNUSED)

<P><STRONG><a name="[1288044]"></a>__ieee_status</STRONG> (ARM, 8 bytes, Stack size 0 bytes, istatus.o(x$fpl$ieeestatus))
<BR><BR>[Called By]<UL><LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[126a598]"></a>_printf_fp_dec</STRONG> (ARM, 4 bytes, Stack size 0 bytes, printf1.o(x$fpl$printf1))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1280a80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (via Veneer)
</UL>

<P><STRONG><a name="[127acdc]"></a>_printf_fp_hex</STRONG> (ARM, 4 bytes, Stack size 0 bytes, printf2.o(x$fpl$printf2))
<BR><BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (via Veneer)
</UL>

<P><STRONG><a name="[12889f4]"></a>__fpl_return_NaN</STRONG> (ARM, 116 bytes, Stack size 0 bytes, retnan.o(x$fpl$retnan))
<BR><BR>[Calls]<UL><LI><a href="#[12884f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[127c8b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
<LI><a href="#[127cd48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
<LI><a href="#[127de2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
<LI><a href="#[127e344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[127b200]"></a>__ARM_scalbn</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[127b27c]"></a>scalbln</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[127b2f0]"></a>scalblnl</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[127b45c]"></a>scalbn</STRONG> (ARM, 108 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn))
<BR><BR>[Calls]<UL><LI><a href="#[11b2758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[127de2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>
<BR>[Called By]<UL><LI><a href="#[1268e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[1287734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__support_dtoi
</UL>

<P><STRONG><a name="[127b368]"></a>scalbnl</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[127b3dc]"></a>__fpl_inf_scalbn</STRONG> (ARM, 0 bytes, Stack size unknown bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[12884f8]"></a>__fpl_cmpreturn</STRONG> (ARM, 60 bytes, Stack size 0 bytes, trapv.o(x$fpl$trapveneer))
<BR><BR>[Called By]<UL><LI><a href="#[127c448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
<LI><a href="#[127d98c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
<LI><a href="#[12889f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>

<P><STRONG><a name="[b46c84]"></a>Undef_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[b46c84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[b46c84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[b46c0c]"></a>SWI_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[b46c0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SWI_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[b46c0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SWI_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[b46b90]"></a>PAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[b46b90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[b46b90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[b46b14]"></a>DAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[b46b14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[b46b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[b46a9c]"></a>IRQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[b46a9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[b46a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[b46a24]"></a>FIQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[b46a24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[b46a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[bf1ff4]"></a>panel_convert_key_value</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, key_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[bf1f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[bf1f7c]"></a>read_key</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bf0a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read165
<LI><a href="#[bf0cf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HeadphoneDetect
<LI><a href="#[bf1ff4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;panel_convert_key_value
</UL>
<BR>[Called By]<UL><LI><a href="#[bf1e04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[bf1f00]"></a>proc_key_press</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = proc_key_press -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bf0b84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[bf1e04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[bf1e84]"></a>proc_key_hold</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = proc_key_hold -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bf0b84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[bf1e04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[bf1e04]"></a>GetPanelKeyThread</STRONG> (Thumb, 94 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = GetPanelKeyThread -> read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[bf1e84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;proc_key_hold
<LI><a href="#[bf1f00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;proc_key_press
<LI><a href="#[bf1f7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>
<BR>[Called By]<UL><LI><a href="#[bf0bfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;key_task
</UL>

<P><STRONG><a name="[100a704]"></a>IsMsgQueueEmpty</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, message.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b40364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage
</UL>

<P><STRONG><a name="[100a688]"></a>IsMsgQueueFull</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1009ed4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage
<LI><a href="#[1009f4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage
</UL>

<P><STRONG><a name="[104afe0]"></a>Zone1ProcessKey</STRONG> (Thumb, 1238 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff17d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff5f0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[ff5f8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[ff6174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[ff6478]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[ff6758]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6b34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff6ca4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[ff7374]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[ff7464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[1047308]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[1047754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[1047be4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[1047d6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey
<LI><a href="#[1047de4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[1047e60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[1047edc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[1047f58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[1047fd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[1048050]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[10480cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[1048148]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[10481c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[10483c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[10485ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[1048628]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[1048b10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[1061188]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[106d040]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[106d91c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106cfc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[103612c]"></a>Zone2ProcessKey</STRONG> (Thumb, 768 bytes, Stack size 16 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = Zone2ProcessKey -> Zone2RadioMode -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[ff5ca0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[ff5d1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[ff6004]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[ff63fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[ff68bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[ff6a34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[ff6b34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[ff6bac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[ff6c24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[ff7010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[ff708c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[ff7184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[ff77cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[1034f44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1064590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[102dba8]"></a>GetCrossoverPoint</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GetCrossoverPoint -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[126d250]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[126dcd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[126f3f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1270454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fsub (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102b484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[101b6a8]"></a>get_freq</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1064610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[101b53c]"></a>PreProcDigitKey</STRONG> (Thumb, 144 bytes, Stack size 4 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = PreProcDigitKey</UL>
<BR>[Calls]<UL><LI><a href="#[126a0d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[101b4c4]"></a>SaveExit</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SaveExit -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[ff6938]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[1018ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[10186b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[101b44c]"></a>SaveInit</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = SaveInit -> UpdateSaveVfd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[10188b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[1018ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[10185b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[10e295c]"></a>i2c_ack</STRONG> (Thumb, 286 bytes, Stack size 24 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[1269c48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[10d32f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[10e23a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[10e27f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
</UL>

<P><STRONG><a name="[10e28e4]"></a>i2c_start</STRONG> (Thumb, 102 bytes, Stack size 8 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = i2c_start</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[10d3274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[10d32f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[10e23a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[10e2424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
</UL>

<P><STRONG><a name="[10e286c]"></a>i2c_stop</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = i2c_stop</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[10d3274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[10d32f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[10e23a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[10e2424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
</UL>

<P><STRONG><a name="[10e27f0]"></a>i2c_writebyte</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10e295c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[10d3274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[10d32f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[10e23a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[10e2424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
</UL>

<P><STRONG><a name="[10e2774]"></a>i2c_readbyte</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = i2c_readbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[1269b7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[1269c48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[10d32f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[10e23a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
</UL>

<P><STRONG><a name="[10fc110]"></a>Iec4094Sendbyte</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10fb500]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetData4094
<LI><a href="#[10fb668]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094Clk
</UL>
<BR>[Called By]<UL><LI><a href="#[10fbbe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>

<P><STRONG><a name="[111520c]"></a>Mas9116WriteWord</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[ff1948]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10ec820]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10ec988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[1114a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[1114b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[10c954c]"></a>CheckInputChannel</STRONG> (Thumb, 386 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1018530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[1047c60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[1047ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[10c85c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
<LI><a href="#[10c86c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelectChannel
<LI><a href="#[10d33e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
</UL>
<BR>[Called By]<UL><LI><a href="#[1046fa0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[1047b6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[10c84c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSelectInputChannel
</UL>

<P><STRONG><a name="[10b59b0]"></a>Write_Byte</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Write_Byte</UL>
<BR>[Calls]<UL><LI><a href="#[10f541c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_MOSI
<LI><a href="#[10f5498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
</UL>
<BR>[Called By]<UL><LI><a href="#[10b508c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10b5108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10b5938]"></a>ReadByteDsp</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10f53a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Sense_Spi_MISO
<LI><a href="#[10f5498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[10f5604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>
<BR>[Called By]<UL><LI><a href="#[10b508c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>

<P><STRONG><a name="[11b6570]"></a>__arm_div4</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b61c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[11b64f8]"></a>__arm_div8</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b61c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[11b647c]"></a>__arm_div_large</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11b61c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[11b2048]"></a>_dadd1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b1960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[11b1a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drsb
</UL>

<P><STRONG><a name="[11b1e6c]"></a>_dsub1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b1a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drsb
<LI><a href="#[11b1b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd
</UL>

<P><STRONG><a name="[1270a24]"></a>_fadd1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[12703e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub
</UL>

<P><STRONG><a name="[1270848]"></a>_fsub1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1270594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd
</UL>

<P><STRONG><a name="[1280c40]"></a>_fp_digits</STRONG> (Thumb, 492 bytes, Stack size 96 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[1274450]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul (via Veneer)
<LI><a href="#[12744a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv (via Veneer)
<LI><a href="#[12744f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e (via Veneer)
<LI><a href="#[12753e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_etento
<LI><a href="#[1275a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10 (via Veneer)
<LI><a href="#[1287734]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__support_dtoi (via Veneer)
<LI><a href="#[1288044]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ieee_status (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1280ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>

<P><STRONG><a name="[1280bc8]"></a>_fp_addexp</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _fp_addexp</UL>
<BR>[Calls]<UL><LI><a href="#[11b6294]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[1263c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[1280ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>

<P><STRONG><a name="[128b380]"></a>__ARM_exceptions_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1263c44]"></a>__ARM_stackcheck</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1263d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__set_errno (Weak Reference)
<LI><a href="#[1263d94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__read_errno (Weak Reference)
<LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
<LI><a href="#[12753e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (Weak Reference)
<LI><a href="#[1280a80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real (Weak Reference)
<LI><a href="#[1280ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (Weak Reference)
<LI><a href="#[1280bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp (Weak Reference)
<LI><a href="#[1280c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (Weak Reference)
<LI><a href="#[1281180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (Weak Reference)
<LI><a href="#[128b47c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
<LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
<LI><a href="#[128eb94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
<LI><a href="#[128f17c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (Weak Reference)
<LI><a href="#[128fae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb (Weak Reference)
</UL>

<P><STRONG><a name="[128b304]"></a>__Heap_DescSize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128b284]"></a>__alloca_initialize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128b1fc]"></a>__cpp_initialize__aeabi_</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128b180]"></a>__cxa_finalize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b47c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>

<P><STRONG><a name="[11b2758]"></a>__fpl_infinity</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[11aee94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dmul (Weak Reference)
<LI><a href="#[11b0724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv (Weak Reference)
<LI><a href="#[11b1960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub (Weak Reference)
<LI><a href="#[11b1b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd (Weak Reference)
<LI><a href="#[11b2618]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2f (Weak Reference)
<LI><a href="#[126c8ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fmul (Weak Reference)
<LI><a href="#[126dc60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffixu (Weak Reference)
<LI><a href="#[126e79c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffix (Weak Reference)
<LI><a href="#[126f384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fdiv (Weak Reference)
<LI><a href="#[12703e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub (Weak Reference)
<LI><a href="#[1270594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd (Weak Reference)
<LI><a href="#[1270fac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_f2d (Weak Reference)
<LI><a href="#[127b45c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;scalbn (Weak Reference)
<LI><a href="#[127c448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN (Weak Reference)
<LI><a href="#[127d98c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN (Weak Reference)
<LI><a href="#[12890a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsqrt (Weak Reference)
</UL>

<P><STRONG><a name="[11b3618]"></a>__user_heap_extend</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED, UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[11b3434]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[128b104]"></a>_atexit_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128eac4]"></a>_call_atexit_fns</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128eb94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
</UL>

<P><STRONG><a name="[128b08c]"></a>_clock_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128b010]"></a>_fp_trap_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128af94]"></a>_get_lc_collate</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128ae98]"></a>_get_lc_monetary</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128ae1c]"></a>_get_lc_time</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128ada0]"></a>_getenv_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128ad28]"></a>_init_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128aca8]"></a>_init_user_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128ac34]"></a>_initio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[127183c]"></a>_printf_mbtowc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
</UL>

<P><STRONG><a name="[12717c4]"></a>_printf_wc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[12718b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
</UL>

<P><STRONG><a name="[128abbc]"></a>_rand_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128ab40]"></a>_signal_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b4cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[128aabc]"></a>_terminate_user_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b47c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>

<P><STRONG><a name="[128aa40]"></a>_terminateio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[128b47c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>
<HR></body></html>
