<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html><head>
<title>Static Call Graph - [.\obj\C11_Audio_Newhdmi1.4.axf]</title></head>
<body><HR>
<H1>Static Call Graph for image .\obj\C11_Audio_Newhdmi1.4.axf</H1><HR>
<BR><P>#&#060CALLGRAPH&#062# ARM Linker, RVCT3.0 [Build 951]: Last Updated: Thu Sep 09 18:15:54 2010
<BR><P>
<H3>Maximum Stack Usage =        820 bytes + Unknown(Functions without stacksize,Cycles,Untraceable Function Pointers)</H3><H3>
Call chain for Maximum Stack Depth:</H3>
ASProcSetBalance -> GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq<P>
<H3>
Functions with no stack information
</H3><UL>
 <LI><a href="#[a66664]">Reset_Handler</a>
 <LI><a href="#[10ee5d8]">__scatterload</a>
 <LI><a href="#[10ee508]">__scatterload_rt2</a>
 <LI><a href="#[10ee558]">__scatterload_null</a>
 <LI><a href="#[10eed34]">__decompress</a>
 <LI><a href="#[10eece4]">__decompress1</a>
 <LI><a href="#[10ee028]">__scatterload_zeroinit</a>
 <LI><a href="#[a664e4]">__user_initial_stackheap</a>
 <LI><a href="#[103bfb4]">_memcpy_lastbytes</a>
 <LI><a href="#[103b9bc]">_memcpy_lastbytes_aligned</a>
 <LI><a href="#[11714e8]">__ARM_call_via_r0</a>
 <LI><a href="#[1171538]">__call_via_r0</a>
 <LI><a href="#[117141c]">__ARM_call_via_r1</a>
 <LI><a href="#[117146c]">__call_via_r1</a>
 <LI><a href="#[119116c]">__ARM_call_via_r2</a>
 <LI><a href="#[11713a0]">__call_via_r2</a>
 <LI><a href="#[11910a0]">__ARM_call_via_r3</a>
 <LI><a href="#[11910f0]">__call_via_r3</a>
 <LI><a href="#[1190fa4]">__ARM_call_via_r4</a>
 <LI><a href="#[1191024]">__call_via_r4</a>
 <LI><a href="#[1190ea8]">__ARM_call_via_r5</a>
 <LI><a href="#[1190f28]">__call_via_r5</a>
 <LI><a href="#[1190dac]">__ARM_call_via_r6</a>
 <LI><a href="#[1190e2c]">__call_via_r6</a>
 <LI><a href="#[1190cb0]">__ARM_call_via_r7</a>
 <LI><a href="#[1190d30]">__call_via_r7</a>
 <LI><a href="#[11867e0]">_memset</a>
 <LI><a href="#[1195fc4]">_memset_w</a>
 <LI><a href="#[117c954]">__fpl_inf_d2f</a>
 <LI><a href="#[117bef8]">__fpl_inf_dadd</a>
 <LI><a href="#[1185164]">__fpl_inf_dcmp</a>
 <LI><a href="#[1183c9c]">__fpl_inf_fcmp</a>
 <LI><a href="#[117aad4]">__fpl_inf_ddiv</a>
 <LI><a href="#[1179ae8]">__dflt_normalise</a>
 <LI><a href="#[11791d0]">__fpl_inf_dmul</a>
 <LI><a href="#[11b0920]">__fpl_inf_dsqrt</a>
 <LI><a href="#[117be7c]">__fpl_inf_dsub</a>
 <LI><a href="#[1178910]">__fpl_inf_f2d</a>
 <LI><a href="#[1177f74]">__fpl_inf_fadd</a>
 <LI><a href="#[1176d5c]">__fpl_inf_fdiv</a>
 <LI><a href="#[1176180]">__fpl_inf_ffix</a>
 <LI><a href="#[1175644]">__fpl_inf_ffixu</a>
 <LI><a href="#[1174b40]">__fflt_normalise</a>
 <LI><a href="#[1174250]">__fpl_inf_fmul</a>
 <LI><a href="#[11ab530]">__fplib_config_pureend_doubles</a>
 <LI><a href="#[1177ef8]">__fpl_inf_fsub</a>
 <LI><a href="#[1182cac]">__fpl_inf_scalbn</a>
 <LI><a href="#[a66c54]">Undef_Handler</a>
 <LI><a href="#[a66bdc]">SWI_Handler</a>
 <LI><a href="#[a66b60]">PAbt_Handler</a>
 <LI><a href="#[a66ae4]">DAbt_Handler</a>
 <LI><a href="#[a66a6c]">IRQ_Handler</a>
 <LI><a href="#[a669f4]">FIQ_Handler</a>
 <LI><a href="#[11807e8]">__arm_div4</a>
 <LI><a href="#[1180770]">__arm_div8</a>
 <LI><a href="#[11806f4]">__arm_div_large</a>
 <LI><a href="#[117c2c0]">_dadd1</a>
 <LI><a href="#[117c0e4]">_dsub1</a>
 <LI><a href="#[11782c4]">_fadd1</a>
 <LI><a href="#[11780e8]">_fsub1</a>
</UL>
<P>
<H3>
Mutually Recursive functions
</H3><UL>
 <LI><a href="#[1035984]">DSP_CFG_VIRTUALIZER</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1035a04]">DSP_CFG_PPM_Mode</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1035a84]">DSP_CFG_PPM</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1035afc]">DSP_CFG_MATRIX</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1035b78]">DSP_CFG_DECODER</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[1035bf4]">DSP_BOOT</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[10c9ee8]">DSP_CFG_MCLK_FACTOR</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[10c9fec]">DSP_CFG_AUDIO_SRC</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[10915e0]">DspSpiWriteNByte</a><BR>
 <LI><a href="#[a66c54]">Undef_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66c54]">Undef_Handler</a><BR>
 <LI><a href="#[a66bdc]">SWI_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66bdc]">SWI_Handler</a><BR>
 <LI><a href="#[a66b60]">PAbt_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66b60]">PAbt_Handler</a><BR>
 <LI><a href="#[a66ae4]">DAbt_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66ae4]">DAbt_Handler</a><BR>
 <LI><a href="#[a66a6c]">IRQ_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a66a6c]">IRQ_Handler</a><BR>
 <LI><a href="#[a669f4]">FIQ_Handler</a>&nbsp;&nbsp;&nbsp;->&nbsp;&nbsp;&nbsp;<a href="#[a669f4]">FIQ_Handler</a><BR>
</UL>
<BR>
<P><STRONG><a name="[a66664]"></a>Reset_Handler</STRONG> (ARM, 0 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[117d07c]"></a>__main</STRONG> (ARM, 8 bytes, Stack size 0 bytes, __main.o(!!!main))
<BR><BR>[Stack]<UL><LI>Max Depth = 68 + Unknown Stack Size
<LI>Call Chain = __main -> __rt_entry -> __rt_lib_init -> _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[10ee5d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__scatterload
<LI><a href="#[118deb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[10ee5d8]"></a>__scatterload</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter))
<BR><BR>[Called By]<UL><LI><a href="#[117d07c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[10ee508]"></a>__scatterload_rt2</STRONG> (ARM, 48 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[118deb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[10ee558]"></a>__scatterload_null</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __scatter.o(!!!scatter), UNUSED)

<P><STRONG><a name="[10eed34]"></a>__decompress</STRONG> (ARM, 92 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[10eece4]"></a>__decompress1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, __dczerorl2.o(!!dczerorl2), UNUSED)

<P><STRONG><a name="[10ee028]"></a>__scatterload_zeroinit</STRONG> (ARM, 44 bytes, Stack size unknown bytes, __scatter_zi.o(!!handler_zi), UNUSED)

<P><STRONG><a name="[1192e94]"></a>__ARM_argv_veneer</STRONG> (ARM, 16 bytes, Stack size 0 bytes, lib_init.o(.emb_text))
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[a664e4]"></a>__user_initial_stackheap</STRONG> (ARM, 0 bytes, Stack size unknown bytes, lpc2300.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[118d530]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[a60578]"></a>Systeminit</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = Systeminit -> HardwareInit -> SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[a60130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[a60408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[b42448]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UartInit
<LI><a href="#[b4253c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Timer0Init
<LI><a href="#[b4281c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitRemoteRepeatKey
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[a604fc]"></a>ProcDimerOff</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = ProcDimerOff -> VfdSetDimerValue -> VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b42350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fb5f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[a60488]"></a>main</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, main.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = main -> Timer0_Handler -> RadioDisplay -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a600b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMsgQueue
<LI><a href="#[a601ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[a60228]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetMessage
<LI><a href="#[a602a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[a6031c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[a60578]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Systeminit
<LI><a href="#[b42350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[b423d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
<LI><a href="#[b424c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[b425b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[b42630]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[b426a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[b42720]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[b427a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LedStandby
<LI><a href="#[11714e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Address Reference Count : 1]<UL><LI> kernel.o(.text)
</UL>
<P><STRONG><a name="[f1e52c]"></a>debug_printf</STRONG> (Thumb, 62 bytes, Stack size 160 bytes, debug.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = debug_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[103d32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f1e4b0]"></a>rs232_printf</STRONG> (Thumb, 62 bytes, Stack size 160 bytes, debug.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[103d32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[a60390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[b0fd6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[b103a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTT_
<LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[b11864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ1VFD_
<LI><a href="#[b118e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[b11964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_
<LI><a href="#[b119e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_
<LI><a href="#[b11a5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_
<LI><a href="#[b11ad8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_
<LI><a href="#[b11b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_
<LI><a href="#[b11bd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_
<LI><a href="#[b11c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_
<LI><a href="#[b11cc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_
<LI><a href="#[b11d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[b11dc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[b11e3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[b11eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[b14bac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ2VFD_
<LI><a href="#[b14c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2_
<LI><a href="#[b14d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[b14e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[b154d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1DF_
<LI><a href="#[b1554c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[b155c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EU
<LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b156b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[b157b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ES
<LI><a href="#[b15828]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EE
<LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[b1599c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ED
<LI><a href="#[b15a14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1D
<LI><a href="#[b15a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1C
<LI><a href="#[b15b04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1A_
<LI><a href="#[b15bf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[b15d60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[f1a3bc]"></a>InitQueue</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, queue.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[101038c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
<LI><a href="#[10104fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>

<P><STRONG><a name="[f1a340]"></a>IsQueueEmpty</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[f1a0e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
<LI><a href="#[f1a1dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[fffb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[fffbc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[f1a2c8]"></a>IsQueueFull</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f1a0e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
<LI><a href="#[f1a168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InQueue
</UL>

<P><STRONG><a name="[f1a250]"></a>QueueFront</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, queue.o(.text), UNUSED)

<P><STRONG><a name="[f1a1dc]"></a>DeQueue</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = DeQueue -> IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[f1a340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[fffb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[fffbc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[f1a168]"></a>InQueue</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, queue.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f1a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1010484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Isr (via Veneer)
<LI><a href="#[10105f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Isr (via Veneer)
</UL>

<P><STRONG><a name="[f1a0e8]"></a>GetQueueElementNum</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1a2c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull
<LI><a href="#[f1a340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
</UL>
<BR>[Called By]<UL><LI><a href="#[f1a064]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementRemain
</UL>

<P><STRONG><a name="[f1a064]"></a>GetQueueElementRemain</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f1a0e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetQueueElementNum
</UL>

<P><STRONG><a name="[f19fe8]"></a>GetQueueElement</STRONG> (Thumb, 48 bytes, Stack size 40 bytes, queue.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[f16860]"></a>SetDspPower</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 84<LI>Call Chain = SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f16410]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[10915e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1098100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[f167e8]"></a>SetDspDelay</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f16504]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay
</UL>
<BR>[Called By]<UL><LI><a href="#[fbb85c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>

<P><STRONG><a name="[f1676c]"></a>SetDspCorner</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f16580]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner
</UL>
<BR>[Called By]<UL><LI><a href="#[f22248]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
</UL>

<P><STRONG><a name="[f166f0]"></a>SetDspSpkMode</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384<LI>Call Chain = SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f16318]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcSpkMode
</UL>
<BR>[Called By]<UL><LI><a href="#[b13274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[b132ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[b13364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[b133e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[b1345c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[b134d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[b13554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[b135cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[b13f70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[b13fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[b14060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[b140dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[b14158]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[b141d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[b14248]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[b142c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
<LI><a href="#[f222c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>

<P><STRONG><a name="[f16674]"></a>SetDspSignal</STRONG> (Thumb, 26 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f16394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[fbb7d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceTestSignal
</UL>

<P><STRONG><a name="[f165fc]"></a>SetDspIrc</STRONG> (Thumb, 22 bytes, Stack size 16 bytes, c11_msg_handler.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = SetDspIrc -> DspProcIrc -> InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f1648c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[f2da68]"></a>HeadphoneDetect</STRONG> (Thumb, 154 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f2d8f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[f2ecec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[f2d9e4]"></a>GetEncoderSwitchThread</STRONG> (Thumb, 378 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetEncoderSwitchThread</UL>
<BR>[Calls]<UL><LI><a href="#[f2d7ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseEncoderSwitchPlus
<LI><a href="#[f2d870]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseEncoderSwitchMinus
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[f2d96c]"></a>key_task</STRONG> (Thumb, 168 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 96<LI>Call Chain = key_task -> GetPanelKeyThread -> read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f2d8f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
<LI><a href="#[f2eb74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[a600b4]"></a>InitMsgQueue</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, message.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b2210c]"></a>PostMessage</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, message.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b22848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[b22094]"></a>SendMessage</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e99c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ea18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ea94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0eb14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b0eb98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[b0ec14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0ec8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[b0ed04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0ed84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[f2d8f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
<LI><a href="#[fb5e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[fd16c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetSoftMute
<LI><a href="#[fd1740]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDspChannel
<LI><a href="#[fd17c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[fd1844]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[fd18c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[ff3528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[1000138]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSavePreset
<LI><a href="#[10001bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MsgTextDisplay
</UL>

<P><STRONG><a name="[a60228]"></a>GetMessage</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetMessage</UL>
<BR>[Calls]<UL><LI><a href="#[b228c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueEmpty
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b15fd8]"></a>GetProtocolFloatValue</STRONG> (Thumb, 180 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36<LI>Call Chain = GetProtocolFloatValue -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1177ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b10234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[b106fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[b10778]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[b107f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[b1086c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[b108e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[b10960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[b109d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[b10a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[b10fa4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[b11020]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[b1109c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[b11118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[b11194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[b11210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[b1128c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[b11308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[b12314]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[b12390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[b1240c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[b12488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[b12504]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[b12580]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[b125fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[b12678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[b126f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[b1276c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[b127e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[b12864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[b128e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[b1295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[b129d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[b12a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[b12ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[b12b4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[b12bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[b12c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[b12cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[b12d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[b12db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[b12e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[b12ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[b12f1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[b12f98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[b13014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[b13090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[b1310c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[b13184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[b131fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[b13a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[b13b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[b13b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[b13c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[b13c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[b13cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[b13d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[b13df4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
<LI><a href="#[b14338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[b143b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[b14428]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[b144a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[b14518]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[b14590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[b14608]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[b14680]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
<LI><a href="#[b14774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[b147ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[b14864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[b148dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[b14954]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b149cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b14a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b14abc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b14d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b14f74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b14ff0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b1506c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b150e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b15164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b151e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b1525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b152d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
<LI><a href="#[b1554c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
</UL>

<P><STRONG><a name="[b15f54]"></a>IsProtocolStringValid</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b10140]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
<LI><a href="#[b14b34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
</UL>

<P><STRONG><a name="[b15edc]"></a>ProcCmdSPU</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15e58]"></a>GetCurrentDecodeStatus</STRONG> (Thumb, 68 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b15d60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[b15dd8]"></a>GetPcmDecodeMode</STRONG> (Thumb, 126 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetPcmDecodeMode</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b155c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EU
<LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b15d60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1_
</UL>

<P><STRONG><a name="[b15d60]"></a>ProcCmdZ1_</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b15dd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[b15e58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurrentDecodeStatus
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15ce4]"></a>GetZone1Channel</STRONG> (Thumb, 158 bytes, Stack size 8 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetZone1Channel</UL>
<BR>[Calls]<UL><LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
</UL>

<P><STRONG><a name="[b15c6c]"></a>ProcCmdZ1S</STRONG> (Thumb, 272 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1S -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0e8b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[b15ce4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15bf4]"></a>ProcCmdZ1P</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1P -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ec14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0effc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1PowerOn
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15b7c]"></a>ProcCmdZ1M</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ProcCmdZ1M -> MsgSetMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15b04]"></a>ProcCmdZ1A_</STRONG> (Thumb, 118 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1A_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15a8c]"></a>ProcCmdZ1C</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1C -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15a14]"></a>ProcCmdZ1D</STRONG> (Thumb, 102 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1D -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1599c]"></a>ProcCmdZ1ED</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ED -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15918]"></a>GetDolby2ChDecodeMode</STRONG> (Thumb, 108 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
</UL>

<P><STRONG><a name="[b158a0]"></a>ProcCmdZ1EF</STRONG> (Thumb, 244 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EF -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[b0f7b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b15918]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDolby2ChDecodeMode
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15828]"></a>ProcCmdZ1EE</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EE -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b157b0]"></a>ProcCmdZ1ES</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ES -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1572c]"></a>GetDolby5ChDecodeMode</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b156b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
</UL>

<P><STRONG><a name="[b156b4]"></a>ProcCmdZ1EX</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EX -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f7b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[b1572c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetDolby5ChDecodeMode
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1563c]"></a>ProcCmdZ1E</STRONG> (Thumb, 388 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1E -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[b0f6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b15dd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b155c4]"></a>ProcCmdZ1EU</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EU -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b15dd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1554c]"></a>ProcCmdZ1VM</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VM -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ef7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11760b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b154d0]"></a>ProcCmdZ1DF_</STRONG> (Thumb, 234 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1DF_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15454]"></a>ProtocolSetEq</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b12314]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[b12390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[b1240c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[b12488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[b12504]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[b12580]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[b125fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[b12678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[b14f74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b14ff0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b1506c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b150e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b15164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b151e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b1525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b152d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
</UL>

<P><STRONG><a name="[b153d0]"></a>IsProtocolEqBandValid</STRONG> (Thumb, 58 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsProtocolEqBandValid</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b12314]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[b12390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[b1240c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[b12488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[b12504]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[b12580]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[b125fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[b12678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[b14f74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b14ff0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b1506c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b150e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b15164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b151e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b1525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b152d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
</UL>

<P><STRONG><a name="[b15354]"></a>IsBalanceValid</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsBalanceValid</UL>
<BR>[Calls]<UL><LI><a href="#[1173550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[1173b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b12314]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSW
<LI><a href="#[b12390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSL
<LI><a href="#[b1240c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSL
<LI><a href="#[b12488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQBSR
<LI><a href="#[b12504]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQSR
<LI><a href="#[b12580]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQR
<LI><a href="#[b125fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQC
<LI><a href="#[b12678]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMZ1EQL
<LI><a href="#[b12ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[b12b4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[b12bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[b12c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[b12cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[b12d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[b12db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[b12e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[b14774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[b147ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[b14864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[b148dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[b14954]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b149cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b14a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b14abc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b14f74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSW
<LI><a href="#[b14ff0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSL
<LI><a href="#[b1506c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSL
<LI><a href="#[b150e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQBSR
<LI><a href="#[b15164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQSR
<LI><a href="#[b151e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQR
<LI><a href="#[b1525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQC
<LI><a href="#[b152d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQL
</UL>

<P><STRONG><a name="[b152d8]"></a>ProcCmdZ1EQL</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1525c]"></a>ProcCmdZ1EQC</STRONG> (Thumb, 160 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQC -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b151e0]"></a>ProcCmdZ1EQR</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b15164]"></a>ProcCmdZ1EQSR</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b150e8]"></a>ProcCmdZ1EQBSR</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQBSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1506c]"></a>ProcCmdZ1EQBSL</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQBSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14ff0]"></a>ProcCmdZ1EQSL</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14f74]"></a>ProcCmdZ1EQSW</STRONG> (Thumb, 88 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQSW -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14efc]"></a>ProcCmdZ1EQ</STRONG> (Thumb, 148 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EQ -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0f454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqOn
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14e84]"></a>ProcCmdZ2P</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2P -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ec14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0ef00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14e08]"></a>GetZone2Channel</STRONG> (Thumb, 108 bytes, Stack size 4 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetZone2Channel</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
</UL>

<P><STRONG><a name="[b14d90]"></a>ProcCmdZ2S</STRONG> (Thumb, 608 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2S -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0ddfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[b14e08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetZone2Channel
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14d18]"></a>ProcCmdZ2V</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2V -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ef7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11760b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14ca0]"></a>ProcCmdZ2M</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ProcCmdZ2M -> MsgSetMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14c28]"></a>ProcCmdZ2_</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ2_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14bac]"></a>ProCmdZ2VFD_</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProCmdZ2VFD_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14b34]"></a>ProcCmdRSN</STRONG> (Thumb, 128 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdRSN -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0df74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[b15f54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolStringValid
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14abc]"></a>ProcCmdSLL</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14a44]"></a>ProcCmdSLC</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b149cc]"></a>ProcCmdSLR</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14954]"></a>ProcCmdSLSR</STRONG> (Thumb, 126 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b148dc]"></a>ProcCmdSLSL</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14864]"></a>ProcCmdSLBR</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLBR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b147ec]"></a>ProcCmdSLBL</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLBL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14774]"></a>ProcCmdSLSW</STRONG> (Thumb, 70 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdSLSW -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b146f8]"></a>IsDistanceValid</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsDistanceValid</UL>
<BR>[Calls]<UL><LI><a href="#[11723e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[1173b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b10234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[b12ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[b12f1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[b12f98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[b13014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[b13090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[b1310c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[b13184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[b131fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[b14338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[b143b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[b14428]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[b144a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[b14518]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[b14590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[b14608]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[b14680]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
</UL>

<P><STRONG><a name="[b14680]"></a>ProcCmdSPL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14608]"></a>ProcCmdSPC</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPC -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14590]"></a>ProcCmdSPR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14518]"></a>ProcCmdSPSR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPSR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b144a0]"></a>ProcCmdSPSL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPSL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14428]"></a>ProcCmdSPBR</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPBR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b143b0]"></a>ProcCmdSPBL</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPBL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14338]"></a>ProcCmdSPs</STRONG> (Thumb, 94 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdSPs -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b142c0]"></a>ProcCmdSZL</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14248]"></a>ProcCmdSZR</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b141d0]"></a>ProcCmdSZSL</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14158]"></a>ProcCmdSZSR</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b140dc]"></a>ProcCmdSZSBL</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSBL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b14060]"></a>ProcCmdSZSBR</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZSBR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13fe8]"></a>ProcCmdSZC</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZC -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13f70]"></a>ProcCmdSZS</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZS -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13ef0]"></a>IsCrossoverValid</STRONG> (Thumb, 110 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = IsCrossoverValid</UL>
<BR>[Calls]<UL><LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b126f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[b1276c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[b127e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[b12864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[b128e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[b1295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[b129d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[b12a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[b13a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[b13b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[b13b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[b13c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[b13c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[b13cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[b13d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[b13df4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>

<P><STRONG><a name="[b13e70]"></a>GetCrossoverPoint</STRONG> (Thumb, 116 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b126f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[b1276c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[b127e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[b12864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[b128e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[b1295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[b129d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[b12a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[b13a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[b13b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[b13b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[b13c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[b13c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[b13cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[b13d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[b13df4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
</UL>

<P><STRONG><a name="[b13df4]"></a>ProcCmdSZXFL</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13d78]"></a>ProcCmdSZXFC</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFC -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13cfc]"></a>ProcCmdSZXFR</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXFR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13c80]"></a>ProcCmdSZXSR</STRONG> (Thumb, 120 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13c04]"></a>ProcCmdSZXSL</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13b88]"></a>ProcCmdSZXSBR</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSBR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13b0c]"></a>ProcCmdSZXSBL</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZXSBL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13a94]"></a>ProcCmdSZX</STRONG> (Thumb, 114 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdSZX -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13a18]"></a>ProcCmdZ1LPS</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 392 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1LPS -> ChangeListenProfileMode -> SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b0fb00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b139a0]"></a>ProcCmdSSPL</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13928]"></a>ProcCmdSSPC</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPC -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b138b0]"></a>ProcCmdSSPR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13834]"></a>ProcCmdSSPSR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b137b8]"></a>ProcCmdSSPSL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1373c]"></a>ProcCmdSSPSBR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSBR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b136c0]"></a>ProcCmdSSPSBL</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSBL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13644]"></a>ProcCmdSSPSW</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdSSPSW -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b135cc]"></a>ProcCmdMSZL</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13554]"></a>ProcCmdMSZR</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b134d8]"></a>ProcCmdMSZSL</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1345c]"></a>ProcCmdMSZSR</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b133e0]"></a>ProcCmdMSZSBL</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSBL -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13364]"></a>ProcCmdMSZSBR</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZSBR -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b132ec]"></a>ProcCmdMSZC</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZC -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13274]"></a>ProcCmdMSZS</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 416 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZS -> SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b131fc]"></a>ProcCmdMSPL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13184]"></a>ProcCmdMSPC</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPC -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1310c]"></a>ProcCmdMSPR</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13090]"></a>ProcCmdMSPSR</STRONG> (Thumb, 102 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPSR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b13014]"></a>ProcCmdMSPSL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPSL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12f98]"></a>ProcCmdMSPBR</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPBR -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12f1c]"></a>ProcCmdMSPBL</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPBL -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12ea4]"></a>ProcCmdMSPs</STRONG> (Thumb, 92 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 236 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSPs -> SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12e2c]"></a>ProcCmdMSLL</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12db4]"></a>ProcCmdMSLC</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12d3c]"></a>ProcCmdMSLR</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12cc0]"></a>ProcCmdMSLSR</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12c44]"></a>ProcCmdMSLSL</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12bc8]"></a>ProcCmdMSLBR</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLBR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12b4c]"></a>ProcCmdMSLBL</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLBL -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12ad0]"></a>ProcCmdMSLSW</STRONG> (Thumb, 72 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSLSW -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12a54]"></a>ProcCmdMSZXFL</STRONG> (Thumb, 126 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b129d8]"></a>ProcCmdMSZXFC</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFC -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1295c]"></a>ProcCmdMSZXFR</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXFR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b128e0]"></a>ProcCmdMSZXSR</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12864]"></a>ProcCmdMSZXSBR</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSBR -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b127e8]"></a>ProcCmdMSZXSBL</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSBL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1276c]"></a>ProcCmdMSZXSL</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZXSL -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b126f4]"></a>ProcCmdMSZX</STRONG> (Thumb, 112 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 424 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSZX -> SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b13e70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[b13ef0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12678]"></a>ProcCmdMZ1EQL</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b125fc]"></a>ProcCmdMZ1EQC</STRONG> (Thumb, 84 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQC -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12580]"></a>ProcCmdMZ1EQR</STRONG> (Thumb, 90 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12504]"></a>ProcCmdMZ1EQSR</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12488]"></a>ProcCmdMZ1EQBSR</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQBSR -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1240c]"></a>ProcCmdMZ1EQBSL</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQBSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12390]"></a>ProcCmdMZ1EQSL</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSL -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12314]"></a>ProcCmdMZ1EQSW</STRONG> (Thumb, 86 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 224 + Unknown Stack Size
<LI>Call Chain = ProcCmdMZ1EQSW -> ProtocolSetEq -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b15354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid
<LI><a href="#[b153d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid
<LI><a href="#[b15454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12298]"></a>ProcCmdMSSPL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1221c]"></a>ProcCmdMSSPC</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPC -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b121a0]"></a>ProcCmdMSSPR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b12124]"></a>ProcCmdMSSPSR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b120a8]"></a>ProcCmdMSSPSL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1202c]"></a>ProcCmdMSSPSBR</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSBR -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11fb0]"></a>ProcCmdMSSPSBL</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSBL -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11f34]"></a>ProcCmdMSSPSW</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdMSSPSW -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11eb8]"></a>ProcCmdZ1EMDIM</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMDIM -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11e3c]"></a>ProcCmdZ1EMP</STRONG> (Thumb, 90 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMP -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11dc0]"></a>ProcCmdZ1EMC</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMC -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11d44]"></a>ProcCmdZ1EMDEL</STRONG> (Thumb, 312 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1EMDEL -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0fa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11cc8]"></a>ProcCmdZ1VFL_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VFL_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11c4c]"></a>ProcCmdZ1VFR_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VFR_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11bd0]"></a>ProcCmdZ1VC_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VC_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11b54]"></a>ProcCmdZ1VSL_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VSL_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11ad8]"></a>ProcCmdZ1VSR_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VSR_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11a5c]"></a>ProcCmdZ1VBL_</STRONG> (Thumb, 246 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VBL_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b119e0]"></a>ProcCmdZ1VBR_</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VBR_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11964]"></a>ProcCmdZ1VS_</STRONG> (Thumb, 80 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 672 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1VS_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b118e0]"></a>Rs232UpdateStreamType</STRONG> (Thumb, 2200 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = Rs232UpdateStreamType -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b11864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProCmdZ1VFD_
</UL>

<P><STRONG><a name="[b11864]"></a>ProCmdZ1VFD_</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProCmdZ1VFD_ -> Rs232UpdateStreamType -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b118e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b117e8]"></a>ProcCmdZ1IN1</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1176c]"></a>ProcCmdZ1IN2</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b116f0]"></a>ProcCmdZ1IN3</STRONG> (Thumb, 648 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11674]"></a>ProcCmdZ1IN4</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b115f8]"></a>ProcCmdZ1IN5</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1157c]"></a>ProcCmdZ1IN6</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11500]"></a>ProcCmdZ1IN7</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11484]"></a>ProcCmdZ1IN8</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1IN8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11404]"></a>IsAnalogLevelValid</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = IsAnalogLevelValid</UL>
<BR>[Calls]<UL><LI><a href="#[1173550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[1173b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b10fa4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[b11020]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[b1109c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[b11118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[b11194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[b11210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[b1128c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[b11308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
</UL>

<P><STRONG><a name="[b11384]"></a>FindLevelPosition</STRONG> (Thumb, 140 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = FindLevelPosition -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[11723e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[1172978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[1172f04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11760b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b10fa4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[b11020]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[b1109c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[b11118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[b11194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[b11210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[b1128c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[b11308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
</UL>

<P><STRONG><a name="[b11308]"></a>ProcCmdZ1SAL1</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1128c]"></a>ProcCmdZ1SAL2</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11210]"></a>ProcCmdZ1SAL3</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11194]"></a>ProcCmdZ1SAL4</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11118]"></a>ProcCmdZ1SAL5</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1109c]"></a>ProcCmdZ1SAL6</STRONG> (Thumb, 106 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b11020]"></a>ProcCmdZ1SAL7</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10fa4]"></a>ProcCmdZ1SAL8</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1SAL8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b11384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition
<LI><a href="#[b11404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10f28]"></a>ProcCmdZ1ACN1</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10eac]"></a>ProcCmdZ1ACN2</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN2 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10e30]"></a>ProcCmdZ1ACN3</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN3 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10db4]"></a>ProcCmdZ1ACN4</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN4 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10d38]"></a>ProcCmdZ1ACN5</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN5 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10cbc]"></a>ProcCmdZ1ACN6</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN6 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10c40]"></a>ProcCmdZ1ACN7</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN7 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10bc4]"></a>ProcCmdZ1ACN8</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN8 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10b48]"></a>ProcCmdZ1ACN7_1</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACN7_1 -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10acc]"></a>ProcCmdZ1ACNR</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdZ1ACNR -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10a54]"></a>ProcCmdTAT</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0eb98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b109d8]"></a>ProcCmdTAHDT</STRONG> (Thumb, 144 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAHDT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0eb98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10960]"></a>ProcCmdTFT</STRONG> (Thumb, 152 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0eb98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b108e4]"></a>ProcCmdTFHDT</STRONG> (Thumb, 154 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFHDT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0eb98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioFreq
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1086c]"></a>ProcCmdTAP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b107f0]"></a>ProcCmdTAHDP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTAHDP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10778]"></a>ProcCmdTFP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b106fc]"></a>ProcCmdTFHDP</STRONG> (Thumb, 78 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = ProcCmdTFHDP -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10684]"></a>ProcCmdT</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = ProcCmdT -> MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10604]"></a>GetTunerPosition</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
</UL>

<P><STRONG><a name="[b1058c]"></a>ProcCmdTAS</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAS -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e744]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[b0ee84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b10604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10510]"></a>ProcCmdTAHDS</STRONG> (Thumb, 158 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDS -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e744]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[b0ee84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b10604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10498]"></a>ProcCmdTAF</STRONG> (Thumb, 212 bytes, Stack size 40 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAF -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e744]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[b0ee84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b10604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1041c]"></a>ProcCmdTAHDF</STRONG> (Thumb, 210 bytes, Stack size 40 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 688 + Unknown Stack Size
<LI>Call Chain = ProcCmdTAHDF -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e744]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[b0ee84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b10604]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTunerPosition
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b103a4]"></a>ProcCmdTT_</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 680 + Unknown Stack Size
<LI>Call Chain = ProcCmdTT_ -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b1032c]"></a>ProcCmdASSP</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASSP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b102b0]"></a>ProcCmdASHDMIAO</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdASHDMIAO -> SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e5cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10234]"></a>ProcCmdASAVD</STRONG> (Thumb, 82 bytes, Stack size 24 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcCmdASAVD -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0fa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[b146f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid
<LI><a href="#[b15fd8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b101bc]"></a>ProcCmdASFP</STRONG> (Thumb, 286 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASFP -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10140]"></a>ProcCmdASRSN</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = ProcCmdASRSN -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0df74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[b0e7c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[b15f54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsProtocolStringValid
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b100c4]"></a>ProcCmdASIRC</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIRC -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b10048]"></a>ProcCmdASIR2C</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIR2C -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0dd04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0ffcc]"></a>ProcCmdASIRM</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIRM -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0ff50]"></a>ProcCmdASIR2M</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASIR2M -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0fed8]"></a>ProcCmdASTO</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASTO -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0fe5c]"></a>ProcCmdASAIS</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASAIS -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0fde4]"></a>ProcCmdASDD</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = ProcCmdASDD -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0fd6c]"></a>ProcCmdASRD</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ProcCmdASRD -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rs232_protocol.o(.constdata)
</UL>
<P><STRONG><a name="[b0fcf8]"></a>StrCmp</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, rs232_protocol.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0fc7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
</UL>

<P><STRONG><a name="[b0fc7c]"></a>ProcRs232Msg</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = ProcRs232Msg</UL>
<BR>[Calls]<UL><LI><a href="#[b0fcf8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;StrCmp
<LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[a60390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
</UL>

<P><STRONG><a name="[a60390]"></a>C11Rs232</STRONG> (Thumb, 266 bytes, Stack size 8 bytes, rs232_protocol.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = C11Rs232 -> rs232_printf -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fc7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
<LI><a href="#[f1a1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[f1a340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[f1e438]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Send
<LI><a href="#[f1e4b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
</UL>
<BR>[Address Reference Count : 1]<UL><LI> main.o(.data)
</UL>
<P><STRONG><a name="[fbbc4c]"></a>SetSpeakerMode</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = SetSpeakerMode -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fbbbd0]"></a>SetDistanceMode</STRONG> (Thumb, 336 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = SetDistanceMode -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fbb358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fbbb54]"></a>SetBalanceMode</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = SetBalanceMode -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fbbad0]"></a>SetCrossoverPointsMode</STRONG> (Thumb, 364 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368 + Unknown Stack Size
<LI>Call Chain = SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbaf74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fbba58]"></a>Phase_Relay</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Phase_Relay</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
</UL>

<P><STRONG><a name="[b0e464]"></a>SetSpkPhase</STRONG> (Thumb, 358 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb25c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacInvert
<LI><a href="#[fbba58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b11f34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[b11fb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[b1202c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[b120a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[b12124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[b121a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[b1221c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[b12298]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[b13644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[b136c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[b1373c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[b137b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[b13834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[b138b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[b13928]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[b139a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[f21f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[fbb9d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[1020784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
</UL>

<P><STRONG><a name="[fbb9d8]"></a>SetSpeakerPhaseMode</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SetSpeakerPhaseMode -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
</UL>

<P><STRONG><a name="[fbb95c]"></a>SetPanoramaMode</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, setup_func.o(.text), UNUSED)

<P><STRONG><a name="[fbb8d8]"></a>SetPanoramaToDefault</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, setup_func.o(.text), UNUSED)

<P><STRONG><a name="[b0fb00]"></a>ChangeListenProfileMode</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 376 + Unknown Stack Size
<LI>Call Chain = ChangeListenProfileMode -> SetCrossoverPointsMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fbb2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[fbb9d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[fbbad0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[fbbb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[fbbbd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode
<LI><a href="#[fbbc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerMode
</UL>
<BR>[Called By]<UL><LI><a href="#[b13a18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1LPS
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[f22d7c]"></a>AssignedInputSetup</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AssignedInputSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f2214c]"></a>SpkDimensionSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkDimensionSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f21fd4]"></a>SpkPanoramaSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkPanoramaSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e354]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f21edc]"></a>SpkWidthSetup</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkWidthSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb85c]"></a>SetSpkDistance</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f167e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspDelay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f220cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[f221cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
</UL>

<P><STRONG><a name="[f221cc]"></a>SpkDelaySetup</STRONG> (Thumb, 108 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 212 + Unknown Stack Size
<LI>Call Chain = SpkDelaySetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb85c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f21f58]"></a>SpkPhaseSetup</STRONG> (Thumb, 156 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkPhaseSetup -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22054]"></a>SpkEqSetup</STRONG> (Thumb, 206 bytes, Stack size 32 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = SpkEqSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f4c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22248]"></a>SpkCrossoverSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 400 + Unknown Stack Size
<LI>Call Chain = SpkCrossoverSetup -> SetDspCorner -> DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f1676c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspCorner
</UL>
<BR>[Called By]<UL><LI><a href="#[b126f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX
<LI><a href="#[b1276c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL
<LI><a href="#[b127e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL
<LI><a href="#[b12864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR
<LI><a href="#[b128e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR
<LI><a href="#[b1295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR
<LI><a href="#[b129d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC
<LI><a href="#[b12a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL
<LI><a href="#[b13a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX
<LI><a href="#[b13b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL
<LI><a href="#[b13b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR
<LI><a href="#[b13c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL
<LI><a href="#[b13c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR
<LI><a href="#[b13cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR
<LI><a href="#[b13d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC
<LI><a href="#[b13df4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22c7c]"></a>AvSyncDelaySetup</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AvSyncDelaySetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0fa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22344]"></a>SpkBlanceTestMode</STRONG> (Thumb, 372 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = SpkBlanceTestMode -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f16674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fbb3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb7d8]"></a>SetBalanceTestSignal</STRONG> (Thumb, 46 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 188<LI>Call Chain = SetBalanceTestSignal -> SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f16674]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[fb64e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[f223c4]"></a>SpkBlanceSetup</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SpkBlanceSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 2]<UL><LI> menu_tbl.o(.data)
<LI> setup_menu.o(.text)
</UL>
<P><STRONG><a name="[f228ac]"></a>LateSetup</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = LateSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22734]"></a>PasswordModeSetup</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = PasswordModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f226b8]"></a>PasswordSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = PasswordSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22c04]"></a>BrightSetup</STRONG> (Thumb, 76 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = BrightSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22cfc]"></a>AutoInputSeekSetup</STRONG> (Thumb, 64 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AutoInputSeekSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f21790]"></a>Zone2InputSetup</STRONG> (Thumb, 340 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = Zone2InputSetup -> Zone2RadioMode -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0ddfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[b0ef00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fbac08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb75c]"></a>GetVolumeIndex</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, setup_func.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f21610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
</UL>

<P><STRONG><a name="[f21610]"></a>Zone2VolumeSetup</STRONG> (Thumb, 110 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = Zone2VolumeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbad78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[fbb75c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVolumeIndex
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22924]"></a>IrControlSetup</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = IrControlSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f21710]"></a>Zone2IrControlSetup</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = Zone2IrControlSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0dd04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f21690]"></a>Zone2IrModeSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = Zone2IrModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f2263c]"></a>RearIrModeSetup</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = RearIrModeSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f2188c]"></a>TriggerSetup</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = TriggerSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f225bc]"></a>RestoreDefaultSetup</STRONG> (Thumb, 106 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = RestoreDefaultSetup -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f222c8]"></a>SpkConfigSetup</STRONG> (Thumb, 138 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 400 + Unknown Stack Size
<LI>Call Chain = SpkConfigSetup -> SetDspSpkMode -> DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f166f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>
<BR>[Called By]<UL><LI><a href="#[b13274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZS
<LI><a href="#[b132ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZC
<LI><a href="#[b13364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBR
<LI><a href="#[b133e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSBL
<LI><a href="#[b1345c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSR
<LI><a href="#[b134d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZSL
<LI><a href="#[b13554]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZR
<LI><a href="#[b135cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZL
<LI><a href="#[b13f70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZS
<LI><a href="#[b13fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZC
<LI><a href="#[b14060]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBR
<LI><a href="#[b140dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSBL
<LI><a href="#[b14158]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSR
<LI><a href="#[b141d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZSL
<LI><a href="#[b14248]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZR
<LI><a href="#[b142c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZL
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f220cc]"></a>SpkDistanceSetup</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 212 + Unknown Stack Size
<LI>Call Chain = SpkDistanceSetup -> SetSpkDistance -> SetDspDelay -> DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb85c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance
</UL>
<BR>[Called By]<UL><LI><a href="#[b12ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs
<LI><a href="#[b12f1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL
<LI><a href="#[b12f98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR
<LI><a href="#[b13014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL
<LI><a href="#[b13090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR
<LI><a href="#[b1310c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR
<LI><a href="#[b13184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC
<LI><a href="#[b131fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL
<LI><a href="#[b14338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs
<LI><a href="#[b143b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL
<LI><a href="#[b14428]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR
<LI><a href="#[b144a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL
<LI><a href="#[b14518]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR
<LI><a href="#[b14590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR
<LI><a href="#[b14608]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC
<LI><a href="#[b14680]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb6dc]"></a>SetAnalogInLevel</STRONG> (Thumb, 50 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 72<LI>Call Chain = SetAnalogInLevel -> Set2ChVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f22dfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
</UL>

<P><STRONG><a name="[f22dfc]"></a>AnalogLevelSetup</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AnalogLevelSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb6dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb660]"></a>SetAnalogInMode</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, setup_func.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f22e7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
</UL>

<P><STRONG><a name="[f22e7c]"></a>AnalogInSetup</STRONG> (Thumb, 154 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = AnalogInSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInMode
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22a1c]"></a>HDMIInAudioSetup</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = HDMIInAudioSetup -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0e5cc]"></a>SetHdmiAudioOut</STRONG> (Thumb, 128 bytes, Stack size 8 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[fbb168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b102b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
<LI><a href="#[f22a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[f22b18]"></a>CDPureAudio</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = CDPureAudio -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22a9c]"></a>HDMIAUIDOOUT</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = HDMIAUIDOOUT -> SetHdmiAudioOut -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e5cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb5dc]"></a>SetMasterVolumeLevel</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = SetMasterVolumeLevel -> SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbae78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[f227b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
</UL>

<P><STRONG><a name="[f227b4]"></a>MasterVolumeLevel</STRONG> (Thumb, 102 bytes, Stack size 40 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256 + Unknown Stack Size
<LI>Call Chain = MasterVolumeLevel -> SetMasterVolumeLevel -> SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb5dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb558]"></a>SetZ2MasterVolumeLevel</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = SetZ2MasterVolumeLevel -> SetZ2MasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ef00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[fbad78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[fbadf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeValue
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f2180c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Z2MasterVolumeLevel
</UL>

<P><STRONG><a name="[f2180c]"></a>Z2MasterVolumeLevel</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = Z2MasterVolumeLevel -> SetZ2MasterVolumeLevel -> SetZ2MasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fbb4dc]"></a>MaxVolumeLevel</STRONG> (Thumb, 212 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = MaxVolumeLevel -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[f2253c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMaxVolumeLevel
</UL>

<P><STRONG><a name="[f2253c]"></a>SetMaxVolumeLevel</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = SetMaxVolumeLevel -> MaxVolumeLevel -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[b0e7c0]"></a>ReadName</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = ReadName -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b10140]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
<LI><a href="#[f22834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[f229a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
</UL>

<P><STRONG><a name="[b0df74]"></a>WriteName</STRONG> (Thumb, 74 bytes, Stack size 24 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b10140]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRSN
<LI><a href="#[b14b34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN
<LI><a href="#[f22834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[f229a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
</UL>

<P><STRONG><a name="[fbb464]"></a>ChanegName</STRONG> (Thumb, 94 bytes, Stack size 12 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = ChanegName</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f22834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup
<LI><a href="#[f229a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup
</UL>

<P><STRONG><a name="[f229a0]"></a>InputNameSetup</STRONG> (Thumb, 168 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = InputNameSetup -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0df74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[b0e7c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[fbb464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f22834]"></a>LogoSetup</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, setup_func.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = LogoSetup -> WriteName -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0df74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[b0e7c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[fbb464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChanegName
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[f761f8]"></a>ReadPwd</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = ReadPwd -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fb65e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[f76180]"></a>WritePwd</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
</UL>

<P><STRONG><a name="[f76100]"></a>read_curr_option</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = read_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[fb61f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[fb6a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
</UL>

<P><STRONG><a name="[f76080]"></a>write_curr_option</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = write_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
</UL>

<P><STRONG><a name="[f76000]"></a>execute_curr_option</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = execute_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[fb61f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[f75f80]"></a>load_default_option</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = load_default_option</UL>
<BR>[Calls]<UL><LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
</UL>

<P><STRONG><a name="[fb6abc]"></a>Inquire_restrict_option</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Inquire_restrict_option</UL>
<BR>[Calls]<UL><LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[fb6a3c]"></a>MenuLoadCurOption</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = MenuLoadCurOption -> read_curr_option</UL>
<BR>[Calls]<UL><LI><a href="#[f76100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[fb69c0]"></a>MenuFindPage</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, setup_menu.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f22440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[fb66d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[fb6944]"></a>MenuCaptionShow</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = MenuCaptionShow -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[fb68c8]"></a>MenuHeaderShow</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = MenuHeaderShow -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fb6754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[fb6848]"></a>VfdShowMenuOption</STRONG> (Thumb, 60 bytes, Stack size 48 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[103d32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
</UL>

<P><STRONG><a name="[fb67cc]"></a>MenuItemShow</STRONG> (Thumb, 1136 bytes, Stack size 80 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 720 + Unknown Stack Size
<LI>Call Chain = MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f76100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[fb6848]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[fb6944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
<LI><a href="#[fb6abc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[117aa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb6754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>

<P><STRONG><a name="[fb6754]"></a>MenuDisplay</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 736 + Unknown Stack Size
<LI>Call Chain = MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fb67cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[fb68c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
</UL>
<BR>[Called By]<UL><LI><a href="#[f22440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuDisplay
<LI><a href="#[fb5ffc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[fb66d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[f22440]"></a>SetupMenuDisplay</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = SetupMenuDisplay -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fb69c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuFindPage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb66d8]"></a>SetupMenuInit</STRONG> (Thumb, 90 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fb69c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuFindPage
</UL>
<BR>[Called By]<UL><LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[fb65e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[fb665c]"></a>VfdInitDispPwd</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = VfdInitDispPwd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb65e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
</UL>

<P><STRONG><a name="[fb65e4]"></a>SetupInit</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[f761f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadPwd
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fb665c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[fb66d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fb656c]"></a>SetupExit</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = SetupExit -> SpkBlanceTestMode -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f22344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fb5ef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
</UL>
<BR>[Called By]<UL><LI><a href="#[f224c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[fb64e8]"></a>SetupMenuProcBalance</STRONG> (Thumb, 220 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = SetupMenuProcBalance -> SetBalanceTestSignal -> SetDspSignal -> DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fbb3e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[fbb7d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceTestSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[fb646c]"></a>ProcSetupUpKey</STRONG> (Thumb, 312 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ProcSetupUpKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fb00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[fb5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[fb64e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fb6a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
<LI><a href="#[fb6abc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[fb63ec]"></a>ProcSetupDownKey</STRONG> (Thumb, 328 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ProcSetupDownKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0fb00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[fb5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[fb64e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fb6a3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption
<LI><a href="#[fb6abc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[fb636c]"></a>ProcSetupLeftKey</STRONG> (Thumb, 432 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = ProcSetupLeftKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f76080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f76100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[fb5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[fb62ec]"></a>ProcSetupRightKey</STRONG> (Thumb, 444 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = ProcSetupRightKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f76080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f76100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[fb5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[fb626c]"></a>ProcSetupEnterKey</STRONG> (Thumb, 282 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 744 + Unknown Stack Size
<LI>Call Chain = ProcSetupEnterKey -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[b0fb00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[f22344]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f76080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[fb5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
<LI><a href="#[fb5ef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[fb665c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[f224c0]"></a>SetupExitMenu</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = SetupExitMenu -> SetupExit -> SpkBlanceTestMode -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[fb656c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
<LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> menu_tbl.o(.data)
</UL>
<P><STRONG><a name="[fb61f0]"></a>SetupLoadEeprom</STRONG> (Thumb, 554 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetupLoadEeprom -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f76100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b42720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
</UL>

<P><STRONG><a name="[b0e254]"></a>SetupLoadDefault</STRONG> (Thumb, 238 bytes, Stack size 24 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[f75f80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;load_default_option
<LI><a href="#[f76000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f76080]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f76180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fd6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[b42720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f225bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fb6174]"></a>PwdKeyService</STRONG> (Thumb, 448 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = PwdKeyService -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f224c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[f76180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[fb665c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[fb66d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fb60f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>

<P><STRONG><a name="[fb60f8]"></a>SetupKeyService</STRONG> (Thumb, 356 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = SetupKeyService -> PwdKeyService -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f224c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[fb6174]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[fb626c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb62ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[fb63ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
<LI><a href="#[fb656c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>
<BR>[Called By]<UL><LI><a href="#[fb5f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[fb6078]"></a>SetupFlashHandler</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SetupFlashHandler -> MsgSetFlash -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[fb5e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetFlash
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[fb5ffc]"></a>UpdateVfdFlash</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 752 + Unknown Stack Size
<LI>Call Chain = UpdateVfdFlash -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fb5e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVfdbufferChar
<LI><a href="#[fb6754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fb5f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>

<P><STRONG><a name="[fb5f7c]"></a>SetupProcMessage</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, setup_menu.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = SetupProcMessage -> Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a604fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[b03f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[fb5ffc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[fb60f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupKeyService
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[b0f0f0]"></a>IsCurFocusTid</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f8d3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundProcMessage
<LI><a href="#[fd14d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[fdbd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[fb5d84]"></a>SetCurFocusTid</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0e8b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[fb656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[fb65e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[fd0098]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[fd062c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[ff34ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[b0f358]"></a>GetCurFocusTid</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[b15ce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel
<LI><a href="#[b42630]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[b426a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[f224c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[fb65e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[fd062c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[1098088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[1098100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[b426a8]"></a>ProcMessage</STRONG> (Thumb, 70 bytes, Stack size 16 bytes, task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = ProcMessage</UL>
<BR>[Calls]<UL><LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b423d0]"></a>VfdRefresh</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = VfdRefresh -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f89c54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f89dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
</UL>

<P><STRONG><a name="[fb5e78]"></a>GetVfdbufferChar</STRONG> (Thumb, 8 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fb5ffc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
</UL>

<P><STRONG><a name="[f89dc8]"></a>SetVfdOwner</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = SetVfdOwner -> VfdRefresh -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b423d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
</UL>

<P><STRONG><a name="[f89d4c]"></a>VfdTimerHandler</STRONG> (Thumb, 94 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f503ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[f89cd0]"></a>SetVfdDispMode</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, vfd_disp.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0e06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
</UL>

<P><STRONG><a name="[fbac88]"></a>VfdDisplay</STRONG> (Thumb, 114 bytes, Stack size 104 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f89c54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[103d32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[1181130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f225bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fb5ffc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateVfdFlash
<LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[fb665c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[fb6848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[fb68c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuHeaderShow
<LI><a href="#[fb6944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuCaptionShow
<LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[fd1264]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[fd13d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[fd1454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fd14d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[fd1558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[ff31c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
<LI><a href="#[ff32c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[ff3338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DisplayConnectHelp
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[fffcc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[fffebc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[b03f98]"></a>VfdDisplayBlank</STRONG> (Thumb, 100 bytes, Stack size 16 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f89c54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[103c3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0e8b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fb665c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdInitDispPwd
<LI><a href="#[fb6754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuDisplay
<LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[fd1264]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
<LI><a href="#[fd13d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[fd1454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fd1558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[ff34ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[fffebc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
</UL>

<P><STRONG><a name="[b0e06c]"></a>VfdTempDisp</STRONG> (Thumb, 114 bytes, Stack size 104 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 592 + Unknown Stack Size
<LI>Call Chain = VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[f89c54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[f89cd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdDispMode
<LI><a href="#[103d32c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;vsprintf
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
<LI><a href="#[1181130]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strncpy (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b14efc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fd1454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[b0dfec]"></a>VfdTempDispBlank</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, vfd_disp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = VfdTempDispBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f89c54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
<LI><a href="#[103c3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b14efc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fd1454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[b0ef7c]"></a>IsZone1VolumeValid</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b14d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b1554c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
</UL>

<P><STRONG><a name="[b0ec8c]"></a>MsgSetMute</STRONG> (Thumb, 40 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b14ca0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2M
<LI><a href="#[b15b7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1M
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[fd18c4]"></a>MsgSetStream</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetStream -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[106c008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[106c088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHRACfg
<LI><a href="#[106c108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[106c184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
<LI><a href="#[106c200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
<LI><a href="#[1098088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
</UL>

<P><STRONG><a name="[b0ed04]"></a>MsgSetInputSource</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetInputSource -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b10b48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[b10bc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[b10c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[b10cbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[b10d38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[b10db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[b10e30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[b10eac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[b10f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[b11484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[b11500]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[b1157c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[b115f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[b11674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[b116f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[b1176c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[b117e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[f22d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[f22e7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[ff34ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
</UL>

<P><STRONG><a name="[fd1844]"></a>MsgSetDSPSetting</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDSPSetting -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[b0f63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[fd0a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0a98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[fd0b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[fd0b90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[fd0c0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1036008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
<LI><a href="#[103610c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[fd17c0]"></a>MsgSetDSPHDMISetting</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDSPHDMISetting -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f503ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
<LI><a href="#[fd08a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
</UL>

<P><STRONG><a name="[fd1740]"></a>MsgSetDspChannel</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDspChannel -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[fd16c4]"></a>MsgSetSoftMute</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetSoftMute -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f503ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[b0ec14]"></a>MsgSetPower</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetPower -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b14e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[b15bf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
<LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[b0ea18]"></a>MsgSetVfdShow</STRONG> (Thumb, 36 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b106fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[b10778]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[b107f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[b1086c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b156b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[b42630]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioLoop
<LI><a href="#[f224c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExitMenu
<LI><a href="#[f503ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fd082c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[fd08a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[fd09a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[fd0a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0a98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[fd0c0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[fd15d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RefreshHandle
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[ff34ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[fffc4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TextDisplayExit
<LI><a href="#[10028d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveExit
</UL>

<P><STRONG><a name="[b0ed84]"></a>MsgSetDimer</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetDimer -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b101bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
<LI><a href="#[f22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[f2d8f4]"></a>MsgSetKey</STRONG> (Thumb, 62 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[f2d96c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;key_task
<LI><a href="#[f2da68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HeadphoneDetect
<LI><a href="#[f2ebf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;proc_key_hold
<LI><a href="#[f2ec70]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;proc_key_press
</UL>

<P><STRONG><a name="[b0e99c]"></a>MsgSetVolume</STRONG> (Thumb, 46 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetVolume -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[b14d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V
<LI><a href="#[b1554c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[fb5e00]"></a>MsgSetFlash</STRONG> (Thumb, 42 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetFlash -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[fb6078]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupFlashHandler
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[fb63ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupDownKey
<LI><a href="#[fb646c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupUpKey
</UL>

<P><STRONG><a name="[b0effc]"></a>IsZone1PowerOn</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b15bf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1P
</UL>

<P><STRONG><a name="[fd164c]"></a>SetRefresh</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fd14d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
</UL>

<P><STRONG><a name="[fd15d0]"></a>RefreshHandle</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RefreshHandle -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
</UL>
<BR>[Called By]<UL><LI><a href="#[f503ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;timer0_irq (via Veneer)
</UL>

<P><STRONG><a name="[fd1558]"></a>ShowVersion</STRONG> (Thumb, 88 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ShowVersion -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd14d4]"></a>VfdUpdateVolumeValue</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = VfdUpdateVolumeValue -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fd164c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRefresh
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[fd13d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
</UL>

<P><STRONG><a name="[fd1454]"></a>VfdUpdateStreamType</STRONG> (Thumb, 2954 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = VfdUpdateStreamType -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fd13d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
</UL>

<P><STRONG><a name="[fd13d8]"></a>VfdUpdateZone1</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = VfdUpdateZone1 -> VfdUpdateStreamType -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fd1454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fd14d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[b0f264]"></a>GetSrcName</STRONG> (Thumb, 82 bytes, Stack size 4 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = GetSrcName</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[fdbd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[fd135c]"></a>SelectSource</STRONG> (Thumb, 890 bytes, Stack size 24 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 240 + Unknown Stack Size
<LI>Call Chain = SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fcf8e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[fcfeb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[fd011c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[fd0394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelect71Channel
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[fd06a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[fd072c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
</UL>

<P><STRONG><a name="[fd12e0]"></a>ProcInputSelect</STRONG> (Thumb, 186 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256 + Unknown Stack Size
<LI>Call Chain = ProcInputSelect -> SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fd135c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[fd1264]"></a>PowerOnDisplay</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[fbae78]"></a>SetMasterVolumeValue</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SetMasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fbb5dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[fd11e0]"></a>GetVolumeEepromSetValue</STRONG> (Thumb, 32 bytes, Stack size 0 bytes, zone1_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[fd1164]"></a>SystemPowerOn</STRONG> (Thumb, 154 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b42350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fbae78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[fcf86c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[fcf96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[fcfa60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetResetPin
<LI><a href="#[fcfad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoPowerOn
<LI><a href="#[fcfdc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
<LI><a href="#[fcfe38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[fcff2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
<LI><a href="#[fcffa4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitCs8416
<LI><a href="#[fd001c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fd1264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerOnDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
</UL>

<P><STRONG><a name="[fd10e8]"></a>SystemPowerOff</STRONG> (Thumb, 86 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = SystemPowerOff -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b425b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fcf96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[fcfd40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[fcfdc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
</UL>

<P><STRONG><a name="[fd1070]"></a>Zone1Mute</STRONG> (Thumb, 52 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Zone1Mute</UL>
<BR>[Calls]<UL><LI><a href="#[fbb078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[fcfb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[fcfc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
</UL>

<P><STRONG><a name="[fd0ff4]"></a>SetAutoseekFlag</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetAutoseekFlag -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0f78]"></a>IsAutoSeekOn</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = IsAutoSeekOn -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[fd0efc]"></a>IsEverAutoseek</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = IsEverAutoseek -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[fd0e84]"></a>SeekSelect</STRONG> (Thumb, 178 bytes, Stack size 16 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SeekSelect -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e6c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fd072c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
</UL>

<P><STRONG><a name="[fd0e08]"></a>ProcAutoSeekSur</STRONG> (Thumb, 582 bytes, Stack size 32 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 624 + Unknown Stack Size
<LI>Call Chain = ProcAutoSeekSur -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ec14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fd05b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[fd0e84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0d88]"></a>ProcZone1PowerOn</STRONG> (Thumb, 172 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 632 + Unknown Stack Size
<LI>Call Chain = ProcZone1PowerOn -> ProcAutoSeekSur -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e5cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbb168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[fcf8e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[fcf9e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[fd0e08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd0efc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsEverAutoseek
<LI><a href="#[fd0f78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsAutoSeekOn
<LI><a href="#[fd0ff4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[fd1164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[fd0d08]"></a>ProcZone1PowerOff</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ProcZone1PowerOff -> SystemPowerOff -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fbb168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[fcf9e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[fd1070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[fd10e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[b42720]"></a>LoadSystemStartupValue</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = LoadSystemStartupValue -> SetupLoadDefault -> WritePwd -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fb61f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[fd0c88]"></a>Zone1ProcAutoSeek</STRONG> (Thumb, 454 bytes, Stack size 40 bytes, zone1_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ec14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fd05b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInput
<LI><a href="#[fd0e84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>

<P><STRONG><a name="[fd0c0c]"></a>PcmProcCesKey</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = PcmProcCesKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[b0f6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0b90]"></a>Ac3ProcCesKey</STRONG> (Thumb, 132 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = Ac3ProcCesKey -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f7b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0b14]"></a>DtsProcCesKey</STRONG> (Thumb, 126 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DtsProcCesKey -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0a98]"></a>PcmProcNeoKey</STRONG> (Thumb, 76 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = PcmProcNeoKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[b0f6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0a1c]"></a>PcmProcPliiKey</STRONG> (Thumb, 184 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = PcmProcPliiKey -> DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[b0f6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd09a0]"></a>PcmProcSurKey</STRONG> (Thumb, 248 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = PcmProcSurKey -> DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[b0f63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[fd041c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd0924]"></a>Ac3ProcPliiKey</STRONG> (Thumb, 318 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = Ac3ProcPliiKey -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f7b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd0210]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[fd17c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd08a8]"></a>DtsProcPliiKey</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DtsProcPliiKey -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd17c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd082c]"></a>Ac3ProcSurKey</STRONG> (Thumb, 222 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = Ac3ProcSurKey -> DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[fd04a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_MULTI
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fd07b4]"></a>IsHidenKey</STRONG> (Thumb, 172 bytes, Stack size 4 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = IsHidenKey</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[b03f50]"></a>Zone1ProcMessage</STRONG> (Thumb, 1246 bytes, Stack size 40 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 800 + Unknown Stack Size
<LI>Call Chain = Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a604fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ef7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1VolumeValid
<LI><a href="#[b0effc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone1PowerOn
<LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b42350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[f1e52c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f22c04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fbaf74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fd028c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[fd0310]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[fd0d08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0d88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd1070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[fd11e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetVolumeEepromSetValue
<LI><a href="#[fd12e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[fd13d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateZone1
<LI><a href="#[fd1454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fd14d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateVolumeValue
<LI><a href="#[fd3b28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fb5f7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupProcMessage
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[b0ef00]"></a>IsZone2PowerOn</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, zone2_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b14e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2P
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fbb558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[fdbeb0]"></a>IsZone2VolumeValid</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, zone2_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[fbadf4]"></a>SetZ2MasterVolumeValue</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetZ2MasterVolumeValue -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fbb558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
</UL>

<P><STRONG><a name="[fdbe30]"></a>ProcZone2PowerOn</STRONG> (Thumb, 132 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = ProcZone2PowerOn -> SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[b0f264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[fbac08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fbadf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeValue
<LI><a href="#[fcf9e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[fd1164]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[fdbdb0]"></a>ProcZone2PowerOff</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ProcZone2PowerOff -> SystemPowerOff -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[f89dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[fcf9e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[fd10e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[fdb750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[fdba48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[fdbd2c]"></a>Zone2ProcInputSelect</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = Zone2ProcInputSelect -> Zone2SelectChannel -> Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[b0f264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[fbac08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fdba48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[b0dd80]"></a>Zone2RadioMode</STRONG> (Thumb, 244 bytes, Stack size 8 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = Zone2RadioMode -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0ee84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fdb7c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[fdb850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[fdb8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[fdb950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[fdba48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[f8d2b0]"></a>Zone2ProcMessage</STRONG> (Thumb, 580 bytes, Stack size 32 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = Zone2ProcMessage -> ProcZone2PowerOn -> SystemPowerOn -> PowerOnDisplay -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a604fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ef00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[fbad78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
<LI><a href="#[fdb750]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
<LI><a href="#[fdbd2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[fdbdb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[fdbe30]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fdbeb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2VolumeValid
<LI><a href="#[fdce94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[ff3528]"></a>MsgSetIrc</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetIrc -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[fd062c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[ff31c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
</UL>

<P><STRONG><a name="[fd062c]"></a>AutoSoundInit</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = AutoSoundInit -> SoftMute -> Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[ff34ac]"></a>AutoSoundExit</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = AutoSoundExit -> VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fd06a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[ff31c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetupConfig
</UL>

<P><STRONG><a name="[ff3434]"></a>InitSpkPara</STRONG> (Thumb, 142 bytes, Stack size 0 bytes, auto_sound.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[ff33b8]"></a>IsAnySpkValid</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, auto_sound.o(.text), UNUSED)

<P><STRONG><a name="[ff3338]"></a>DisplayConnectHelp</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = DisplayConnectHelp -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[ff32c0]"></a>DisplayNA</STRONG> (Thumb, 54 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
</UL>

<P><STRONG><a name="[ff3244]"></a>GetIrc2EqValue</STRONG> (Thumb, 1022 bytes, Stack size 656 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 780<LI>Call Chain = GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff2a54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value
<LI><a href="#[ff2c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[1172978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[1172f04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[1177ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[117c904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
</UL>

<P><STRONG><a name="[ff31c4]"></a>ASProcSetupConfig</STRONG> (Thumb, 246 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = ASProcSetupConfig -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[ff3144]"></a>ASProcSpeakerCheck</STRONG> (Thumb, 922 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = ASProcSpeakerCheck -> DisplayConnectHelp -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a602a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f165fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fd06a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[fd072c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[ff2ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[ff2b58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSpkDistance
<LI><a href="#[ff2bd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[ff2c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[ff2d44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[ff3338]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayConnectHelp
<LI><a href="#[ff3434]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitSpkPara
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[11723e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[1179180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul (via Veneer)
<LI><a href="#[117c904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[ff30c4]"></a>ASProcSetDistance</STRONG> (Thumb, 532 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = ASProcSetDistance -> DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff32c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[103c89c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[117aa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv (via Veneer)
<LI><a href="#[117c904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[ff3044]"></a>ASProcSetBalance</STRONG> (Thumb, 1000 bytes, Stack size 40 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 820 + Unknown Stack Size
<LI>Call Chain = ASProcSetBalance -> GetIrc2EqValue -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[a602a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f165fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff2a54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value
<LI><a href="#[ff2ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[ff2c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[ff2cc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue
<LI><a href="#[ff3244]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
<LI><a href="#[ff32c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[103c89c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[11723e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[1172978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[1179180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul (via Veneer)
<LI><a href="#[117bc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dsub (via Veneer)
<LI><a href="#[117c904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[ff2fd0]"></a>sort</STRONG> (Thumb, 58 bytes, Stack size 4 bytes, auto_sound.o(.text), UNUSED)

<P><STRONG><a name="[ff2f48]"></a>ASProcSetCrossoverPoints</STRONG> (Thumb, 580 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = ASProcSetCrossoverPoints -> DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f165fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff2ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[ff32c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[ff2ecc]"></a>ASProcSetRoomEQ</STRONG> (Thumb, 834 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = ASProcSetRoomEQ -> DisplayNA -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f165fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff2ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[ff32c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[b0f3d4]"></a>FindBalancePosition</STRONG> (Thumb, 120 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = FindBalancePosition -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[1172978]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmple (via Veneer)
<LI><a href="#[1172f04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfcmpeq (via Veneer)
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11760b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b12ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[b12b4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[b12bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[b12c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[b12cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[b12d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[b12db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[b12e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[b14774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[b147ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[b14864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[b148dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[b14954]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b149cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b14a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b14abc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b15454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[ff2e4c]"></a>SPK_Phase_Display</STRONG> (Thumb, 112 bytes, Stack size 48 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 640 + Unknown Stack Size
<LI>Call Chain = SPK_Phase_Display -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[ff2dc8]"></a>ASProcSetSpeakerphase</STRONG> (Thumb, 2616 bytes, Stack size 24 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 664 + Unknown Stack Size
<LI>Call Chain = ASProcSetSpeakerphase -> SPK_Phase_Display -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f3d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f21f58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[f22054]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[f220cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[f22248]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[f222c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f223c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff2e4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[ff32c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisplayNA
<LI><a href="#[ff34ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[ff3528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetIrc
<LI><a href="#[ff54ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint
<LI><a href="#[103c89c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1177cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fsub (via Veneer)
<LI><a href="#[1180c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strlen
</UL>
<BR>[Address Reference Count : 1]<UL><LI> auto_sound.o(.data)
</UL>
<P><STRONG><a name="[f8d3b0]"></a>AutoSoundProcMessage</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = AutoSoundProcMessage</UL>
<BR>[Calls]<UL><LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[10002b4]"></a>SetRadioStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fffa44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
<LI><a href="#[1002860]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveInit
<LI><a href="#[10028d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveExit
</UL>

<P><STRONG><a name="[1000238]"></a>GetRadioStatus</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[b0f078]"></a>IsFreqValid</STRONG> (Thumb, 114 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[b108e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[b10960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[b109d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[b10a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[b0eb98]"></a>MsgSetRadioFreq</STRONG> (Thumb, 54 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetRadioFreq -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b108e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[b10960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[b109d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[b10a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
</UL>

<P><STRONG><a name="[b0ea94]"></a>MsgSetRadioSearch</STRONG> (Thumb, 38 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetRadioSearch -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b10684]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdT
<LI><a href="#[b108e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT
<LI><a href="#[b10960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT
<LI><a href="#[b109d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT
<LI><a href="#[b10a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[b0eb14]"></a>MsgSetRadioLoadPreset</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = MsgSetRadioLoadPreset -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b106fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP
<LI><a href="#[b10778]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP
<LI><a href="#[b107f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP
<LI><a href="#[b1086c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[10001bc]"></a>MsgTextDisplay</STRONG> (Thumb, 34 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = MsgTextDisplay -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[1000138]"></a>MsgSetRadioSavePreset</STRONG> (Thumb, 58 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = MsgSetRadioSavePreset -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b22094]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SendMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[fffac8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[b0e744]"></a>SaveFmPreset</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = SaveFmPreset -> EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[b0ee84]"></a>LoadRadioPreset</STRONG> (Thumb, 242 bytes, Stack size 24 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = LoadRadioPreset -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[10000b8]"></a>IsTunerIfCorrect</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, radio_task.o(.text), UNUSED)

<P><STRONG><a name="[1000038]"></a>ISValidTunerPostion</STRONG> (Thumb, 300 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[ffffbc]"></a>RadioDisplay</STRONG> (Thumb, 656 bytes, Stack size 56 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 648 + Unknown Stack Size
<LI>Call Chain = RadioDisplay -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0ef00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsZone2PowerOn
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[103c89c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[ffff3c]"></a>GetTextDispBuffer</STRONG> (Thumb, 42 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = GetTextDispBuffer</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fffebc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
</UL>

<P><STRONG><a name="[fffebc]"></a>Radio_Text_Display</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 600 + Unknown Stack Size
<LI>Call Chain = Radio_Text_Display -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ffff3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTextDispBuffer
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fffe40]"></a>RadioChangeMode</STRONG> (Thumb, 812 bytes, Stack size 16 bytes, radio_task.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fd011c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[fd072c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[fdb850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[fdb8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[fdb950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[fdba48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[fff944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>

<P><STRONG><a name="[b0e838]"></a>RadioInit</STRONG> (Thumb, 464 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = RadioInit -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a60408]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fbaff8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fd011c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[fd072c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[fdb850]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[fdb8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[fdb950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[fdba48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
<LI><a href="#[fff944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[fb656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[b0e8b0]"></a>RadioExit</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = RadioExit -> VfdDisplayBlank -> VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fb5ef8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeleteRemoteRepeatKey
<LI><a href="#[fdba48]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDRadioPower
</UL>
<BR>[Called By]<UL><LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[fdbcac]"></a>CalcRadioPosition</STRONG> (Thumb, 302 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[fffac8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[fffdc4]"></a>CalcRadioFreq</STRONG> (Thumb, 166 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fffd44]"></a>CalcCurrenTunerFreq</STRONG> (Thumb, 28 bytes, Stack size 4 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = CalcCurrenTunerFreq</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fffcc8]"></a>UpdateSaveVfd</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 608 + Unknown Stack Size
<LI>Call Chain = UpdateSaveVfd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fffac8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[1002860]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveInit
</UL>

<P><STRONG><a name="[fffc4c]"></a>TextDisplayExit</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = TextDisplayExit -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
</UL>
<BR>[Called By]<UL><LI><a href="#[fffa44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
</UL>

<P><STRONG><a name="[fffbc8]"></a>C11_Tuner_SIS_Change</STRONG> (Thumb, 384 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = C11_Tuner_SIS_Change -> Tuner_Req_Radio_Monitor_Command</UL>
<BR>[Calls]<UL><LI><a href="#[f1a1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[f1a340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[fff834]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fffb44]"></a>C11_Tuner_PSD_Change</STRONG> (Thumb, 474 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = C11_Tuner_PSD_Change -> DeQueue -> IsQueueEmpty</UL>
<BR>[Calls]<UL><LI><a href="#[f1a1dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DeQueue
<LI><a href="#[f1a340]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fffac8]"></a>PreProcSaveKey</STRONG> (Thumb, 234 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = PreProcSaveKey -> UpdateSaveVfd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fdbcac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[fffcc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[1000138]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSavePreset
<LI><a href="#[10028d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveExit
</UL>
<BR>[Called By]<UL><LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[fffa44]"></a>PreProcTextDisplayKey</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = PreProcTextDisplayKey -> TextDisplayExit -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[fffc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TextDisplayExit
<LI><a href="#[10002b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[fff9c8]"></a>RadioKeyService</STRONG> (Thumb, 954 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = RadioKeyService -> RadioDisplay -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0e838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0e8b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fdbcac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[fffa44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcTextDisplayKey
<LI><a href="#[fffac8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
<LI><a href="#[ffffbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[10001bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgTextDisplay
<LI><a href="#[1000238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRadioStatus
<LI><a href="#[1002860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveInit
<LI><a href="#[1002950]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PreProcDigitKey
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[f8d330]"></a>RadioProcMessage</STRONG> (Thumb, 1910 bytes, Stack size 16 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 816 + Unknown Stack Size
<LI>Call Chain = RadioProcMessage -> Zone1ProcMessage -> Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[a604fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[b03f50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0e744]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ea94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioSearch
<LI><a href="#[b0ee84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b0f078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsFreqValid
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f89dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fd1454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[fdb7c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[fdb8d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[fdbcac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[fff6b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[fff734]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Up
<LI><a href="#[fff7b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Down
<LI><a href="#[fff834]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[fff8c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
<LI><a href="#[fff9c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
<LI><a href="#[fffb44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[fffbc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
<LI><a href="#[fffd44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcCurrenTunerFreq
<LI><a href="#[fffdc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioFreq
<LI><a href="#[fffebc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[ffff3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetTextDispBuffer
<LI><a href="#[ffffbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
<LI><a href="#[1000038]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ISValidTunerPostion
<LI><a href="#[1000238]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetRadioStatus
<LI><a href="#[10002b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
<LI><a href="#[1002abc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;get_freq
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> task.o(.constdata)
</UL>
<P><STRONG><a name="[b42630]"></a>RadioLoop</STRONG> (Thumb, 144 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = RadioLoop -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1010574]"></a>SetUart0Baudrate</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = SetUart0Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10104fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>

<P><STRONG><a name="[10104fc]"></a>Uart0Init</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Uart0Init -> SetUart0Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[f1a3bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[1010574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetUart0Baudrate
</UL>
<BR>[Called By]<UL><LI><a href="#[b42448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UartInit
</UL>

<P><STRONG><a name="[f1e438]"></a>Uart0Send</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, uart.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60390]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11Rs232
<LI><a href="#[f1e4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f1e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;debug_printf
</UL>

<P><STRONG><a name="[1010404]"></a>SetUart1Baudrate</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[101038c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
</UL>

<P><STRONG><a name="[101038c]"></a>Uart1Init</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = Uart1Init -> SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[f1a3bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[1010404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetUart1Baudrate
</UL>
<BR>[Called By]<UL><LI><a href="#[b42448]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UartInit
</UL>

<P><STRONG><a name="[1010314]"></a>Uart1Send</STRONG> (Thumb, 40 bytes, Stack size 0 bytes, uart.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f33300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Freq
<LI><a href="#[f3337c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Ext_Reset
<LI><a href="#[f333f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Stop_Seek
<LI><a href="#[f33474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Band_Command
<LI><a href="#[fdb7c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[fdb850]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Volume_Init
<LI><a href="#[fdb8d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Mute_Command
<LI><a href="#[fff6b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[fff734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Up
<LI><a href="#[fff7b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Tune_Down
<LI><a href="#[fff834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[fff8c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
</UL>

<P><STRONG><a name="[b42448]"></a>UartInit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = UartInit -> Uart1Init -> SetUart1Baudrate</UL>
<BR>[Calls]<UL><LI><a href="#[101038c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Init
<LI><a href="#[10104fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart0Init
</UL>
<BR>[Called By]<UL><LI><a href="#[a60578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[10105f4]"></a>Uart0Isr</STRONG> (ARM, 68 bytes, Stack size 32 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Uart0Isr -> InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f1a168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uart.o(.text)
</UL>
<P><STRONG><a name="[1010484]"></a>Uart1Isr</STRONG> (ARM, 84 bytes, Stack size 32 bytes, uart.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = Uart1Isr -> InQueue -> IsQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f1a168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> uart.o(.text)
</UL>
<P><STRONG><a name="[1007000]"></a>Cs8416WriteByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = Cs8416WriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fcffa4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitCs8416
</UL>

<P><STRONG><a name="[1006f84]"></a>Cs8416ReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1006e0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsCs8416Unlock
<LI><a href="#[1006e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[1006f08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
</UL>

<P><STRONG><a name="[1006f08]"></a>Cs8416GetFreq</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = Cs8416GetFreq -> Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[1006e88]"></a>CheckCs8416Unlock</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = CheckCs8416Unlock -> Cs8416ReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1006f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[1006e0c]"></a>IsCs8416Unlock</STRONG> (Thumb, 56 bytes, Stack size 8 bytes, cs8416.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1006f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>

<P><STRONG><a name="[fcffa4]"></a>InitCs8416</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, cs8416.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = InitCs8416 -> Cs8416WriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1007000]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[10208f4]"></a>SelectDSD</STRONG> (Thumb, 186 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[102052c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[102087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>

<P><STRONG><a name="[102087c]"></a>write_word</STRONG> (Thumb, 92 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[10205a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[10208f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
</UL>
<BR>[Called By]<UL><LI><a href="#[1020800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>

<P><STRONG><a name="[1020800]"></a>Pcm1796Write</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[102087c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f99c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[fbb25c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacInvert
<LI><a href="#[fcfeb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[fcff2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
<LI><a href="#[ff2d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
</UL>

<P><STRONG><a name="[fbb25c]"></a>DacInvert</STRONG> (Thumb, 182 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = DacInvert -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[1020800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
</UL>

<P><STRONG><a name="[ff2d44]"></a>Auto_Setup_DAC_Phase</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = Auto_Setup_DAC_Phase -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[1020800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[1020784]"></a>InitDACPhase</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = InitDACPhase -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0e464]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fcff2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACReg
</UL>

<P><STRONG><a name="[b0f99c]"></a>DacMute</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = DacMute -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[1020800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[b0fd6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[f225bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[fb64e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fcff2c]"></a>InitDACReg</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = InitDACReg -> InitDACPhase -> SetSpkPhase -> EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1020784]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
<LI><a href="#[1020800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[102070c]"></a>DSD_Choose</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DSD_Choose</UL>
<BR>[Calls]<UL><LI><a href="#[1020694]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Select
</UL>
<BR>[Called By]<UL><LI><a href="#[fcfeb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
</UL>

<P><STRONG><a name="[fcfeb4]"></a>InitDSDMode</STRONG> (Thumb, 158 bytes, Stack size 8 bytes, dac.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = InitDSDMode -> Pcm1796Write -> write_word -> SelectDSD</UL>
<BR>[Calls]<UL><LI><a href="#[102070c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Choose
<LI><a href="#[1020800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Pcm1796Write
</UL>
<BR>[Called By]<UL><LI><a href="#[a601ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[1098088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
</UL>

<P><STRONG><a name="[b0f544]"></a>EepromWriteByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, eeprom.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = EepromWriteByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b0df74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;WriteName
<LI><a href="#[b0e744]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset
<LI><a href="#[b0fde4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
<LI><a href="#[b0fe5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAIS
<LI><a href="#[b0fed8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASTO
<LI><a href="#[b0ff50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2M
<LI><a href="#[b0ffcc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRM
<LI><a href="#[b10048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
<LI><a href="#[b100c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[b101bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASFP
<LI><a href="#[b10234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[b102b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASHDMIAO
<LI><a href="#[b1032c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASSP
<LI><a href="#[b10acc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACNR
<LI><a href="#[b10b48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7_1
<LI><a href="#[b10bc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN8
<LI><a href="#[b10c40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN7
<LI><a href="#[b10cbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN6
<LI><a href="#[b10d38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN5
<LI><a href="#[b10db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN4
<LI><a href="#[b10e30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN3
<LI><a href="#[b10eac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN2
<LI><a href="#[b10f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ACN1
<LI><a href="#[b10fa4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[b11020]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[b1109c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[b11118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[b11194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[b11210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[b1128c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[b11308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[b11484]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN8
<LI><a href="#[b11500]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN7
<LI><a href="#[b1157c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN6
<LI><a href="#[b115f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN5
<LI><a href="#[b11674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN4
<LI><a href="#[b116f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN3
<LI><a href="#[b1176c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN2
<LI><a href="#[b117e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1IN1
<LI><a href="#[b11d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[b11dc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[b11e3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[b11eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[b11f34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSW
<LI><a href="#[b11fb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBL
<LI><a href="#[b1202c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSBR
<LI><a href="#[b120a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSL
<LI><a href="#[b12124]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPSR
<LI><a href="#[b121a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPR
<LI><a href="#[b1221c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPC
<LI><a href="#[b12298]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSSPL
<LI><a href="#[b12ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[b12b4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[b12bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[b12c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[b12cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[b12d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[b12db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[b12e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[b13644]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSW
<LI><a href="#[b136c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBL
<LI><a href="#[b1373c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSBR
<LI><a href="#[b137b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSL
<LI><a href="#[b13834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPSR
<LI><a href="#[b138b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPR
<LI><a href="#[b13928]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPC
<LI><a href="#[b139a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSSPL
<LI><a href="#[b14774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[b147ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[b14864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[b148dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[b14954]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b149cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b14a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b14abc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[b15454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[b42720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f21610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[f21690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrModeSetup
<LI><a href="#[f21710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f2180c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Z2MasterVolumeLevel
<LI><a href="#[f2188c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TriggerSetup
<LI><a href="#[f21edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[f21f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[f21fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[f22054]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[f220cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[f2214c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[f221cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
<LI><a href="#[f22248]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[f222c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f223c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[f2253c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMaxVolumeLevel
<LI><a href="#[f2263c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RearIrModeSetup
<LI><a href="#[f226b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordSetup
<LI><a href="#[f22734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordModeSetup
<LI><a href="#[f227b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
<LI><a href="#[f228ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[f22924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[f22a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIInAudioSetup
<LI><a href="#[f22a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[f22b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CDPureAudio
<LI><a href="#[f22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[f22c7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[f22cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoInputSeekSetup
<LI><a href="#[f22d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[f22dfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
<LI><a href="#[f22e7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[f76180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;WritePwd
<LI><a href="#[fbadf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeValue
<LI><a href="#[fbae78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeValue
<LI><a href="#[fbb4dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[fd0ff4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
<LI><a href="#[fdbd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
</UL>

<P><STRONG><a name="[b0f5c0]"></a>EepromReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, eeprom.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = EepromReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b0e464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase
<LI><a href="#[b0e7c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadName
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0ee84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadRadioPreset
<LI><a href="#[b11964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_
<LI><a href="#[b119e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_
<LI><a href="#[b11a5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_
<LI><a href="#[b11ad8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_
<LI><a href="#[b11b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_
<LI><a href="#[b11bd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_
<LI><a href="#[b11c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_
<LI><a href="#[b11cc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_
<LI><a href="#[b11d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[b11dc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[b11e3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[b11eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[b42720]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LoadSystemStartupValue
<LI><a href="#[f21610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[f21690]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrModeSetup
<LI><a href="#[f21710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f2180c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Z2MasterVolumeLevel
<LI><a href="#[f2188c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TriggerSetup
<LI><a href="#[f21edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
<LI><a href="#[f21f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[f21fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
<LI><a href="#[f22054]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
<LI><a href="#[f220cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDistanceSetup
<LI><a href="#[f2214c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
<LI><a href="#[f221cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDelaySetup
<LI><a href="#[f22248]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkCrossoverSetup
<LI><a href="#[f222c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkConfigSetup
<LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f223c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[f2253c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMaxVolumeLevel
<LI><a href="#[f2263c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RearIrModeSetup
<LI><a href="#[f226b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordSetup
<LI><a href="#[f22734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PasswordModeSetup
<LI><a href="#[f227b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MasterVolumeLevel
<LI><a href="#[f228ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[f22924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[f22a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIInAudioSetup
<LI><a href="#[f22a9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMIAUIDOOUT
<LI><a href="#[f22b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CDPureAudio
<LI><a href="#[f22c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BrightSetup
<LI><a href="#[f22c7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[f22cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoInputSeekSetup
<LI><a href="#[f22d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AssignedInputSetup
<LI><a href="#[f22dfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogLevelSetup
<LI><a href="#[f22e7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup
<LI><a href="#[f761f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadPwd
<LI><a href="#[fb61f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow
<LI><a href="#[fbac08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fbb4dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
<LI><a href="#[fbb5dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[fbb9d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerPhaseMode
<LI><a href="#[fbbad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[fbbb54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
<LI><a href="#[fbbc4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpeakerMode
<LI><a href="#[fcf8e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd0efc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsEverAutoseek
<LI><a href="#[fd0f78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAutoSeekOn
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1020784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDACPhase
</UL>

<P><STRONG><a name="[10204b4]"></a>wait_timer</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, i2cdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f3d594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f46d28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[f46da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[f46ea0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[f475b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
<LI><a href="#[f6f05c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
<LI><a href="#[f6f58c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
<LI><a href="#[f7588c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[f75908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[f75c58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[f75cd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[f75d50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[f75dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[f75e40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[1006d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[1006d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[102087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>

<P><STRONG><a name="[f75908]"></a>I2CWriteNByte</STRONG> (Thumb, 128 bytes, Stack size 40 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f75cd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[f75d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[f75dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[f4a180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[f4a1f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
</UL>

<P><STRONG><a name="[f7588c]"></a>I2CReadNByte</STRONG> (Thumb, 162 bytes, Stack size 48 bytes, i2cdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f75c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[f75cd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[f75d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[f75dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[f75e40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>

<P><STRONG><a name="[1006d14]"></a>I2C_bytewrite</STRONG> (Thumb, 148 bytes, Stack size 48 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88 + Unknown Stack Size
<LI>Call Chain = I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f75cd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[f75d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[f75dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f544]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[b0f8ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fbb168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
<LI><a href="#[1007000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte
</UL>

<P><STRONG><a name="[1006d90]"></a>I2C_byteread</STRONG> (Thumb, 188 bytes, Stack size 48 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88 + Unknown Stack Size
<LI>Call Chain = I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f75c58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[f75cd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[f75d50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[f75dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[f75e40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f16c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f5c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[1006f84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte
</UL>

<P><STRONG><a name="[f2d778]"></a>read165</STRONG> (Thumb, 80 bytes, Stack size 16 bytes, ic165.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = read165</UL>
<BR>[Calls]<UL><LI><a href="#[f71790]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort1
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[f2ecec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[f6f05c]"></a>Ext4094Sendbyte</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6e9e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094Cs
<LI><a href="#[f6f58c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[f6ef64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>

<P><STRONG><a name="[f6efe0]"></a>Ext4094SetBit</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Ext4094SetBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6f05c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[f6eb5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[f6ebe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[f6ec64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[f6ece8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[f6ed6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[f6ede8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[f6ee64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[f6eee0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[f6ef64]"></a>Ext4094ClearBit</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6f05c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>
<BR>[Called By]<UL><LI><a href="#[f6eb5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[f6ebe0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[f6ec64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[f6ece8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[f6ed6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[f6ede8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[f6ee64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[f6eee0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[f6eee0]"></a>Set_SLSR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_SLSR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f6ead8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
<LI><a href="#[fbad00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6ee64]"></a>Set_HDMI_ISR</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_HDMI_ISR -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fd0098]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
</UL>

<P><STRONG><a name="[f6ede8]"></a>Set_HDMI_RST</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[fcfe38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6ed6c]"></a>Set_UART_SEL</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_UART_SEL -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
<LI><a href="#[fd0098]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
</UL>

<P><STRONG><a name="[f6ece8]"></a>Set_Zone2_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_Zone2_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6ec64]"></a>Set_FLFR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_FLFR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f6ead8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
<LI><a href="#[fbad00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6ebe0]"></a>Set_CENLFE_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_CENLFE_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f6ead8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
<LI><a href="#[fbad00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6eb5c]"></a>Set_SBLSBR_Mas9116_Mute</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ef64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094ClearBit
<LI><a href="#[f6efe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ext4094SetBit
</UL>
<BR>[Called By]<UL><LI><a href="#[f6ead8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Mas9116_HardMute
<LI><a href="#[fbad00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6ead8]"></a>Set_Mas9116_HardMute</STRONG> (Thumb, 64 bytes, Stack size 8 bytes, ic4094.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f6eb5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[f6ebe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[f6ec64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[f6eee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>

<P><STRONG><a name="[fcfe38]"></a>LPC2132HwReset</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = LPC2132HwReset -> Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f6ede8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0098]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[fd001c]"></a>IC4094_Default</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = IC4094_Default -> Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6e970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094OE
<LI><a href="#[f6eb5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[f6ebe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[f6ec64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[f6ece8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Zone2_Mas9116_Mute
<LI><a href="#[f6ed6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[f6ede8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_RST
<LI><a href="#[f6ee64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[f6eee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[fd0098]"></a>HDMI_Software_Update</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = HDMI_Software_Update -> LPC2132HwReset -> Set_HDMI_RST -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6ed6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_UART_SEL
<LI><a href="#[f6ee64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_HDMI_ISR
<LI><a href="#[fb5d84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetCurFocusTid
<LI><a href="#[fcfe38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[fbaefc]"></a>SetIoport0</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f46d28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[f46da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[f46ea0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[f475b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
<LI><a href="#[f692d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[f69798]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[fbba58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay
<LI><a href="#[ff2d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Auto_Setup_DAC_Phase
<LI><a href="#[102087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
<LI><a href="#[10208f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
</UL>

<P><STRONG><a name="[f69c4c]"></a>SensePort0</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f46ea0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[f686c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SenseDspBusy
<LI><a href="#[f68740]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>

<P><STRONG><a name="[102061c]"></a>SetIoport1</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f2d778]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read165
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f46d28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[f46da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[f46ea0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[f475b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
<LI><a href="#[f692d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[f69798]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[10208f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
</UL>

<P><STRONG><a name="[f71790]"></a>SensePort1</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f2d778]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read165
</UL>

<P><STRONG><a name="[10205a4]"></a>SetIoport2</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f69798]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[102087c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_word
</UL>

<P><STRONG><a name="[f69bd4]"></a>SensePort2</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[f69b5c]"></a>SetIoport3</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[f69ae4]"></a>SensePort3</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[102052c]"></a>SetIoport4</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f69798]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[10208f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD
</UL>

<P><STRONG><a name="[f69a6c]"></a>SensePort4</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[fcf96c]"></a>SystemPower</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[fcfdc0]"></a>PowerLed</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b427a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LedStandby
<LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[b427a4]"></a>LedStandby</STRONG> (Thumb, 78 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = LedStandby</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fcfdc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PowerLed
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[f69980]"></a>InitPower</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[fdba48]"></a>HDRadioPower</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0e8b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[fdbd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f69900]"></a>InitHDRaidoPower</STRONG> (Thumb, 16 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[fcfa60]"></a>SetResetPin</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6980c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemReset
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[f69884]"></a>InitResetPin</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f6980c]"></a>SystemReset</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, ioport.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fcfa60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetResetPin
</UL>

<P><STRONG><a name="[f69798]"></a>InitDac</STRONG> (Thumb, 122 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitDac</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[102052c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[10205a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f696a8]"></a>SetMas9116Cs0</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f6934c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
</UL>

<P><STRONG><a name="[f6962c]"></a>SetMas9116Cs1</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f6934c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
</UL>

<P><STRONG><a name="[f695b0]"></a>SetMas9116Cs2</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f6934c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
</UL>

<P><STRONG><a name="[f69534]"></a>SetMas9116Cs3</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f6934c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
</UL>

<P><STRONG><a name="[f694b8]"></a>SetMas9116Cs4</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f6934c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
</UL>

<P><STRONG><a name="[f6943c]"></a>SetMas9116Cs5</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f6934c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
</UL>

<P><STRONG><a name="[f6934c]"></a>SelectMas9116</STRONG> (Thumb, 314 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SelectMas9116</UL>
<BR>[Calls]<UL><LI><a href="#[f6943c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[f694b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[f69534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[f695b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[f6962c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[f696a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
</UL>
<BR>[Called By]<UL><LI><a href="#[f46d28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[f46da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[f692d4]"></a>InitMas9116</STRONG> (Thumb, 78 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMas9116</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f69258]"></a>SetMax335Data</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f3d594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[f68d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
</UL>

<P><STRONG><a name="[f691dc]"></a>SetMax335Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f3d594]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[f68d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
</UL>

<P><STRONG><a name="[f69160]"></a>SetMax335Cs1</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f690e4]"></a>SetMax335Cs2</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f69068]"></a>SetMax335Cs3</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f68fec]"></a>SetMax335Cs4</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f68f70]"></a>SetMax335Cs5</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f68ef4]"></a>SetMax335Cs6</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f68e78]"></a>SetMax335Cs7</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f68dfc]"></a>SetMax335Cs8</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b425b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetIoStandby
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>

<P><STRONG><a name="[f68d80]"></a>SelectMax335</STRONG> (Thumb, 144 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SelectMax335</UL>
<BR>[Calls]<UL><LI><a href="#[f68dfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs8
<LI><a href="#[f68e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs7
<LI><a href="#[f68ef4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs6
<LI><a href="#[f68f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs5
<LI><a href="#[f68fec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs4
<LI><a href="#[f69068]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs3
<LI><a href="#[f690e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs2
<LI><a href="#[f69160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs1
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e0e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
</UL>

<P><STRONG><a name="[f68d08]"></a>InitMAS335</STRONG> (Thumb, 72 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMAS335</UL>
<BR>[Calls]<UL><LI><a href="#[f691dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[f69258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[fbb078]"></a>Set7CH1Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f21f58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPhaseSetup
<LI><a href="#[f68c10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[fcfd40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[fd1070]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
</UL>

<P><STRONG><a name="[f68c8c]"></a>SetZone2Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f68c10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[fdb750]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2Mute
</UL>

<P><STRONG><a name="[fcfc4c]"></a>SetBalance_Mute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f68c10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[fcfd40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[fd1070]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
</UL>

<P><STRONG><a name="[fcfb54]"></a>SetHeadphoneMute</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f68c10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[fcfd40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PowerOffMuteControl
<LI><a href="#[fd1070]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
</UL>

<P><STRONG><a name="[fdb750]"></a>Zone2Mute</STRONG> (Thumb, 26 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone2Mute</UL>
<BR>[Calls]<UL><LI><a href="#[f68c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
</UL>

<P><STRONG><a name="[f68c10]"></a>InitMuteControl</STRONG> (Thumb, 72 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = InitMuteControl</UL>
<BR>[Calls]<UL><LI><a href="#[f68c8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetZone2Mute
<LI><a href="#[fbb078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[fcfb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[fcfc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[fcfd40]"></a>PowerOffMuteControl</STRONG> (Thumb, 24 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = PowerOffMuteControl</UL>
<BR>[Calls]<UL><LI><a href="#[fbb078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set7CH1Mute
<LI><a href="#[fcfb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetHeadphoneMute
<LI><a href="#[fcfc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalance_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>

<P><STRONG><a name="[f68b9c]"></a>Init165</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f2d7ec]"></a>SenseEncoderSwitchPlus</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f2d9e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
</UL>

<P><STRONG><a name="[f2d870]"></a>SenseEncoderSwitchMinus</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f2d9e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
</UL>

<P><STRONG><a name="[f68b1c]"></a>InitEncoderSwitch</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[fd0530]"></a>DSP_Input_Stream_Select</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1098100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[f68a98]"></a>Init_Dsp_Input_Select</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1020694]"></a>DSD_Select</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[102070c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Choose
</UL>

<P><STRONG><a name="[f68a1c]"></a>Init_DSD_Select</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f6899c]"></a>SenseAnalogSignal</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[f39524]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
</UL>

<P><STRONG><a name="[f6e9e8]"></a>Set4094Cs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6f05c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>

<P><STRONG><a name="[f6e970]"></a>Set4094OE</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fd001c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IC4094_Default
</UL>

<P><STRONG><a name="[f6e8f8]"></a>SetData4094</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6f58c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>

<P><STRONG><a name="[f6ea60]"></a>Set4094Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6f58c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Iec4094Sendbyte
</UL>

<P><STRONG><a name="[f68924]"></a>Init4094</STRONG> (Thumb, 30 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f688ac]"></a>SetDspReset</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f687b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
</UL>

<P><STRONG><a name="[f68830]"></a>InitDspResetPin</STRONG> (Thumb, 28 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f687b8]"></a>DSPHwReset</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = DSPHwReset</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f688ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspReset
</UL>
<BR>[Called By]<UL><LI><a href="#[a602a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[f16410]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>

<P><STRONG><a name="[f68740]"></a>SenseDspIrq</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f69c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[a602a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[105b338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[108dd00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[1091eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
</UL>

<P><STRONG><a name="[f686c4]"></a>SenseDspBusy</STRONG> (Thumb, 18 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SenseDspBusy</UL>
<BR>[Calls]<UL><LI><a href="#[f69c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
</UL>
<BR>[Called By]<UL><LI><a href="#[10915e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[f6864c]"></a>Set_Spi_Cs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6845c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
<LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10915e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[f685d4]"></a>Set_Spi_Clk</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6845c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
<LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10915e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1091eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[1091f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
</UL>

<P><STRONG><a name="[f68558]"></a>Set_Spi_MOSI</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f6845c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
<LI><a href="#[1091f28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
</UL>

<P><STRONG><a name="[f684dc]"></a>Sense_Spi_MISO</STRONG> (Thumb, 14 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1091eb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
</UL>

<P><STRONG><a name="[f6845c]"></a>Init_Dsp_Spi_Pin</STRONG> (Thumb, 64 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Init_Dsp_Spi_Pin</UL>
<BR>[Calls]<UL><LI><a href="#[f68558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_MOSI
<LI><a href="#[f685d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[f6864c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[1006b3c]"></a>set_sda</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[1006bb0]"></a>set_scl</STRONG> (Thumb, 44 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[1006c24]"></a>sense_sda</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[1006c9c]"></a>sense_scl</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> cs8416.o(.constdata)
</UL>
<P><STRONG><a name="[f683e4]"></a>set_vfd_sda</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[f6836c]"></a>set_vfd_scl</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[f682f0]"></a>sense_vfd_sda</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[f68274]"></a>sense_vfd_scl</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> vfddriver.o(.constdata)
</UL>
<P><STRONG><a name="[101935c]"></a>set_sda1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[10193d4]"></a>set_scl1</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[101944c]"></a>sense_sda1</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[10194c4]"></a>sense_scl1</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> eeprom.o(.constdata)
</UL>
<P><STRONG><a name="[f681fc]"></a>set_sda2</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[f68184]"></a>set_scl2</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[f6810c]"></a>sense_sda2</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[f68094]"></a>sense_scl2</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> channel.o(.constdata)
</UL>
<P><STRONG><a name="[f68018]"></a>set_sda_hdmi</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[f67f9c]"></a>set_scl_hdmi</STRONG> (Thumb, 52 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f67e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
</UL>
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[f67f20]"></a>sense_sda_hdmi</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[f67ea4]"></a>sense_scl_hdmi</STRONG> (Thumb, 20 bytes, Stack size 0 bytes, ioport.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> hdmi.o(.constdata)
</UL>
<P><STRONG><a name="[f67e2c]"></a>I2cPinInit</STRONG> (Thumb, 172 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = I2cPinInit</UL>
<BR>[Calls]<UL><LI><a href="#[f67f9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl_hdmi
<LI><a href="#[f68018]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda_hdmi
<LI><a href="#[f68184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl2
<LI><a href="#[f681fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda2
<LI><a href="#[f6836c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_vfd_scl
<LI><a href="#[f683e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_vfd_sda
<LI><a href="#[1006b3c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda
<LI><a href="#[1006bb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl
<LI><a href="#[101935c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_sda1
<LI><a href="#[10193d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;set_scl1
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[f67db4]"></a>EnableEint0</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[f67d38]"></a>DisableEint0</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text), UNUSED)

<P><STRONG><a name="[f67cc0]"></a>EnableEint1</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0def8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[f67c44]"></a>DisableEint1</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0def8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[f67bcc]"></a>EnableEint2</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0dd04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
</UL>

<P><STRONG><a name="[f67b50]"></a>DisableEint2</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0dd04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectIr
</UL>

<P><STRONG><a name="[f67ad8]"></a>EnableEint3</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0def8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[f67a5c]"></a>DisableEint3</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0def8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>

<P><STRONG><a name="[b0def8]"></a>Zone1SelectIr</STRONG> (Thumb, 110 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone1SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[f67a5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint3
<LI><a href="#[f67ad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint3
<LI><a href="#[f67c44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint1
<LI><a href="#[f67cc0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint1
</UL>
<BR>[Called By]<UL><LI><a href="#[b100c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIRC
<LI><a href="#[f22924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IrControlSetup
<LI><a href="#[f679e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;remote_config
</UL>

<P><STRONG><a name="[f679e0]"></a>remote_config</STRONG> (Thumb, 60 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = remote_config -> Zone1SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[b0def8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1SelectIr
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
</UL>

<P><STRONG><a name="[b0dd04]"></a>Zone2SelectIr</STRONG> (Thumb, 92 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = Zone2SelectIr</UL>
<BR>[Calls]<UL><LI><a href="#[f67b50]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DisableEint2
<LI><a href="#[f67bcc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EnableEint2
</UL>
<BR>[Called By]<UL><LI><a href="#[b10048]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASIR2C
<LI><a href="#[f21710]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2IrControlSetup
</UL>

<P><STRONG><a name="[b425b4]"></a>SetIoStandby</STRONG> (Thumb, 180 bytes, Stack size 4 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = SetIoStandby</UL>
<BR>[Calls]<UL><LI><a href="#[f68dfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs8
<LI><a href="#[f68e78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs7
<LI><a href="#[f68ef4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs6
<LI><a href="#[f68f70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs5
<LI><a href="#[f68fec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs4
<LI><a href="#[f69068]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs3
<LI><a href="#[f690e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs2
<LI><a href="#[f69160]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Cs1
<LI><a href="#[f691dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[f69258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
<LI><a href="#[f6943c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[f694b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[f69534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[f695b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[f6962c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[f696a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
<LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[102052c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport4
<LI><a href="#[10205a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport2
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
</UL>

<P><STRONG><a name="[fcfad8]"></a>SetIoPowerOn</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, ioport.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[a60130]"></a>HardwareInit</STRONG> (Thumb, 90 bytes, Stack size 8 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = HardwareInit -> SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f679e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;remote_config
<LI><a href="#[f67e2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2cPinInit
<LI><a href="#[f6845c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Spi_Pin
<LI><a href="#[f68830]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDspResetPin
<LI><a href="#[f68924]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init4094
<LI><a href="#[f68a1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_DSD_Select
<LI><a href="#[f68a98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init_Dsp_Input_Select
<LI><a href="#[f68b1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitEncoderSwitch
<LI><a href="#[f68b9c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Init165
<LI><a href="#[f68c10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMuteControl
<LI><a href="#[f68d08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMAS335
<LI><a href="#[f692d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMas9116
<LI><a href="#[f69798]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDac
<LI><a href="#[f69884]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitResetPin
<LI><a href="#[f69900]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitHDRaidoPower
<LI><a href="#[f69980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitPower
<LI><a href="#[fcf96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SystemPower
<LI><a href="#[fcf9e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
</UL>
<BR>[Called By]<UL><LI><a href="#[a60578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[f69cc4]"></a>exint3</STRONG> (ARM, 200 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint3 -> ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[f678e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[f699f8]"></a>exint2</STRONG> (ARM, 236 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint2 -> ir2_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[f67960]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[f69724]"></a>exint1</STRONG> (ARM, 236 bytes, Stack size 40 bytes, ioport.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = exint1 -> ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[f678e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> ioport.o(.text)
</UL>
<P><STRONG><a name="[f693c8]"></a>exint0</STRONG> (ARM, 200 bytes, Stack size 40 bytes, ioport.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f678e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
</UL>

<P><STRONG><a name="[f5aa24]"></a>repeat_IRkey_allowed</STRONG> (Thumb, 48 bytes, Stack size 0 bytes, ir.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60408]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AddRemoteRepeatKey
<LI><a href="#[f678e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips
</UL>

<P><STRONG><a name="[b4281c]"></a>InitRemoteRepeatKey</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = InitRemoteRepeatKey</UL>
<BR>[Calls]<UL><LI><a href="#[103c3c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a60578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[a60408]"></a>AddRemoteRepeatKey</STRONG> (Thumb, 48 bytes, Stack size 4 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = AddRemoteRepeatKey</UL>
<BR>[Calls]<UL><LI><a href="#[f5aa24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;repeat_IRkey_allowed
</UL>
<BR>[Called By]<UL><LI><a href="#[a60578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb66d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuInit
</UL>

<P><STRONG><a name="[fb5ef8]"></a>DeleteRemoteRepeatKey</STRONG> (Thumb, 102 bytes, Stack size 4 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = DeleteRemoteRepeatKey</UL>
<BR>[Called By]<UL><LI><a href="#[b0e8b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioExit
<LI><a href="#[fb626c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupEnterKey
<LI><a href="#[fb656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
</UL>

<P><STRONG><a name="[f5a99c]"></a>zone2_repeat_IRkey_allowed</STRONG> (Thumb, 18 bytes, Stack size 0 bytes, ir.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f678e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips
<LI><a href="#[f67960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips
</UL>

<P><STRONG><a name="[f678e4]"></a>ir_core_philips</STRONG> (Thumb, 714 bytes, Stack size 48 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ir_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[f5a99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;zone2_repeat_IRkey_allowed
<LI><a href="#[f5aa24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;repeat_IRkey_allowed
<LI><a href="#[1173550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[1173b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[1179a98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f693c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint0 (via Veneer)
<LI><a href="#[f69724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint1 (via Veneer)
<LI><a href="#[f69cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint3 (via Veneer)
</UL>

<P><STRONG><a name="[f67960]"></a>ir2_core_philips</STRONG> (Thumb, 622 bytes, Stack size 48 bytes, ir.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = ir2_core_philips</UL>
<BR>[Calls]<UL><LI><a href="#[f5a99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;zone2_repeat_IRkey_allowed
<LI><a href="#[1173550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple (via Veneer)
<LI><a href="#[1173b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple (via Veneer)
<LI><a href="#[1179a98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2d (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f699f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exint2 (via Veneer)
</UL>

<P><STRONG><a name="[b0f928]"></a>DelayMs</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a602a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0f63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[b0fd6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASRD
<LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[b427a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LedStandby
<LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f225bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RestoreDefaultSetup
<LI><a href="#[f39524]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
<LI><a href="#[f687b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[f6980c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemReset
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService
<LI><a href="#[fb64e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
<LI><a href="#[fcf86c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
<LI><a href="#[fcfbd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[fcfe38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LPC2132HwReset
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[fd0a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd10e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOff
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[fd1558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[fdb950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[fffebc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[1006e88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1036008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
<LI><a href="#[105b338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
<LI><a href="#[10801f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
<LI><a href="#[108dd00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10915e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[b424c0]"></a>Timer0_Handler</STRONG> (Thumb, 214 bytes, Stack size 8 bytes, timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 656 + Unknown Stack Size
<LI>Call Chain = Timer0_Handler -> RadioDisplay -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f1a3bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitQueue
<LI><a href="#[f2d96c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;key_task
<LI><a href="#[f2d9e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetEncoderSwitchThread
<LI><a href="#[f50330]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fb6078]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupFlashHandler
<LI><a href="#[fff834]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Req_Radio_Monitor_Command
<LI><a href="#[fffb44]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change
<LI><a href="#[fffebc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Radio_Text_Display
<LI><a href="#[ffffbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[b4253c]"></a>Timer0Init</STRONG> (Thumb, 34 bytes, Stack size 0 bytes, timer.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60578]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Systeminit
</UL>

<P><STRONG><a name="[f503ac]"></a>timer0_irq</STRONG> (ARM, 752 bytes, Stack size 24 bytes, timer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = timer0_irq -> RefreshHandle -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow (via Veneer)
<LI><a href="#[f89d4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTimerHandler (via Veneer)
<LI><a href="#[fd15d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RefreshHandle (via Veneer)
<LI><a href="#[fd16c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetSoftMute (via Veneer)
<LI><a href="#[fd17c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPHDMISetting (via Veneer)
</UL>
<BR>[Address Reference Count : 1]<UL><LI> timer.o(.text)
</UL>
<P><STRONG><a name="[f4a1f8]"></a>VfdSendNByte</STRONG> (Thumb, 46 bytes, Stack size 88 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f75908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f89c54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>

<P><STRONG><a name="[f4a180]"></a>VfdSendByte</STRONG> (Thumb, 42 bytes, Stack size 80 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f75908]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b42350]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSetDimerValue
<LI><a href="#[f89c54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateBuffer
</UL>

<P><STRONG><a name="[f89c54]"></a>VfdUpdateBuffer</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = VfdUpdateBuffer -> VfdSendNByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f4a180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
<LI><a href="#[f4a1f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0dfec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b423d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdRefresh
<LI><a href="#[fbac88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>

<P><STRONG><a name="[b42350]"></a>VfdSetDimerValue</STRONG> (Thumb, 34 bytes, Stack size 8 bytes, vfddriver.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 168 + Unknown Stack Size
<LI>Call Chain = VfdSetDimerValue -> VfdSendByte -> I2CWriteNByte -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f4a180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[a604fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcDimerOff
<LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[f46ea0]"></a>Mas9116Read</STRONG> (Thumb, 176 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Mas9116Read</UL>
<BR>[Calls]<UL><LI><a href="#[f69c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SensePort0
<LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[f46d28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
</UL>

<P><STRONG><a name="[f46e20]"></a>CalcMas9116Volume</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[11723e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1177ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f46da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[f46da4]"></a>Mas9116SetGain</STRONG> (Thumb, 146 bytes, Stack size 24 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[f46e20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume
<LI><a href="#[f475b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
<LI><a href="#[f6934c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e648]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[b0e6c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set2ChVolume
<LI><a href="#[f43070]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume
<LI><a href="#[fbad78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZone2Volume
</UL>

<P><STRONG><a name="[f46d28]"></a>Mas9116ReadRC5</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Mas9116ReadRC5 -> Mas9116Read</UL>
<BR>[Calls]<UL><LI><a href="#[f46ea0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Read
<LI><a href="#[f6934c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMas9116
<LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[fbad00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fcf86c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
</UL>

<P><STRONG><a name="[f46cac]"></a>Mas9116Reset</STRONG> (Thumb, 138 bytes, Stack size 8 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = Mas9116Reset -> Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[f475b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116WriteWord
<LI><a href="#[f6943c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs5
<LI><a href="#[f694b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs4
<LI><a href="#[f69534]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs3
<LI><a href="#[f695b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs2
<LI><a href="#[f6962c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs1
<LI><a href="#[f696a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMas9116Cs0
<LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[fbad00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fcf86c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VolumeInit
</UL>

<P><STRONG><a name="[fbad78]"></a>SetZone2Volume</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SetZone2Volume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[f46da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>
<BR>[Called By]<UL><LI><a href="#[f21610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
<LI><a href="#[fbb558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel
</UL>

<P><STRONG><a name="[b0e6c8]"></a>Set2ChVolume</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = Set2ChVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[f46da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>
<BR>[Called By]<UL><LI><a href="#[b10fa4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL8
<LI><a href="#[b11020]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL7
<LI><a href="#[b1109c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL6
<LI><a href="#[b11118]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL5
<LI><a href="#[b11194]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL4
<LI><a href="#[b11210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL3
<LI><a href="#[b1128c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL2
<LI><a href="#[b11308]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1SAL1
<LI><a href="#[fbb6dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[b0e648]"></a>SetBalanceVolume</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[f46da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[1177ea8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fadd (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b12ad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSW
<LI><a href="#[b12b4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBL
<LI><a href="#[b12bc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLBR
<LI><a href="#[b12c44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSL
<LI><a href="#[b12cc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLSR
<LI><a href="#[b12d3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLR
<LI><a href="#[b12db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLC
<LI><a href="#[b12e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSLL
<LI><a href="#[b14774]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSW
<LI><a href="#[b147ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBL
<LI><a href="#[b14864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLBR
<LI><a href="#[b148dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSL
<LI><a href="#[b14954]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLSR
<LI><a href="#[b149cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLR
<LI><a href="#[b14a44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLC
<LI><a href="#[b14abc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSLL
<LI><a href="#[f223c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceSetup
<LI><a href="#[fbaff8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume
<LI><a href="#[fbbb54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceMode
</UL>

<P><STRONG><a name="[fbaff8]"></a>Set7Ch1MainVolume</STRONG> (Thumb, 100 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = Set7Ch1MainVolume -> SetBalanceVolume -> Mas9116SetGain -> CalcMas9116Volume</UL>
<BR>[Calls]<UL><LI><a href="#[b0e648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fb656c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupExit
<LI><a href="#[fbb4dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MaxVolumeLevel
<LI><a href="#[fbb5dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMasterVolumeLevel
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[ff34ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f43070]"></a>AutoSoundSetVolume</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, volume.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f46da4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>

<P><STRONG><a name="[fbad00]"></a>SoftMute</STRONG> (Thumb, 140 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SoftMute -> Set_SBLSBR_Mas9116_Mute -> Ext4094ClearBit -> Ext4094Sendbyte -> Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f46cac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f46d28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
<LI><a href="#[f6eb5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SBLSBR_Mas9116_Mute
<LI><a href="#[f6ebe0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_CENLFE_Mas9116_Mute
<LI><a href="#[f6ec64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_FLFR_Mas9116_Mute
<LI><a href="#[f6eee0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_SLSR_Mas9116_Mute
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[fd062c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[fd08a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[fd0a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0a98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1097f90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_secret_loop
<LI><a href="#[1098088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[1098100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[fcf86c]"></a>VolumeInit</STRONG> (Thumb, 116 bytes, Stack size 8 bytes, volume.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = VolumeInit -> Mas9116ReadRC5 -> Mas9116Read</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f46cac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f46d28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Mas9116ReadRC5
</UL>
<BR>[Called By]<UL><LI><a href="#[fd1164]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemPowerOn
</UL>

<P><STRONG><a name="[f3d594]"></a>Max335SendByte</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f691dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Clk
<LI><a href="#[f69258]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Data
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e0e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
</UL>

<P><STRONG><a name="[b0e4dc]"></a>SetMax335Switch</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = SetMax335Switch</UL>
<BR>[Called By]<UL><LI><a href="#[b0ddfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f394ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[fbac08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fd06a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[fd072c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fff944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>

<P><STRONG><a name="[b0e0e4]"></a>UpdateMax335</STRONG> (Thumb, 46 bytes, Stack size 8 bytes, max335.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[f3d594]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Max335SendByte
<LI><a href="#[f68d80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SelectMax335
</UL>
<BR>[Called By]<UL><LI><a href="#[b0ddfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f394ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[fbac08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fd06a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[fd072c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fff944]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
</UL>

<P><STRONG><a name="[b0f8ac]"></a>DigiSendByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[f395a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2DigiSelectChannel
<LI><a href="#[f39624]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelectChannel
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fcf9e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetTrigerOut
<LI><a href="#[fd0394]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelect71Channel
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1098100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[fcf9e4]"></a>SetTrigerOut</STRONG> (Thumb, 32 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = SetTrigerOut -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a60130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HardwareInit
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fdbdb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOff
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
</UL>

<P><STRONG><a name="[f39624]"></a>DigitalInSelectChannel</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[fd0394]"></a>DigitalInSelect71Channel</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = DigitalInSelect71Channel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[f395a0]"></a>Zone2DigiSelectChannel</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fbac08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
</UL>

<P><STRONG><a name="[f39524]"></a>CheckAnalogIn</STRONG> (Thumb, 44 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CheckAnalogIn</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f6899c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseAnalogSignal
</UL>
<BR>[Called By]<UL><LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[f394ac]"></a>AnalogInOff</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInOff -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[f39424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSelectInputChannel
<LI><a href="#[fcf8e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[fd05b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInput
</UL>

<P><STRONG><a name="[b0ddfc]"></a>Zone2AnalogInOff</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Zone2AnalogInOff -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[fbac08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
</UL>

<P><STRONG><a name="[fff944]"></a>AnalogInSelectChannel</STRONG> (Thumb, 58 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInSelectChannel -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fbac08]"></a>Zone2SelectChannel</STRONG> (Thumb, 232 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = Zone2SelectChannel -> Zone2DigiSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0ddfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[f395a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2DigiSelectChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[fdbd2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcInputSelect
<LI><a href="#[fdbe30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone2PowerOn
</UL>

<P><STRONG><a name="[fd06a8]"></a>AnalogInputTypeSelect</STRONG> (Thumb, 118 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = AnalogInputTypeSelect -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[ff34ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundExit
</UL>

<P><STRONG><a name="[fd072c]"></a>Analog7CH1OutSelectChannel</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Analog7CH1OutSelectChannel -> UpdateMax335 -> Max335SendByte</UL>
<BR>[Calls]<UL><LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f3a4a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f39424]"></a>SystemSelectInputChannel</STRONG> (Thumb, 54 bytes, Stack size 16 bytes, channel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[f394ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[f3a4a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>

<P><STRONG><a name="[fcf8e4]"></a>SystemSearchInputChannel</STRONG> (Thumb, 86 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[f394ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[f3a4a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
</UL>

<P><STRONG><a name="[fd05b4]"></a>CheckInput</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216 + Unknown Stack Size
<LI>Call Chain = CheckInput -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f394ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInOff
<LI><a href="#[f3a4a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckInputChannel
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek
<LI><a href="#[fd0e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
</UL>

<P><STRONG><a name="[fff834]"></a>Tuner_Req_Radio_Monitor_Command</STRONG> (Thumb, 140 bytes, Stack size 40 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Tuner_Req_Radio_Monitor_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fffbc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change
</UL>

<P><STRONG><a name="[f33474]"></a>Tuner_Band_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Band_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[fdb950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[fff734]"></a>Tuner_Req_Tune_Up</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Req_Tune_Up</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[fff7b4]"></a>Tuner_Req_Tune_Down</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Req_Tune_Down</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[f333f8]"></a>Tuner_Stop_Seek</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Tuner_Stop_Seek</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[fdb950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[fff6b4]"></a>Tuner_Seek_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Seek_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fdb950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[fff8c0]"></a>Tuner_HDSEEK_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_HDSEEK_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fdb950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[fdb8d0]"></a>Tuner_Mute_Command</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Tuner_Mute_Command</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fdb850]"></a>Tuner_Volume_Init</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = Tuner_Volume_Init</UL>
<BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[f3337c]"></a>Tuner_Ext_Reset</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, tuner.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>

<P><STRONG><a name="[f33300]"></a>Tuner_Req_Freq</STRONG> (Thumb, 44 bytes, Stack size 8 bytes, tuner.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
</UL>

<P><STRONG><a name="[f33284]"></a>FreqCheckSum</STRONG> (Thumb, 28 bytes, Stack size 4 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = FreqCheckSum</UL>
<BR>[Called By]<UL><LI><a href="#[fdb7c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
</UL>

<P><STRONG><a name="[fdb7c8]"></a>Tuner_Write_Freq_Command</STRONG> (Thumb, 104 bytes, Stack size 32 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 36 + Unknown Stack Size
<LI>Call Chain = Tuner_Write_Freq_Command -> FreqCheckSum</UL>
<BR>[Calls]<UL><LI><a href="#[f33284]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FreqCheckSum
<LI><a href="#[1010314]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Uart1Send
<LI><a href="#[1180440]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
<LI><a href="#[fdb950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitTuner
</UL>

<P><STRONG><a name="[fdb950]"></a>InitTuner</STRONG> (Thumb, 226 bytes, Stack size 8 bytes, tuner.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 44 + Unknown Stack Size
<LI>Call Chain = InitTuner -> Tuner_Write_Freq_Command -> FreqCheckSum</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f333f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Stop_Seek
<LI><a href="#[f33474]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Band_Command
<LI><a href="#[fdb7c8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command
<LI><a href="#[fff6b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_Seek_Command
<LI><a href="#[fff8c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Tuner_HDSEEK_Command
</UL>
<BR>[Called By]<UL><LI><a href="#[b0dd80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[fbb168]"></a>HdmiSendByte</STRONG> (Thumb, 42 bytes, Stack size 88 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e5cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetHdmiAudioOut
<LI><a href="#[fd011c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Port_Select
<LI><a href="#[fd0d08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOff
<LI><a href="#[fd0d88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcZone1PowerOn
</UL>

<P><STRONG><a name="[b0f16c]"></a>HdmiReadByte</STRONG> (Thumb, 40 bytes, Stack size 72 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 160 + Unknown Stack Size
<LI>Call Chain = HdmiReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1006d90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
<LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[a601ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1097f90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_secret_loop
<LI><a href="#[1098088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[1098100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>

<P><STRONG><a name="[fd011c]"></a>HDMI_Port_Select</STRONG> (Thumb, 104 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = HDMI_Port_Select -> HdmiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[fbb168]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e838]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource
<LI><a href="#[fffe40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioChangeMode
</UL>

<P><STRONG><a name="[1098100]"></a>HDMI_Loop</STRONG> (Thumb, 148 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = HDMI_Loop -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
</UL>
<BR>[Called By]<UL><LI><a href="#[a601ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[1098088]"></a>DSD_Loop</STRONG> (Thumb, 196 bytes, Stack size 16 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 176 + Unknown Stack Size
<LI>Call Chain = DSD_Loop -> HdmiReadByte -> I2C_byteread -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetCurFocusTid
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fcfeb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
</UL>
<BR>[Called By]<UL><LI><a href="#[a601ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[1098010]"></a>HDMI_Busy</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = HDMI_Busy -> DSP_API_Read -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1097f14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
</UL>
<BR>[Called By]<UL><LI><a href="#[a601ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_DSD_Loop
</UL>

<P><STRONG><a name="[1097f90]"></a>HDMI_secret_loop</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, hdmi.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
</UL>

<P><STRONG><a name="[a601ac]"></a>HDMI_DSD_Loop</STRONG> (Thumb, 88 bytes, Stack size 8 bytes, hdmi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 192 + Unknown Stack Size
<LI>Call Chain = HDMI_DSD_Loop -> HDMI_Loop -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[fcfeb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitDSDMode
<LI><a href="#[1098010]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Busy
<LI><a href="#[1098088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSD_Loop
<LI><a href="#[1098100]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Loop
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[1091660]"></a>Delay_SPI</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dsp_spi.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>

<P><STRONG><a name="[10915e0]"></a>DspSpiWriteNByte</STRONG> (Thumb, 162 bytes, Stack size 24 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 108<LI>Call Chain = DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[f685d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[f6864c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
<LI><a href="#[f686c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspBusy
<LI><a href="#[1091f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
</UL>
<BR>[Called By]<UL><LI><a href="#[f393a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[fbb358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[fd0210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[fd041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO
<LI><a href="#[fd04a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_MULTI
<LI><a href="#[ff2bd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[ff2c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[1026684]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadOS
<LI><a href="#[10266fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB_Debug
<LI><a href="#[1026790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_Debug
<LI><a href="#[10352d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[1035364]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
<LI><a href="#[1035468]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Speaker_Select
<LI><a href="#[10354ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Control
<LI><a href="#[10355ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[1035670]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[10356f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[1035800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE
<LI><a href="#[1035884]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Channel
<LI><a href="#[1035900]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Test_Duration
<LI><a href="#[1035984]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[1035a04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035a84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035afc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[1035b78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[1035bf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1035e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DTS_HD_HRA_Read
<LI><a href="#[1035f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDTSHDChannel
<LI><a href="#[104d12c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Max_EQ_Fc
<LI><a href="#[1052cb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC_1_Test_Signal
<LI><a href="#[1052d34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Tx_Channel
<LI><a href="#[1052db4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Gain
<LI><a href="#[1052e2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC_1_Control
<LI><a href="#[105b338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[105b430]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[105b4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_POSTGAIN
<LI><a href="#[105b528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CH_PREATTENUATION
<LI><a href="#[105b5b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Flash
<LI><a href="#[105b62c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Bands
<LI><a href="#[105b6a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Channels
<LI><a href="#[105b724]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Config
<LI><a href="#[105b7a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
<LI><a href="#[10715b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolbyPLIIX
<LI><a href="#[1071634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DIMENSION_CONFIGURATION
<LI><a href="#[10716c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1071758]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CNOTROL_REGISTER
<LI><a href="#[10717e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_Control
<LI><a href="#[1074b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION
<LI><a href="#[1074c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1074cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CONTROL_REGISTER
<LI><a href="#[1074d34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[1074db8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
<LI><a href="#[107810c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadRegist
<LI><a href="#[1078188]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadCrossbar
<LI><a href="#[1078204]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolby
<LI><a href="#[1078300]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[107837c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[10783f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
<LI><a href="#[1078480]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_STEREO_MODE_CONTROL
<LI><a href="#[1078508]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_Control
<LI><a href="#[1080174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDelay
<LI><a href="#[1080274]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DLYAUXCNTL
<LI><a href="#[10802f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EXT_BUFF_SIZE
<LI><a href="#[1080370]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EXT_BUFF_ADDR
<LI><a href="#[10803f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Max_Setting
<LI><a href="#[1080474]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Unit
<LI><a href="#[10804f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_MAIN_PPM_CONTROL
<LI><a href="#[10886c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[1088754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10887e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[108886c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[10888f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[1088980]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[1088a08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[1088a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[1088b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[1088ba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[1088c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[1088cb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[1088d40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[1088dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
<LI><a href="#[1088e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER
<LI><a href="#[1088ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_HPF_CONTROL
<LI><a href="#[1088f54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_5XOVER_CONTROL
<LI><a href="#[1088fdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
<LI><a href="#[1097f14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
<LI><a href="#[10c9ee8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10c9f68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode_Pl2x
<LI><a href="#[10c9fec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[10ca06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_OUTPUT_FS
<LI><a href="#[10cd428]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Decode_Mode_Control
<LI><a href="#[10cd4b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Control
<LI><a href="#[10d9924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadSgen
<LI><a href="#[10d999c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CHANNEL_SIGNAL_SELECT
</UL>

<P><STRONG><a name="[1091564]"></a>DspSpiReadNByte</STRONG> (Thumb, 118 bytes, Stack size 24 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 44<LI>Call Chain = DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f685d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[f6864c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Cs
<LI><a href="#[f68740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[1091660]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Delay_SPI
<LI><a href="#[1091eb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadByteDsp
<LI><a href="#[1091f28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Write_Byte
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
<LI><a href="#[1036288]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
<LI><a href="#[105b338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadEq
<LI><a href="#[108dd00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
</UL>

<P><STRONG><a name="[108905c]"></a>ConvertDbValue</STRONG> (Thumb, 74 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 288<LI>Call Chain = ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[11788c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2d (via Veneer)
<LI><a href="#[117c904]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_d2f (via Veneer)
<LI><a href="#[119054c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pow (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10886c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[1088754]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10887e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[108886c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[10888f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[1088980]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[1088a08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[1088a90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[1088b18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[1088ba0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[1088c28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[1088cb4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[1088d40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[1088dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
</UL>

<P><STRONG><a name="[1088fdc]"></a>DSP_BASS_CONTROL</STRONG> (Thumb, 174 bytes, Stack size 40 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DSP_BASS_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[108855c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;BassOn
<LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088f54]"></a>DSP_BASS_MGR_5XOVER_CONTROL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_BASS_MGR_5XOVER_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088ecc]"></a>DSP_BASS_MGR_HPF_CONTROL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_BASS_MGR_HPF_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088e4c]"></a>DSP_SET_BASS_CORNER</STRONG> (Thumb, 304 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_SET_BASS_CORNER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fbaf74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>

<P><STRONG><a name="[1088dc8]"></a>DSP_BASS_INPUT_LEVEL</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_INPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088d40]"></a>DSP_BASS_LFE_OUTPUT_LEVEL</STRONG> (Thumb, 206 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_LFE_OUTPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088cb4]"></a>DSP_BASS_FRONT_SUM_OUTPUT_LEVEL</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_FRONT_SUM_OUTPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088c28]"></a>DSP_BASS_BACK_SUM_OUTPUT_LEVEL</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_BACK_SUM_OUTPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088ba0]"></a>DSP_BASS_SUM1_INPUT_LEVEL</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM1_INPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088b18]"></a>DSP_BASS_SUM2_INPUT_LEVEL</STRONG> (Thumb, 160 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM2_INPUT_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088a90]"></a>DSP_BASS_SUM3_INPUT_LEVLE</STRONG> (Thumb, 168 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM3_INPUT_LEVLE -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088a08]"></a>DSP_BASS_SUM4_INPUT_LEVLE</STRONG> (Thumb, 174 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM4_INPUT_LEVLE -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088980]"></a>DSP_BASS_SUM5_INPUT_LEVLE</STRONG> (Thumb, 190 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_SUM5_INPUT_LEVLE -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10888f4]"></a>DSP_BASS_X_INPUT_LEVEL_FRONT</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_X_INPUT_LEVEL_FRONT -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[108886c]"></a>DSP_BASS_X_INPUT_LEVEL_BACK</STRONG> (Thumb, 176 bytes, Stack size 32 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 320<LI>Call Chain = DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10887e4]"></a>DSP_BASS_INPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = DSP_BASS_INPUT_SUB_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088754]"></a>DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10886c4]"></a>DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 304<LI>Call Chain = DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[108905c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[1088648]"></a>ConfigSpkMode</STRONG> (Thumb, 512 bytes, Stack size 48 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = ConfigSpkMode -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10885d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
</UL>

<P><STRONG><a name="[10885d0]"></a>C11SetBass</STRONG> (Thumb, 584 bytes, Stack size 24 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 344<LI>Call Chain = C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[1088648]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode
<LI><a href="#[10886c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[1088754]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_SUB_LEVEL
<LI><a href="#[10887e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_SUB_LEVEL
<LI><a href="#[108886c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK
<LI><a href="#[10888f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT
<LI><a href="#[1088980]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE
<LI><a href="#[1088a08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM4_INPUT_LEVLE
<LI><a href="#[1088a90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM3_INPUT_LEVLE
<LI><a href="#[1088b18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM2_INPUT_LEVEL
<LI><a href="#[1088ba0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM1_INPUT_LEVEL
<LI><a href="#[1088c28]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_BACK_SUM_OUTPUT_LEVEL
<LI><a href="#[1088cb4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_FRONT_SUM_OUTPUT_LEVEL
<LI><a href="#[1088d40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL
<LI><a href="#[1088dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL
<LI><a href="#[1088ecc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_HPF_CONTROL
<LI><a href="#[1088f54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_MGR_5XOVER_CONTROL
<LI><a href="#[1088fdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[fbaf74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>

<P><STRONG><a name="[108855c]"></a>BassOn</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, bassmanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1088fdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_CONTROL
</UL>

<P><STRONG><a name="[fbaf74]"></a>SetBassManagerSpeaker</STRONG> (Thumb, 206 bytes, Stack size 8 bytes, bassmanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 352<LI>Call Chain = SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[10885d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;C11SetBass
<LI><a href="#[1088e4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
<LI><a href="#[f16318]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSpkMode
<LI><a href="#[f16580]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner
<LI><a href="#[fbbad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[10804f0]"></a>DSP_MAIN_PPM_CONTROL</STRONG> (Thumb, 152 bytes, Stack size 32 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_MAIN_PPM_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[10801f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>

<P><STRONG><a name="[1080474]"></a>DSP_Delay_Unit</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[fbb358]"></a>DSP_Delay_Channel_Setting</STRONG> (Thumb, 186 bytes, Stack size 32 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fa10]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[f16504]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay
<LI><a href="#[fbbbd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode
<LI><a href="#[10801f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>

<P><STRONG><a name="[10803f0]"></a>DSP_Delay_Max_Setting</STRONG> (Thumb, 182 bytes, Stack size 24 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1080370]"></a>DSP_EXT_BUFF_ADDR</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10802f0]"></a>DSP_EXT_BUFF_SIZE</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1080274]"></a>DSP_DLYAUXCNTL</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10801f0]"></a>DSP_Delay_Firmware_Init</STRONG> (Thumb, 104 bytes, Stack size 8 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DSP_Delay_Firmware_Init -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fbb358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[10804f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_MAIN_PPM_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[b0fa10]"></a>DSP_AV_Delay</STRONG> (Thumb, 96 bytes, Stack size 8 bytes, delaymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DSP_AV_Delay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fbb358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
</UL>
<BR>[Called By]<UL><LI><a href="#[b10234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD
<LI><a href="#[b11d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL
<LI><a href="#[f22c7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AvSyncDelaySetup
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[1080174]"></a>DspReadDelay</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, delaymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1078508]"></a>DSP_AC3_Control</STRONG> (Thumb, 140 bytes, Stack size 24 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1078480]"></a>DSP_AC3_STEREO_MODE_CONTROL</STRONG> (Thumb, 96 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10783f8]"></a>DSP_AC3_COMPRESSION_CONTROL</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = DSP_AC3_COMPRESSION_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[1078280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[107837c]"></a>DSP_AC3_CUT_X</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_AC3_CUT_X -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[1078280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[1078300]"></a>DSP_AC3_BOOST_Y</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_AC3_BOOST_Y -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[1078280]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
</UL>

<P><STRONG><a name="[1078280]"></a>DSP_AC3_DRC_INIT</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dolbymanager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = DSP_AC3_DRC_INIT -> DSP_AC3_BOOST_Y -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1078300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[107837c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[10783f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>

<P><STRONG><a name="[1078204]"></a>DspReadDolby</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1078188]"></a>DspReadCrossbar</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[107810c]"></a>DspReadRegist</STRONG> (Thumb, 60 bytes, Stack size 16 bytes, dolbymanager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1074db8]"></a>DSP_PLII_Control</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e354]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[1074b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Firmware_Cfg
</UL>

<P><STRONG><a name="[1074d34]"></a>DSP_PLII_DECODE_MODE</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_DECODE_MODE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
<LI><a href="#[b0e354]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
<LI><a href="#[b0e3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
<LI><a href="#[1074b08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Firmware_Cfg
</UL>

<P><STRONG><a name="[1074cac]"></a>DSP_PLII_CONTROL_REGISTER</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_CONTROL_REGISTER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e354]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Panorama_On_Or_Off
</UL>

<P><STRONG><a name="[1074c1c]"></a>DSP_PLII_CENTER_WIDTH_CONFIGURATION</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_CENTER_WIDTH_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Width
</UL>

<P><STRONG><a name="[1074b8c]"></a>DSP_PLII_DIMENSION_CONFIGURATION</STRONG> (Thumb, 170 bytes, Stack size 16 bytes, dolbyprologicii.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLII_DIMENSION_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set_Prologic2Dimension
</UL>

<P><STRONG><a name="[1074b08]"></a>DSP_PLII_Firmware_Cfg</STRONG> (Thumb, 20 bytes, Stack size 8 bytes, dolbyprologicii.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1074d34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[1074db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
</UL>

<P><STRONG><a name="[10717e0]"></a>DSP_PLIIx_Control</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[fd041c]"></a>DSP_PLIIx_DECODE_MODE_STEREO</STRONG> (Thumb, 164 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLIIx_DECODE_MODE_STEREO -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fd09a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
</UL>

<P><STRONG><a name="[1071758]"></a>DSP_PLIIx_CNOTROL_REGISTER</STRONG> (Thumb, 134 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10716c4]"></a>DSP_PLIIx_CENTER_WIDTH_CONFIGURATION</STRONG> (Thumb, 174 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[1071634]"></a>DSP_PLIIx_DIMENSION_CONFIGURATION</STRONG> (Thumb, 170 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[fd04a8]"></a>DSP_PLIIx_DECODE_MODE_MULTI</STRONG> (Thumb, 160 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_PLIIx_DECODE_MODE_MULTI -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd082c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
</UL>

<P><STRONG><a name="[10715b4]"></a>DspReadDolbyPLIIX</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbyprologiciix.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[106c2f8]"></a>ClearDspBuffer</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, dsp_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[106c27c]"></a>AnalyseDspMsg</STRONG> (Thumb, 234 bytes, Stack size 24 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 232 + Unknown Stack Size
<LI>Call Chain = AnalyseDspMsg -> DspProcUnsolicitedMsg -> ProcAutodetecResponse -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[103bf64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy (via Veneer)
<LI><a href="#[106bf04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
<LI><a href="#[106c008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
<LI><a href="#[106c088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHRACfg
<LI><a href="#[106c108]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
<LI><a href="#[106c184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
<LI><a href="#[106c200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
</UL>
<BR>[Called By]<UL><LI><a href="#[a6031c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoop
</UL>

<P><STRONG><a name="[a6031c]"></a>DspLoop</STRONG> (Thumb, 210 bytes, Stack size 16 bytes, dsp_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 272 + Unknown Stack Size
<LI>Call Chain = DspLoop -> ProcInputSelect -> SelectSource -> SystemSearchInputChannel -> CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f68740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[f6899c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseAnalogSignal
<LI><a href="#[fd12e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect
<LI><a href="#[fd1740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDspChannel
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1006f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
<LI><a href="#[106c27c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
<LI><a href="#[106c2f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ClearDspBuffer
<LI><a href="#[1091564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
</UL>

<P><STRONG><a name="[ff2a54]"></a>ReConvert_8_24_Value</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = ReConvert_8_24_Value</UL>
<BR>[Calls]<UL><LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
</UL>

<P><STRONG><a name="[ff2cc4]"></a>ConvertBalanceValue</STRONG> (Thumb, 62 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ConvertBalanceValue -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
<LI><a href="#[11760b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2iz (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
</UL>

<P><STRONG><a name="[1036480]"></a>ArrayToDWORD</STRONG> (Thumb, 112 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1036288]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>

<P><STRONG><a name="[1036404]"></a>ArrayToHWORD</STRONG> (Thumb, 56 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[108dd00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
</UL>

<P><STRONG><a name="[b0e2d4]"></a>Set_Prologic2Width</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = Set_Prologic2Width -> DSP_PLII_CENTER_WIDTH_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1074c1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION
<LI><a href="#[1074d34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
</UL>
<BR>[Called By]<UL><LI><a href="#[b11dc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC
<LI><a href="#[f21edc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkWidthSetup
</UL>

<P><STRONG><a name="[b0e3e0]"></a>Set_Prologic2Dimension</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = Set_Prologic2Dimension -> DSP_PLII_DIMENSION_CONFIGURATION -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1074b8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION
<LI><a href="#[1074d34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
</UL>
<BR>[Called By]<UL><LI><a href="#[b11eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM
<LI><a href="#[f2214c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkDimensionSetup
</UL>

<P><STRONG><a name="[b0e354]"></a>Set_Prologic2Panorama_On_Or_Off</STRONG> (Thumb, 66 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = Set_Prologic2Panorama_On_Or_Off -> DSP_PLII_CONTROL_REGISTER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1074cac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CONTROL_REGISTER
<LI><a href="#[1074d34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE
<LI><a href="#[1074db8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[b11e3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMP
<LI><a href="#[f21fd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkPanoramaSetup
</UL>

<P><STRONG><a name="[f16318]"></a>DspProcSpkMode</STRONG> (Thumb, 20 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = DspProcSpkMode -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[fbaf74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
</UL>
<BR>[Called By]<UL><LI><a href="#[f166f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspSpkMode
</UL>

<P><STRONG><a name="[f16504]"></a>DspProcDelay</STRONG> (Thumb, 312 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspProcDelay -> DSP_Delay_Channel_Setting -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fbb358]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f167e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspDelay
</UL>

<P><STRONG><a name="[f16580]"></a>DspProcCorner</STRONG> (Thumb, 98 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368<LI>Call Chain = DspProcCorner -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[fbaf74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f1676c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspCorner
</UL>

<P><STRONG><a name="[f16394]"></a>DspProcSignal</STRONG> (Thumb, 52 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspProcSignal -> DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1035784]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_ENABLE
<LI><a href="#[1035800]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE
</UL>
<BR>[Called By]<UL><LI><a href="#[f16674]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspSignal
</UL>

<P><STRONG><a name="[f1648c]"></a>DspProcIrc</STRONG> (Thumb, 206 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspProcIrc -> InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0f99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DacMute
<LI><a href="#[10353e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
<LI><a href="#[1035468]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Speaker_Select
<LI><a href="#[10354ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Dsp_IRC2_Control
<LI><a href="#[1035884]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Rx_Channel
<LI><a href="#[1035900]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_IRC1_Test_Duration
<LI><a href="#[1035cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[f165fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspIrc
</UL>

<P><STRONG><a name="[fcfbd4]"></a>SetDh2On</STRONG> (Thumb, 182 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = SetDh2On -> Change_DSP_VIRTUALIZER_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1035cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>
<BR>[Called By]<UL><LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[1036384]"></a>DspChannelOut5_1</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspChannelOut5_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10352d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[1035364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[fd0310]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
</UL>

<P><STRONG><a name="[1036304]"></a>DspChannelOut7_1</STRONG> (Thumb, 28 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10352d8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL_FOR_DSPB
<LI><a href="#[1035364]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;OS_OUTPUT_MODE_CONTROL
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fd0310]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOutSetting
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
<LI><a href="#[1036008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[fd0310]"></a>DspChannelOutSetting</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspChannelOutSetting -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1036304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1036384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[fd028c]"></a>DspLoadDefaultSetting</STRONG> (Thumb, 180 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 368 + Unknown Stack Size
<LI>Call Chain = DspLoadDefaultSetting -> SetBassManagerSpeaker -> C11SetBass -> DSP_BASS_X_INPUT_LEVEL_BACK -> ConvertDbValue -> pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[b0f5c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[b0fa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AV_Delay
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fbaf74]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetBassManagerSpeaker
<LI><a href="#[fbb2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[1035a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035a84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1035cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10801f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Firmware_Init
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[108dd00]"></a>ReadDsp</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = ReadDsp -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f68740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[1036404]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ArrayToHWORD
<LI><a href="#[1091564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f16410]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
<LI><a href="#[fd0210]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadTRUEHD
<LI><a href="#[ff2bd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
<LI><a href="#[ff2c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
<LI><a href="#[1026684]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadOS
<LI><a href="#[1035e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_DTS_HD_HRA_Read
<LI><a href="#[1035f04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDTSHDChannel
<LI><a href="#[10715b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolbyPLIIX
<LI><a href="#[107810c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadRegist
<LI><a href="#[1078188]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadCrossbar
<LI><a href="#[1078204]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDolby
<LI><a href="#[1080174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadDelay
<LI><a href="#[1097f14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_API_Read
<LI><a href="#[10d9924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspReadSgen
</UL>

<P><STRONG><a name="[1036288]"></a>CheckDspMessage</STRONG> (Thumb, 40 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 60<LI>Call Chain = CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[1036480]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ArrayToDWORD
<LI><a href="#[1091564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[a602a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
</UL>

<P><STRONG><a name="[a602a0]"></a>DspMasterBoot</STRONG> (Thumb, 50 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 68<LI>Call Chain = DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f68740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[f687b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[1036288]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckDspMessage
</UL>
<BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f16410]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[f16410]"></a>DspProcPower</STRONG> (Thumb, 146 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 76<LI>Call Chain = DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[a602a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspMasterBoot
<LI><a href="#[f687b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPHwReset
<LI><a href="#[1035c6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
</UL>
<BR>[Called By]<UL><LI><a href="#[f16860]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
</UL>

<P><STRONG><a name="[f393a4]"></a>DSPFirmwareWrite</STRONG> (Thumb, 96 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[fbac08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2SelectChannel
<LI><a href="#[10353e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
<LI><a href="#[1035784]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_ENABLE
<LI><a href="#[103618c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllMono
<LI><a href="#[1036208]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllStereo
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
<LI><a href="#[1088648]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode
</UL>

<P><STRONG><a name="[1036208]"></a>SetMixerAllStereo</STRONG> (Thumb, 240 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = SetMixerAllStereo -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>

<P><STRONG><a name="[103618c]"></a>SetMixerAllMono</STRONG> (Thumb, 178 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
</UL>

<P><STRONG><a name="[b0f63c]"></a>DspSetCrossbarEffect</STRONG> (Thumb, 74 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = DspSetCrossbarEffect -> SetMixerAllMono -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[1035cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[1035d7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[103618c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllMono
<LI><a href="#[1036208]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMixerAllStereo
</UL>
<BR>[Called By]<UL><LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[fd082c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[fd09a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
</UL>

<P><STRONG><a name="[b0f2dc]"></a>GetNormalFreq</STRONG> (Thumb, 6 bytes, Stack size 0 bytes, dspdrv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b118e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType
<LI><a href="#[fd09a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[fd0a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0a98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[fd0c0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[fd1454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[b0f6c0]"></a>DspDecodePcm</STRONG> (Thumb, 360 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspDecodePcm -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1035984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[1035afc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1035d7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[1036304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1036384]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E
<LI><a href="#[f50330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;lpcm_20_config
<LI><a href="#[fd0a1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0a98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[fd0c0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>

<P><STRONG><a name="[b0f7b8]"></a>DspDecodeAc3</STRONG> (Thumb, 728 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[103556c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
<LI><a href="#[1035984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[1035a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035a84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035afc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1036304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1078280]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_DRC_INIT
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b156b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EX
<LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF
<LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[fd0b90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[1036088]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
<LI><a href="#[103610c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[103610c]"></a>AC3_Cfg_Change_Deal</STRONG> (Thumb, 50 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = AC3_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f7b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
</UL>
<BR>[Called By]<UL><LI><a href="#[106c200]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseAc3Cfg
</UL>

<P><STRONG><a name="[106c200]"></a>AnalyseAc3Cfg</STRONG> (Thumb, 66 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseAc3Cfg -> AC3_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[103610c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AC3_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[1036088]"></a>TureHD_Cfg_Change_Deal</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = TureHD_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f7b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>
<BR>[Called By]<UL><LI><a href="#[106c008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseTureHDCfg
</UL>

<P><STRONG><a name="[106c008]"></a>AnalyseTureHDCfg</STRONG> (Thumb, 74 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseTureHDCfg -> TureHD_Cfg_Change_Deal -> DspDecodeAc3 -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1036088]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;TureHD_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[b0f73c]"></a>DspDecodeDTS</STRONG> (Thumb, 684 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[1035984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[1035a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035a84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035afc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[1035b78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[1035cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[1035d7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[1036304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b1599c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1ED
<LI><a href="#[fd08a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[fd0b14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[1035f84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
<LI><a href="#[1036008]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>

<P><STRONG><a name="[1036008]"></a>DTS_Cfg_Change_Deal</STRONG> (Thumb, 134 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DTS_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[1036304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
</UL>
<BR>[Called By]<UL><LI><a href="#[106c184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsCfg
</UL>

<P><STRONG><a name="[106c184]"></a>AnalyseDtsCfg</STRONG> (Thumb, 138 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 196<LI>Call Chain = AnalyseDtsCfg -> DTS_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1036008]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DTS_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[1035f84]"></a>DtsHD_Cfg_Change_Deal</STRONG> (Thumb, 42 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = DtsHD_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f73c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>
<BR>[Called By]<UL><LI><a href="#[106c108]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDtsHDCfg
</UL>

<P><STRONG><a name="[1035f04]"></a>DspReadDTSHDChannel</STRONG> (Thumb, 60 bytes, Stack size 8 bytes, dspdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[106c108]"></a>AnalyseDtsHDCfg</STRONG> (Thumb, 164 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 204<LI>Call Chain = AnalyseDtsHDCfg -> DtsHD_Cfg_Change_Deal -> DspDecodeDTS -> DspChannelOut7_1 -> OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1035f84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsHD_Cfg_Change_Deal
</UL>
<BR>[Called By]<UL><LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[106c088]"></a>AnalyseDtsHRACfg</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = AnalyseDtsHRACfg -> MsgSetStream -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
</UL>
<BR>[Called By]<UL><LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[1035e84]"></a>DSP_DTS_HD_HRA_Read</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dspdrv.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[f50330]"></a>lpcm_20_config</STRONG> (Thumb, 98 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 184 + Unknown Stack Size
<LI>Call Chain = lpcm_20_config -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1006f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
</UL>
<BR>[Called By]<UL><LI><a href="#[b424c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Timer0_Handler
</UL>

<P><STRONG><a name="[1035e00]"></a>ProcAutodetecResponse</STRONG> (Thumb, 1186 bytes, Stack size 24 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = ProcAutodetecResponse -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f6c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f16860]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDspPower
<LI><a href="#[fbad00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SoftMute
<LI><a href="#[fd0530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Input_Stream_Select
<LI><a href="#[fd1844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDSPSetting
<LI><a href="#[fd18c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetStream
<LI><a href="#[1006f08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Cs8416GetFreq
<LI><a href="#[1036304]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[106bf04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcUnsolicitedMsg
</UL>

<P><STRONG><a name="[106bf04]"></a>DspProcUnsolicitedMsg</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 208 + Unknown Stack Size
<LI>Call Chain = DspProcUnsolicitedMsg -> ProcAutodetecResponse -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[1035e00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse
</UL>
<BR>[Called By]<UL><LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg
</UL>

<P><STRONG><a name="[b0e558]"></a>SetLate</STRONG> (Thumb, 178 bytes, Stack size 16 bytes, dspdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = SetLate -> DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10355ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[1035670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[10356f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
<LI><a href="#[1078300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_BOOST_Y
<LI><a href="#[107837c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_CUT_X
<LI><a href="#[10783f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_AC3_COMPRESSION_CONTROL
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0fde4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASDD
<LI><a href="#[b15a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1C
<LI><a href="#[f228ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LateSetup
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[105b90c]"></a>CALC_EQ_FC</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CALC_EQ_FC</UL>
<BR>[Calls]<UL><LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[105b894]"></a>CALC_EQ_Q</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = CALC_EQ_Q</UL>
<BR>[Calls]<UL><LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[105b81c]"></a>CALC_EQ_G</STRONG> (Thumb, 68 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = CALC_EQ_G</UL>
<BR>[Calls]<UL><LI><a href="#[11723e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cfrcmple (via Veneer)
<LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[105b7a0]"></a>DSP_Eq_Control</STRONG> (Thumb, 146 bytes, Stack size 32 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[fbb2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
</UL>

<P><STRONG><a name="[105b724]"></a>DSP_Eq_Config</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[105b6a8]"></a>DSP_Eq_Channels</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[105b62c]"></a>DSP_Eq_Bands</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[105b5b0]"></a>DSP_Eq_Flash</STRONG> (Thumb, 142 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[105b528]"></a>DSP_EQ_CH_PREATTENUATION</STRONG> (Thumb, 222 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[105b4ac]"></a>DSP_EQ_POSTGAIN</STRONG> (Thumb, 226 bytes, Stack size 24 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[105b430]"></a>DSP_EQ_CHANGER</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_EQ_CHANGER -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
</UL>

<P><STRONG><a name="[b0f4c8]"></a>EqModuleconfig</STRONG> (Thumb, 452 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 164<LI>Call Chain = EqModuleconfig -> DSP_Eq_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[105b430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[105b7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
<LI><a href="#[105b81c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G
<LI><a href="#[105b894]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q
<LI><a href="#[105b90c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b15454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProtocolSetEq
<LI><a href="#[f22054]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkEqSetup
</UL>

<P><STRONG><a name="[105b3b0]"></a>DSP_Power_on_config</STRONG> (Thumb, 458 bytes, Stack size 24 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 156<LI>Call Chain = DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[b0f2dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetNormalFreq
<LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[105b430]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CHANGER
<LI><a href="#[105b81c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G
<LI><a href="#[105b894]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q
<LI><a href="#[105b90c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC
<LI><a href="#[1174a2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2f (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fbb2d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
</UL>

<P><STRONG><a name="[fbb2d4]"></a>DSP_EQ_Firmware_Init</STRONG> (Thumb, 112 bytes, Stack size 16 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 172<LI>Call Chain = DSP_EQ_Firmware_Init -> DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[105b3b0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config
<LI><a href="#[105b7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[b0fb00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChangeListenProfileMode
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[b0f454]"></a>EqOn</STRONG> (Thumb, 48 bytes, Stack size 8 bytes, eq_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 180<LI>Call Chain = EqOn -> DSP_EQ_Firmware_Init -> DSP_Power_on_config -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[fbb2d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_Firmware_Init
<LI><a href="#[105b7a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_Eq_Control
</UL>
<BR>[Called By]<UL><LI><a href="#[b14efc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EQ
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey
</UL>

<P><STRONG><a name="[105b338]"></a>DspReadEq</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, eq_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[f68740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
<LI><a href="#[1091564]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1052eac]"></a>Convert_8_24_Value</STRONG> (Thumb, 28 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Convert_8_24_Value</UL>
<BR>[Calls]<UL><LI><a href="#[1174200]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fmul (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[10353e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitMicParameter
</UL>

<P><STRONG><a name="[10353e8]"></a>InitMicParameter</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = InitMicParameter -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
<LI><a href="#[1052eac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value
</UL>
<BR>[Called By]<UL><LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1052e2c]"></a>DSP_IRC_1_Control</STRONG> (Thumb, 130 bytes, Stack size 16 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1035884]"></a>DSP_Rx_Channel</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_Rx_Channel -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1052db4]"></a>DSP_Rx_Gain</STRONG> (Thumb, 84 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1052d34]"></a>DSP_IRC1_Tx_Channel</STRONG> (Thumb, 80 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1035900]"></a>DSP_IRC1_Test_Duration</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_IRC1_Test_Duration -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1052cb0]"></a>DSP_IRC_1_Test_Signal</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[ff2c4c]"></a>DspReadIrc1</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2b58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSpkDistance
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue
<LI><a href="#[1052c30]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsIrc1ValidResult
</UL>

<P><STRONG><a name="[ff2b58]"></a>GetSpkDistance</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, irc1_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = GetSpkDistance -> DspReadIrc1 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff2c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
</UL>
<BR>[Called By]<UL><LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[1052c30]"></a>IsIrc1ValidResult</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, irc1_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[ff2c4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc1
</UL>

<P><STRONG><a name="[10354ec]"></a>Dsp_IRC2_Control</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = Dsp_IRC2_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[1035468]"></a>Dsp_IRC2_Speaker_Select</STRONG> (Thumb, 124 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = Dsp_IRC2_Speaker_Select -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
</UL>

<P><STRONG><a name="[104d12c]"></a>Dsp_IRC2_Max_EQ_Fc</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, irc2_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[ff2bd4]"></a>DspReadIrc2</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DspReadIrc2 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2ad8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsIrc2ValidResult
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[ff2ad8]"></a>IsIrc2ValidResult</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, irc2_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = IsIrc2ValidResult -> DspReadIrc2 -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[ff2bd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspReadIrc2
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[1035364]"></a>OS_OUTPUT_MODE_CONTROL</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, os_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = OS_OUTPUT_MODE_CONTROL -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1036304]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1036384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>

<P><STRONG><a name="[10352d8]"></a>OS_OUTPUT_MODE_CONTROL_FOR_DSPB</STRONG> (Thumb, 166 bytes, Stack size 40 bytes, os_manager.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 148<LI>Call Chain = OS_OUTPUT_MODE_CONTROL_FOR_DSPB -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1036304]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut7_1
<LI><a href="#[1036384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspChannelOut5_1
</UL>

<P><STRONG><a name="[1026790]"></a>OS_OUTPUT_MODE_CONTROL_Debug</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10266fc]"></a>OS_OUTPUT_MODE_CONTROL_FOR_DSPB_Debug</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1026684]"></a>DspReadOS</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, os_manager.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1035784]"></a>DSP_SGEN_ENABLE</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, signalgenerator.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 140<LI>Call Chain = DSP_SGEN_ENABLE -> DSPFirmwareWrite -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f393a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSPFirmwareWrite
</UL>
<BR>[Called By]<UL><LI><a href="#[f16394]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>

<P><STRONG><a name="[1035800]"></a>DSP_SGEN_CHANNEL_ENABLE</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, signalgenerator.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_SGEN_CHANNEL_ENABLE -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f16394]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcSignal
</UL>

<P><STRONG><a name="[10d999c]"></a>DSP_CHANNEL_SIGNAL_SELECT</STRONG> (Thumb, 222 bytes, Stack size 32 bytes, signalgenerator.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10d9924]"></a>DspReadSgen</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, signalgenerator.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10cd4b4]"></a>DSP_TRUEHD_Control</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10cd428]"></a>DSP_TRUEHD_Decode_Mode_Control</STRONG> (Thumb, 166 bytes, Stack size 16 bytes, dolbytruehd.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10355ec]"></a>DSP_TRUEHD_DRC_Control</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 116<LI>Call Chain = DSP_TRUEHD_DRC_Control -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[103556c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[1035670]"></a>DSP_TRUEHD_Cut_Scalefactor</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[103556c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[10356f8]"></a>DSP_TRUEHD_Boost_Scalefactor</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_TRUEHD_Boost_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[103556c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_INIT
</UL>

<P><STRONG><a name="[103556c]"></a>DSP_TRUEHD_DRC_INIT</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 132<LI>Call Chain = DSP_TRUEHD_DRC_INIT -> DSP_TRUEHD_Cut_Scalefactor -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[10355ec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_DRC_Control
<LI><a href="#[1035670]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Cut_Scalefactor
<LI><a href="#[10356f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Boost_Scalefactor
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
</UL>

<P><STRONG><a name="[fd0210]"></a>DspReadTRUEHD</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dolbytruehd.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DspReadTRUEHD -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
</UL>

<P><STRONG><a name="[1035bf4]"></a>DSP_BOOT</STRONG> (Thumb, 186 bytes, Stack size 24 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + In Cycle
<LI>Call Chain = DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fbb3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035cf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[1035d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[10c9de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
<LI><a href="#[10c9e68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[10ca06c]"></a>DSP_CFG_OUTPUT_FS</STRONG> (Thumb, 194 bytes, Stack size 16 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>

<P><STRONG><a name="[10c9fec]"></a>DSP_CFG_AUDIO_SRC</STRONG> (Thumb, 172 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_AUDIO_SRC -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fbb3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035cf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10c9de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
</UL>

<P><STRONG><a name="[1035b78]"></a>DSP_CFG_DECODER</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_DECODER -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[fbb3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035cf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>

<P><STRONG><a name="[1035afc]"></a>DSP_CFG_MATRIX</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_MATRIX -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
</UL>

<P><STRONG><a name="[1035984]"></a>DSP_CFG_VIRTUALIZER</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_VIRTUALIZER -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035cf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
</UL>

<P><STRONG><a name="[1035a84]"></a>DSP_CFG_PPM</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_PPM -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035cf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10c9e68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[1035a04]"></a>DSP_CFG_PPM_Mode</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_PPM_Mode -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035d7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_MATRIX_Code
<LI><a href="#[10c9e68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_PPM_Code
</UL>

<P><STRONG><a name="[10c9f68]"></a>DSP_CFG_PPM_Mode_Pl2x</STRONG> (Thumb, 82 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[10c9ee8]"></a>DSP_CFG_MCLK_FACTOR</STRONG> (Thumb, 168 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + In Cycle
<LI>Call Chain = DSP_CFG_MCLK_FACTOR -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[fbb3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source
<LI><a href="#[1035cf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_VIRTUALIZER_Code
<LI><a href="#[10c9de8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Update_Flash
</UL>

<P><STRONG><a name="[fbb3e0]"></a>Change_DSP_Decoder_Code</STRONG> (Thumb, 136 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Change_DSP_Decoder_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[1035b78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10c9ee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10c9fec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f22344]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SpkBlanceTestMode
<LI><a href="#[fb64e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupMenuProcBalance
</UL>

<P><STRONG><a name="[1035d7c]"></a>Change_DSP_MATRIX_Code</STRONG> (Thumb, 250 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Change_DSP_MATRIX_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[1035a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035afc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
</UL>

<P><STRONG><a name="[1035cf4]"></a>Change_DSP_VIRTUALIZER_Code</STRONG> (Thumb, 128 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = Change_DSP_VIRTUALIZER_Code -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[1035984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[1035a84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035b78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10c9ee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10c9fec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
</UL>
<BR>[Called By]<UL><LI><a href="#[b0f63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSetCrossbarEffect
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS
<LI><a href="#[f1648c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcIrc
<LI><a href="#[fcfbd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[fd028c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspLoadDefaultSetting
</UL>

<P><STRONG><a name="[10c9e68]"></a>Change_DSP_PPM_Code</STRONG> (Thumb, 62 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1035a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035a84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
</UL>

<P><STRONG><a name="[1035c6c]"></a>Change_Input_Audio_Source</STRONG> (Thumb, 414 bytes, Stack size 8 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = Change_Input_Audio_Source -> DSP_BOOT -> DspSpiWriteNByte (Cycle)</UL>
<BR>[Calls]<UL><LI><a href="#[b0f928]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DelayMs
<LI><a href="#[fd1070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[1035984]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_VIRTUALIZER
<LI><a href="#[1035a04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM_Mode
<LI><a href="#[1035a84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_PPM
<LI><a href="#[1035afc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MATRIX
<LI><a href="#[1035b78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_DECODER
<LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10c9ee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10c9fec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f16410]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcPower
</UL>

<P><STRONG><a name="[10c9de8]"></a>DSP_Update_Flash</STRONG> (Thumb, 36 bytes, Stack size 8 bytes, dsp_api.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1035bf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT
<LI><a href="#[10c9ee8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_MCLK_FACTOR
<LI><a href="#[10c9fec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC
</UL>

<P><STRONG><a name="[1097f14]"></a>DSP_API_Read</STRONG> (Thumb, 58 bytes, Stack size 16 bytes, dsp_api.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 124<LI>Call Chain = DSP_API_Read -> DspSpiWriteNByte -> SetDspPower -> DspProcPower -> DspMasterBoot -> CheckDspMessage -> DspSpiReadNByte -> ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[108dd00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ReadDsp
<LI><a href="#[10915e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>
<BR>[Called By]<UL><LI><a href="#[1098010]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HDMI_Busy
</UL>

<P><STRONG><a name="[103deb8]"></a>_printf_pre_padding</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, _printf_pad.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_pre_padding</UL>
<BR>[Calls]<UL><LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[1188350]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[1189ee4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[118a528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[118aa58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>

<P><STRONG><a name="[103de34]"></a>_printf_post_padding</STRONG> (Thumb, 36 bytes, Stack size 16 bytes, _printf_pad.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[1188350]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[1189ee4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[118a528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[118aa58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
</UL>

<P><STRONG><a name="[103d9c4]"></a>_printf_int_dec</STRONG> (Thumb, 98 bytes, Stack size 72 bytes, _printf_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 128 + Unknown Stack Size
<LI>Call Chain = _printf_int_dec -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[11862e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_udiv10 (via Veneer)
<LI><a href="#[1189ee4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[118ae60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
<LI><a href="#[118aeb0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_signed
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[103d32c]"></a>vsprintf</STRONG> (Thumb, 38 bytes, Stack size 16 bytes, vsprintf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 488 + Unknown Stack Size
<LI>Call Chain = vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1186c0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[11871bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f1e4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f1e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb6848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[fbac88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
</UL>

<P><STRONG><a name="[103c89c]"></a>__0sprintf</STRONG> (Thumb, 40 bytes, Stack size 32 bytes, __0sprintf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 504 + Unknown Stack Size
<LI>Call Chain = __0sprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1186c0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sputc
<LI><a href="#[11871bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay
</UL>

<P><STRONG><a name="[103c3c0]"></a>__aeabi_memset</STRONG> (ARM, 16 bytes, Stack size 0 bytes, aeabi_memset.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[11867e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank (via Veneer)
<LI><a href="#[b0dfec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank (via Veneer)
<LI><a href="#[b4281c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InitRemoteRepeatKey (via Veneer)
</UL>

<P><STRONG><a name="[103bf64]"></a>__aeabi_memcpy</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memcpy.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage (via Veneer)
<LI><a href="#[b14b34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN (via Veneer)
<LI><a href="#[b22094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage (via Veneer)
<LI><a href="#[b2210c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage (via Veneer)
<LI><a href="#[f22834]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;LogoSetup (via Veneer)
<LI><a href="#[f229a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InputNameSetup (via Veneer)
<LI><a href="#[106c27c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalyseDspMsg (via Veneer)
</UL>

<P><STRONG><a name="[103beec]"></a>__rt_memcpy</STRONG> (ARM, 212 bytes, Stack size 0 bytes, rt_memcpy.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[103b8f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memcpy4
</UL>

<P><STRONG><a name="[103bfb4]"></a>_memcpy_lastbytes</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy.o(.text), UNUSED)

<P><STRONG><a name="[103b8f0]"></a>__aeabi_memcpy4</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_memcpy4</UL>
<BR>[Called By]<UL><LI><a href="#[b0f16c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte (via Veneer)
<LI><a href="#[b0f544]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte (via Veneer)
<LI><a href="#[b0f5c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EepromReadByte (via Veneer)
<LI><a href="#[b0f8ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte (via Veneer)
<LI><a href="#[f4a180]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendByte (via Veneer)
<LI><a href="#[f4a1f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdSendNByte (via Veneer)
<LI><a href="#[fbb168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;HdmiSendByte (via Veneer)
<LI><a href="#[ff2e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display (via Veneer)
<LI><a href="#[1006f84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416ReadByte (via Veneer)
<LI><a href="#[1007000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Cs8416WriteByte (via Veneer)
<LI><a href="#[103beec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_memcpy
</UL>

<P><STRONG><a name="[103b940]"></a>__aeabi_memcpy8</STRONG> (ARM, 0 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[103b874]"></a>__rt_memcpy_w</STRONG> (ARM, 100 bytes, Stack size 8 bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[103b9bc]"></a>_memcpy_lastbytes_aligned</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memcpy_w.o(.text), UNUSED)

<P><STRONG><a name="[1181130]"></a>strncpy</STRONG> (ARM, 108 bytes, Stack size 8 bytes, strncpy.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strncpy</UL>
<BR>[Calls]<UL><LI><a href="#[1186790]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memclr
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp (via Veneer)
<LI><a href="#[fbac88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay (via Veneer)
</UL>

<P><STRONG><a name="[1180c8c]"></a>strlen</STRONG> (Thumb, 68 bytes, Stack size 8 bytes, strlen.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = strlen</UL>
<BR>[Called By]<UL><LI><a href="#[b0e06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[f1e4b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;rs232_printf
<LI><a href="#[f1e52c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[fb6848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdShowMenuOption
<LI><a href="#[fbac88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
<LI><a href="#[ff2e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SPK_Phase_Display
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ
<LI><a href="#[ff2f48]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetCrossoverPoints
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck
</UL>

<P><STRONG><a name="[118055c]"></a>__aeabi_idiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text), UNUSED)

<P><STRONG><a name="[118050c]"></a>__aeabi_idivmod</STRONG> (ARM, 364 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text))
<BR><BR>[Calls]<UL><LI><a href="#[118d0ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idiv0
</UL>
<BR>[Called By]<UL><LI><a href="#[a60228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage (via Veneer)
<LI><a href="#[b22094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage (via Veneer)
<LI><a href="#[b2210c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage (via Veneer)
<LI><a href="#[b22848]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsMsgQueueFull (via Veneer)
<LI><a href="#[f19fe8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetQueueElement (via Veneer)
<LI><a href="#[f1a168]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;InQueue (via Veneer)
<LI><a href="#[f1a1dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DeQueue (via Veneer)
<LI><a href="#[f1a2c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsQueueFull (via Veneer)
<LI><a href="#[f1a340]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsQueueEmpty (via Veneer)
<LI><a href="#[fd0c88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcAutoSeek (via Veneer)
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey (via Veneer)
<LI><a href="#[ff2a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value (via Veneer)
<LI><a href="#[ff2cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay (via Veneer)
<LI><a href="#[1188498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp (via Veneer)
<LI><a href="#[119caec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
</UL>

<P><STRONG><a name="[117d7bc]"></a>__use_two_region_memory</STRONG> (ARM, 4 bytes, Stack size 0 bytes, stkheap2.o(.text), UNUSED)

<P><STRONG><a name="[117d734]"></a>__rt_stackheap_init</STRONG> (ARM, 60 bytes, Stack size 24 bytes, stkheap2.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = __rt_stackheap_init -> __user_setup_stackheap</UL>
<BR>[Calls]<UL><LI><a href="#[118c1d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_storage
<LI><a href="#[118d530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>
<BR>[Called By]<UL><LI><a href="#[118deb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[117d6ac]"></a>__rt_heap_extend</STRONG> (ARM, 24 bytes, Stack size 8 bytes, stkheap2.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117d890]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[1171970]"></a>__ARM_switch8</STRONG> (ARM, 24 bytes, Stack size 0 bytes, switch8.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage (via Veneer)
<LI><a href="#[b0e254]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault (via Veneer)
<LI><a href="#[b0e464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkPhase (via Veneer)
<LI><a href="#[b0e558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetLate (via Veneer)
<LI><a href="#[b0f264]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetSrcName (via Veneer)
<LI><a href="#[b0f6c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodePcm (via Veneer)
<LI><a href="#[b0f73c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeDTS (via Veneer)
<LI><a href="#[b0f7b8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspDecodeAc3 (via Veneer)
<LI><a href="#[b118e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Rs232UpdateStreamType (via Veneer)
<LI><a href="#[b11d44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDEL (via Veneer)
<LI><a href="#[b11dc0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMC (via Veneer)
<LI><a href="#[b11eb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EMDIM (via Veneer)
<LI><a href="#[b14b34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdRSN (via Veneer)
<LI><a href="#[b14d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2S (via Veneer)
<LI><a href="#[b14e08]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone2Channel (via Veneer)
<LI><a href="#[b153d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsProtocolEqBandValid (via Veneer)
<LI><a href="#[b154d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1DF_ (via Veneer)
<LI><a href="#[b1563c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1E (via Veneer)
<LI><a href="#[b158a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1EF (via Veneer)
<LI><a href="#[b15c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1S (via Veneer)
<LI><a href="#[b15ce4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetZone1Channel (via Veneer)
<LI><a href="#[b15dd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPcmDecodeMode (via Veneer)
<LI><a href="#[f16504]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcDelay (via Veneer)
<LI><a href="#[f16580]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspProcCorner (via Veneer)
<LI><a href="#[f21790]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2InputSetup (via Veneer)
<LI><a href="#[f22e7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AnalogInSetup (via Veneer)
<LI><a href="#[f68d80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectMax335 (via Veneer)
<LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage (via Veneer)
<LI><a href="#[fb6174]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PwdKeyService (via Veneer)
<LI><a href="#[fb61f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetupLoadEeprom (via Veneer)
<LI><a href="#[fb62ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupRightKey (via Veneer)
<LI><a href="#[fb636c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcSetupLeftKey (via Veneer)
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[fb6a3c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuLoadCurOption (via Veneer)
<LI><a href="#[fbb25c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DacInvert (via Veneer)
<LI><a href="#[fbb358]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Channel_Setting (via Veneer)
<LI><a href="#[fbb3e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_DSP_Decoder_Code (via Veneer)
<LI><a href="#[fbb464]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ChanegName (via Veneer)
<LI><a href="#[fbb85c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetSpkDistance (via Veneer)
<LI><a href="#[fbba58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Phase_Relay (via Veneer)
<LI><a href="#[fbbad0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetCrossoverPointsMode (via Veneer)
<LI><a href="#[fbbbd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetDistanceMode (via Veneer)
<LI><a href="#[fd041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DECODE_MODE_STEREO (via Veneer)
<LI><a href="#[fd07b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey (via Veneer)
<LI><a href="#[fd0924]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey (via Veneer)
<LI><a href="#[fd12e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcInputSelect (via Veneer)
<LI><a href="#[fd1454]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;VfdUpdateStreamType (via Veneer)
<LI><a href="#[fd3b28]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcessKey (via Veneer)
<LI><a href="#[fdce94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcessKey (via Veneer)
<LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService (via Veneer)
<LI><a href="#[fffb44]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_PSD_Change (via Veneer)
<LI><a href="#[fffbc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;C11_Tuner_SIS_Change (via Veneer)
<LI><a href="#[1002950]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcDigitKey (via Veneer)
<LI><a href="#[10208f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectDSD (via Veneer)
<LI><a href="#[1035800]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SGEN_CHANNEL_ENABLE (via Veneer)
<LI><a href="#[1035bf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BOOT (via Veneer)
<LI><a href="#[1035c6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Change_Input_Audio_Source (via Veneer)
<LI><a href="#[1035e00]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcAutodetecResponse (via Veneer)
<LI><a href="#[105b4ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_POSTGAIN (via Veneer)
<LI><a href="#[105b528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_EQ_CH_PREATTENUATION (via Veneer)
<LI><a href="#[1071634]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_DIMENSION_CONFIGURATION (via Veneer)
<LI><a href="#[10716c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLIIx_CENTER_WIDTH_CONFIGURATION (via Veneer)
<LI><a href="#[1074b8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DIMENSION_CONFIGURATION (via Veneer)
<LI><a href="#[1074c1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_CENTER_WIDTH_CONFIGURATION (via Veneer)
<LI><a href="#[1074d34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_PLII_DECODE_MODE (via Veneer)
<LI><a href="#[10803f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Delay_Max_Setting (via Veneer)
<LI><a href="#[1088648]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConfigSpkMode (via Veneer)
<LI><a href="#[108886c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_BACK (via Veneer)
<LI><a href="#[10888f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_X_INPUT_LEVEL_FRONT (via Veneer)
<LI><a href="#[1088980]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_SUM5_INPUT_LEVLE (via Veneer)
<LI><a href="#[1088d40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_LFE_OUTPUT_LEVEL (via Veneer)
<LI><a href="#[1088dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_BASS_INPUT_LEVEL (via Veneer)
<LI><a href="#[1088e4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_SET_BASS_CORNER (via Veneer)
<LI><a href="#[10c9fec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_AUDIO_SRC (via Veneer)
<LI><a href="#[10ca06c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CFG_OUTPUT_FS (via Veneer)
<LI><a href="#[10cd428]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_TRUEHD_Decode_Mode_Control (via Veneer)
<LI><a href="#[10d999c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_CHANNEL_SIGNAL_SELECT (via Veneer)
</UL>

<P><STRONG><a name="[11718f4]"></a>__rt_switch8</STRONG> (ARM, 0 bytes, Stack size 0 bytes, switch8.o(.text), UNUSED)

<P><STRONG><a name="[11714e8]"></a>__ARM_call_via_r0</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60488]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;main
<LI><a href="#[f75c58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[f75e40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
</UL>

<P><STRONG><a name="[1171538]"></a>__call_via_r0</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[117141c]"></a>__ARM_call_via_r1</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b426a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcMessage
<LI><a href="#[f75c58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_readbyte
<LI><a href="#[f75cd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[f75d50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_stop
<LI><a href="#[f75dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_start
<LI><a href="#[f75e40]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[f8d3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundProcMessage
<LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[117146c]"></a>__call_via_r1</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[119116c]"></a>__ARM_call_via_r2</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[b0fc7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcRs232Msg
<LI><a href="#[103de34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[103deb8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[1188350]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
<LI><a href="#[1189ee4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[118a528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[1197bbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_outstr_char
<LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11713a0]"></a>__call_via_r2</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[11910a0]"></a>__ARM_call_via_r3</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f75f80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;load_default_option
<LI><a href="#[f76000]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;execute_curr_option
<LI><a href="#[f76080]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;write_curr_option
<LI><a href="#[f76100]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_curr_option
<LI><a href="#[fb6abc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Inquire_restrict_option
<LI><a href="#[118aa58]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[11973e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
<LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11910f0]"></a>__call_via_r3</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190fa4]"></a>__ARM_call_via_r4</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1191024]"></a>__call_via_r4</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190ea8]"></a>__ARM_call_via_r5</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190f28]"></a>__call_via_r5</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190dac]"></a>__ARM_call_via_r6</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190e2c]"></a>__call_via_r6</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190cb0]"></a>__ARM_call_via_r7</STRONG> (Thumb, 2 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[1190d30]"></a>__call_via_r7</STRONG> (Thumb, 0 bytes, Stack size unknown bytes, callvia.o(.text), UNUSED)

<P><STRONG><a name="[119054c]"></a>pow</STRONG> (ARM, 3604 bytes, Stack size 216 bytes, pow.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 256<LI>Call Chain = pow -> __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[1173550]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdrcmple
<LI><a href="#[1179180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[11799ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_i2d
<LI><a href="#[117aa10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ddiv
<LI><a href="#[117bc4c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dsub
<LI><a href="#[117bd10]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_drsub
<LI><a href="#[117be00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
<LI><a href="#[1181844]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
<LI><a href="#[1182d2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scalbn
<LI><a href="#[118b400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[1190458]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;copysign
<LI><a href="#[11a0de0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>
<BR>[Called By]<UL><LI><a href="#[108905c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
<LI><a href="#[11904d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__softfp_pow
</UL>

<P><STRONG><a name="[11904d0]"></a>__softfp_pow</STRONG> (ARM, 4 bytes, Stack size 0 bytes, pow.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[119054c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[118deb0]"></a>__rt_entry</STRONG> (ARM, 76 bytes, Stack size 16 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 68 + Unknown Stack Size
<LI>Call Chain = __rt_entry -> __rt_lib_init -> _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[117d734]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
<LI><a href="#[1191230]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_lib_init
<LI><a href="#[1191684]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_platform_post_stackheap_init
<LI><a href="#[1192dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
<LI><a href="#[1196490]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;exit (via BX)
</UL>
<BR>[Called By]<UL><LI><a href="#[10ee508]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__scatterload_rt2
<LI><a href="#[117d07c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__main
</UL>

<P><STRONG><a name="[118dd68]"></a>__rt_exit</STRONG> (ARM, 20 bytes, Stack size 8 bytes, kernel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __rt_exit -> __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[1192d78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1196490]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (via Veneer)
</UL>

<P><STRONG><a name="[118dcf0]"></a>__rt_abort</STRONG> (ARM, 8 bytes, Stack size 0 bytes, kernel.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11a07bc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_sys_exit
</UL>

<P><STRONG><a name="[118d530]"></a>__user_setup_stackheap</STRONG> (ARM, 96 bytes, Stack size 8 bytes, sys_stackheap_outer.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = __user_setup_stackheap</UL>
<BR>[Calls]<UL><LI><a href="#[a664e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_initial_stackheap
<LI><a href="#[11a02e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__user_perproc_libspace
</UL>
<BR>[Called By]<UL><LI><a href="#[117d734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[118d0ac]"></a>__aeabi_idiv0</STRONG> (ARM, 4 bytes, Stack size 0 bytes, aeabi_idiv0.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[118050c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod
</UL>

<P><STRONG><a name="[118c1d4]"></a>__rt_stackheap_storage</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_stackheap_storage_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[117d734]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_stackheap_init
</UL>

<P><STRONG><a name="[118b450]"></a>__read_errno</STRONG> (Thumb, 18 bytes, Stack size 8 bytes, _rserrno.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr (via Veneer)
</UL>

<P><STRONG><a name="[118b400]"></a>__set_errno</STRONG> (Thumb, 16 bytes, Stack size 8 bytes, _rserrno.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __set_errno</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_errno_addr (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow (via Veneer)
<LI><a href="#[11a0de0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt (via Veneer)
</UL>

<P><STRONG><a name="[118aeb0]"></a>_printf_truncate_signed</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, _printf_truncate.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d9c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
</UL>

<P><STRONG><a name="[118ae60]"></a>_printf_truncate_unsigned</STRONG> (Thumb, 22 bytes, Stack size 0 bytes, _printf_truncate.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d9c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[11892cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[11898a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>

<P><STRONG><a name="[118aa58]"></a>_printf_str</STRONG> (Thumb, 94 bytes, Stack size 16 bytes, _printf_str.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32 + Unknown Stack Size
<LI>Call Chain = _printf_str -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[103de34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[103deb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[118a528]"></a>_printf_wctomb</STRONG> (Thumb, 190 bytes, Stack size 56 bytes, _printf_wctomb.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80 + Unknown Stack Size
<LI>Call Chain = _printf_wctomb -> _wcrtomb -> __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[103de34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[103deb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[11973e0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1189ee4]"></a>_printf_int_common</STRONG> (Thumb, 168 bytes, Stack size 40 bytes, _printf_intcommon.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56 + Unknown Stack Size
<LI>Call Chain = _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[103de34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[103deb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[103d9c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[1188e24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[11892cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[11898a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
</UL>

<P><STRONG><a name="[11898a8]"></a>_printf_longlong_hex</STRONG> (Thumb, 182 bytes, Stack size 88 bytes, _printf_longlong_hex.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 144 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_hex -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1189ee4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[118ae60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[11892cc]"></a>_printf_longlong_oct</STRONG> (Thumb, 138 bytes, Stack size 64 bytes, _printf_longlong_oct.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_oct -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1189ee4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[118ae60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_truncate_unsigned
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1188e24]"></a>_printf_longlong_dec</STRONG> (Thumb, 124 bytes, Stack size 80 bytes, _printf_longlong_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 136 + Unknown Stack Size
<LI>Call Chain = _printf_longlong_dec -> _printf_int_common -> _printf_post_padding</UL>
<BR>[Calls]<UL><LI><a href="#[1189ee4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_common
<LI><a href="#[119d10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[118890c]"></a>_printf_charcount</STRONG> (Thumb, 36 bytes, Stack size 0 bytes, _printf_charcount.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>

<P><STRONG><a name="[1188418]"></a>__lib_sel_fp_printf</STRONG> (Thumb, 2 bytes, Stack size 0 bytes, _printf_fp_dec.o(.text), UNUSED)

<P><STRONG><a name="[11883a0]"></a>_fp_display</STRONG> (Thumb, 806 bytes, Stack size 64 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 280<LI>Call Chain = _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1188498]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp
<LI><a href="#[1188510]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
<LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119ddbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[11af420]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__mathlib_classify (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1188350]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real
</UL>

<P><STRONG><a name="[1188350]"></a>_printf_fp_dec_real</STRONG> (Thumb, 234 bytes, Stack size 56 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[103de34]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_post_padding
<LI><a href="#[103deb8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_pre_padding
<LI><a href="#[11883a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_display
<LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Called By]<UL><LI><a href="#[1171e38]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec (via Veneer)
</UL>

<P><STRONG><a name="[11871bc]"></a>_printf_char_common</STRONG> (Thumb, 44 bytes, Stack size 88 bytes, _printf_char_common.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 472 + Unknown Stack Size
<LI>Call Chain = _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1198fbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__printf
</UL>
<BR>[Called By]<UL><LI><a href="#[103c89c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[103d32c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>

<P><STRONG><a name="[1186c0c]"></a>_sputc</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, _sputc.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103c89c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__0sprintf
<LI><a href="#[103d32c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;vsprintf
</UL>
<BR>[Address Reference Count : 2]<UL><LI> __0sprintf.o(.text)
<LI> vsprintf.o(.text)
</UL>
<P><STRONG><a name="[1186790]"></a>__aeabi_memclr</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1181130]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;strncpy
</UL>

<P><STRONG><a name="[1186718]"></a>__rt_memclr</STRONG> (ARM, 64 bytes, Stack size 0 bytes, rt_memclr.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1195fc4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_memset_w
</UL>

<P><STRONG><a name="[11867e0]"></a>_memset</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103c3c0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_memset
</UL>

<P><STRONG><a name="[11862e8]"></a>__rt_udiv10</STRONG> (ARM, 44 bytes, Stack size 0 bytes, rtudiv10.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[103d9c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec (via Veneer)
</UL>

<P><STRONG><a name="[1181844]"></a>__kernel_poly</STRONG> (ARM, 248 bytes, Stack size 24 bytes, poly.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40<LI>Call Chain = __kernel_poly -> __aeabi_dmul</UL>
<BR>[Calls]<UL><LI><a href="#[1179180]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dmul
<LI><a href="#[117be00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_dadd
</UL>
<BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11a0de0]"></a>sqrt</STRONG> (ARM, 100 bytes, Stack size 16 bytes, sqrt.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 32<LI>Call Chain = sqrt -> _dsqrt</UL>
<BR>[Calls]<UL><LI><a href="#[1173b00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_cdcmple
<LI><a href="#[118b400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[11b08d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsqrt
</UL>
<BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[11a0d64]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__softfp_sqrt
</UL>

<P><STRONG><a name="[11a0d64]"></a>__softfp_sqrt</STRONG> (ARM, 4 bytes, Stack size 0 bytes, sqrt.o(.text), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11a0de0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[11a07bc]"></a>_sys_exit</STRONG> (ARM, 20 bytes, Stack size 0 bytes, sys_exit.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[118dcf0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_abort
</UL>

<P><STRONG><a name="[11a01b8]"></a>__user_libspace</STRONG> (ARM, 8 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[11a02e0]"></a>__user_perproc_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[118d530]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__user_setup_stackheap
</UL>

<P><STRONG><a name="[11a0258]"></a>__user_perthread_libspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, libspace.o(.text), UNUSED)

<P><STRONG><a name="[119f16c]"></a>__aeabi_errno_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_errno_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[118b400]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__set_errno (via Veneer)
<LI><a href="#[118b450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__read_errno (via Veneer)
</UL>

<P><STRONG><a name="[119f1f8]"></a>__rt_errno_addr_intlibspace</STRONG> (ARM, 0 bytes, Stack size 0 bytes, rt_errno_addr_intlibspace.o(.text), UNUSED)

<P><STRONG><a name="[119ddbc]"></a>__rt_locale</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_locale_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11883a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (via Veneer)
<LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
<LI><a href="#[11ae664]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table
</UL>

<P><STRONG><a name="[119d10c]"></a>_ll_udiv10</STRONG> (ARM, 160 bytes, Stack size 12 bytes, lludiv10.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _ll_udiv10</UL>
<BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
<LI><a href="#[1188e24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec (via Veneer)
</UL>

<P><STRONG><a name="[119caec]"></a>_btod_etento</STRONG> (Thumb, 202 bytes, Stack size 72 bytes, bigflt0.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 120<LI>Call Chain = _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119bb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul (via Veneer)
<LI><a href="#[119bba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits
</UL>

<P><STRONG><a name="[1198fbc]"></a>__printf</STRONG> (Thumb, 740 bytes, Stack size 48 bytes, __printf.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 384 + Unknown Stack Size
<LI>Call Chain = __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[103d9c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_int_dec
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[1171e38]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec (via Veneer)
<LI><a href="#[11825ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_hex (via Veneer)
<LI><a href="#[118890c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_charcount
<LI><a href="#[1188e24]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_dec
<LI><a href="#[11892cc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_oct
<LI><a href="#[11898a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_longlong_hex
<LI><a href="#[118a528]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
<LI><a href="#[118aa58]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_str
<LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
<LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
<LI><a href="#[1198ec8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_wc (Weak Reference)
<LI><a href="#[1198f40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_mbtowc (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11871bc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_char_common
</UL>

<P><STRONG><a name="[1197bbc]"></a>_printf_outstr_char</STRONG> (Thumb, 32 bytes, Stack size 16 bytes, _printf_outstr_char.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = _printf_outstr_char</UL>
<BR>[Calls]<UL><LI><a href="#[119116c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r2
</UL>
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[11977c0]"></a>_printf_input_char</STRONG> (Thumb, 10 bytes, Stack size 0 bytes, _printf_input_char.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> _printf_char_common.o(.text)
</UL>
<P><STRONG><a name="[11973e0]"></a>_wcrtomb</STRONG> (Thumb, 78 bytes, Stack size 16 bytes, _wcrtomb.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = _wcrtomb -> __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11910a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r3
<LI><a href="#[11ae664]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_ctype_table (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[118a528]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_wctomb
</UL>

<P><STRONG><a name="[1196a78]"></a>_get_lc_numeric</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, lc_numeric_c.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11ad400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>

<P><STRONG><a name="[1196490]"></a>exit</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, exit.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = exit -> __rt_exit -> __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[118dd68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
<LI><a href="#[11963c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_call_atexit_fns (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[118deb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[1195ecc]"></a>__aeabi_memclr4</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[1195f48]"></a>__aeabi_memclr8</STRONG> (ARM, 0 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[1195e50]"></a>__rt_memclr_w</STRONG> (ARM, 84 bytes, Stack size 4 bytes, rt_memclr_w.o(.text), UNUSED)

<P><STRONG><a name="[1195fc4]"></a>_memset_w</STRONG> (ARM, 0 bytes, Stack size unknown bytes, rt_memclr_w.o(.text), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1186718]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_memclr
</UL>

<P><STRONG><a name="[1192dc8]"></a>__rt_lib_init</STRONG> (Thumb, 188 bytes, Stack size 40 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 52<LI>Call Chain = __rt_lib_init -> _get_lc_numeric -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119243c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_signal_init (Weak Reference)
<LI><a href="#[11924b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_rand_init (Weak Reference)
<LI><a href="#[1192530]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_initio (Weak Reference)
<LI><a href="#[11925a4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_user_alloc (Weak Reference)
<LI><a href="#[1192624]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_init_alloc (Weak Reference)
<LI><a href="#[119269c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_getenv_init (Weak Reference)
<LI><a href="#[1192718]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_time (Weak Reference)
<LI><a href="#[1192794]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_monetary (Weak Reference)
<LI><a href="#[1192890]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_collate (Weak Reference)
<LI><a href="#[119290c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_trap_init (Weak Reference)
<LI><a href="#[1192988]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_clock_init (Weak Reference)
<LI><a href="#[1192a00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_atexit_init (Weak Reference)
<LI><a href="#[1192af8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cpp_initialize__aeabi_ (Weak Reference)
<LI><a href="#[1192b80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__alloca_initialize (Weak Reference)
<LI><a href="#[1192c00]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__Heap_DescSize (Weak Reference)
<LI><a href="#[1192c7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_exceptions_init (Weak Reference)
<LI><a href="#[1192e94]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_argv_veneer (via Veneer)
<LI><a href="#[1196a78]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric
<LI><a href="#[119ddbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale (via Veneer)
<LI><a href="#[11a89a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype
<LI><a href="#[11ab63c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fp_init (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[118deb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry (via Veneer)
</UL>

<P><STRONG><a name="[1192d78]"></a>__rt_lib_shutdown</STRONG> (Thumb, 26 bytes, Stack size 8 bytes, lib_init.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_lib_shutdown</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119233c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminateio (Weak Reference)
<LI><a href="#[11923b8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_terminate_user_alloc (Weak Reference)
<LI><a href="#[1192a7c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__cxa_finalize (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[118dd68]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_exit (via Veneer)
</UL>

<P><STRONG><a name="[1191684]"></a>_platform_post_stackheap_init</STRONG> (ARM, 12 bytes, Stack size 0 bytes, boardinit2.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[118deb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[1191230]"></a>_platform_post_lib_init</STRONG> (ARM, 16 bytes, Stack size 8 bytes, boardinit3.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _platform_post_lib_init</UL>
<BR>[Called By]<UL><LI><a href="#[118deb0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_entry
</UL>

<P><STRONG><a name="[11af420]"></a>__mathlib_classify</STRONG> (ARM, 56 bytes, Stack size 8 bytes, classify.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __mathlib_classify</UL>
<BR>[Calls]<UL><LI><a href="#[11ab0d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_fpclassify
</UL>
<BR>[Called By]<UL><LI><a href="#[11883a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (via Veneer)
</UL>

<P><STRONG><a name="[11aef5c]"></a>__support_dtoi</STRONG> (ARM, 96 bytes, Stack size 16 bytes, dtoi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __support_dtoi</UL>
<BR>[Calls]<UL><LI><a href="#[1182d2c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;scalbn
</UL>
<BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[11aeac8]"></a>__I_use_semihosting</STRONG> (ARM, 0 bytes, Stack size 0 bytes, use_no_semi.o(.text))
<BR>[Address Reference Count : 1]<UL><LI> sys_exit.o(.text)
</UL>
<P><STRONG><a name="[11aea40]"></a>__use_no_semihosting_swi</STRONG> (ARM, 4 bytes, Stack size 0 bytes, use_no_semi.o(.text), UNUSED)

<P><STRONG><a name="[11ae664]"></a>__rt_ctype_table</STRONG> (ARM, 24 bytes, Stack size 8 bytes, rt_ctype_table.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __rt_ctype_table</UL>
<BR>[Calls]<UL><LI><a href="#[119ddbc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_locale
</UL>
<BR>[Called By]<UL><LI><a href="#[11973e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb (via Veneer)
</UL>

<P><STRONG><a name="[11ad400]"></a>strcmp</STRONG> (ARM, 156 bytes, Stack size 4 bytes, strcmp.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = strcmp</UL>
<BR>[Called By]<UL><LI><a href="#[1196a78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (via Veneer)
<LI><a href="#[11a89a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (via Veneer)
</UL>

<P><STRONG><a name="[11aba50]"></a>__ARM_get_argv</STRONG> (Thumb, 6 bytes, Stack size 4 bytes, no_argv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __ARM_get_argv</UL>
<BR>[Address Reference Count : 1]<UL><LI> lib_init.o(.emb_text)
</UL>
<P><STRONG><a name="[11ab0d4]"></a>__ARM_fpclassify</STRONG> (ARM, 44 bytes, Stack size 0 bytes, fpclassify.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11af420]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__mathlib_classify
</UL>

<P><STRONG><a name="[11a9dd0]"></a>__rt_fp_status_addr</STRONG> (ARM, 12 bytes, Stack size 0 bytes, rt_fp_status_addr_intlibspace.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[11ab63c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_init
</UL>

<P><STRONG><a name="[11a89a8]"></a>_get_lc_ctype</STRONG> (Thumb, 40 bytes, Stack size 8 bytes, lc_ctype_c.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 12<LI>Call Chain = _get_lc_ctype -> strcmp</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[11ad400]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;strcmp (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init
</UL>
<BR>[Address Reference Count : 1]<UL><LI> rt_ctype_table.o(.text)
</UL>
<P><STRONG><a name="[1180490]"></a>__aeabi_uidiv</STRONG> (ARM, 0 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv), UNUSED)

<P><STRONG><a name="[1180440]"></a>__aeabi_uidivmod</STRONG> (ARM, 28 bytes, Stack size 0 bytes, aeabi_sdiv.o(.text_udiv))
<BR><BR>[Calls]<UL><LI><a href="#[11806f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div_large
<LI><a href="#[1180770]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div8
<LI><a href="#[11807e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__arm_div4
</UL>
<BR>[Called By]<UL><LI><a href="#[b0e744]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SaveFmPreset (via Veneer)
<LI><a href="#[b103a4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTT_ (via Veneer)
<LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage (via Veneer)
<LI><a href="#[fdb7c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Tuner_Write_Freq_Command (via Veneer)
<LI><a href="#[fffcc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd (via Veneer)
<LI><a href="#[ffffbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioDisplay (via Veneer)
<LI><a href="#[1010404]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetUart1Baudrate (via Veneer)
<LI><a href="#[1010574]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetUart0Baudrate (via Veneer)
</UL>

<P><STRONG><a name="[119bbf4]"></a>_btod_d2e</STRONG> (ARM, 56 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e))
<BR><BR>[Calls]<UL><LI><a href="#[119bad8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>
<BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[119ba5c]"></a>_d2e_denorm_low</STRONG> (ARM, 84 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e_denorm_low))
<BR><BR>[Called By]<UL><LI><a href="#[119bad8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2e_norm_op1
</UL>

<P><STRONG><a name="[119bad8]"></a>_d2e_norm_op1</STRONG> (ARM, 104 bytes, Stack size 0 bytes, btod.o(CL$$btod_d2e_norm_op1))
<BR><BR>[Calls]<UL><LI><a href="#[119ba5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_d2e_denorm_low
</UL>
<BR>[Called By]<UL><LI><a href="#[119bbf4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e
</UL>

<P><STRONG><a name="[119b784]"></a>__btod_div_common</STRONG> (ARM, 716 bytes, Stack size 24 bytes, btod.o(CL$$btod_div_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = __btod_div_common</UL>
<BR>[Called By]<UL><LI><a href="#[119bba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[119b8f8]"></a>_e2e</STRONG> (ARM, 220 bytes, Stack size 24 bytes, btod.o(CL$$btod_e2e))
<BR><BR>[Stack]<UL><LI>Max Depth = 24<LI>Call Chain = _e2e</UL>
<BR>[Called By]<UL><LI><a href="#[119bb54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
<LI><a href="#[119bba4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv
</UL>

<P><STRONG><a name="[119bba4]"></a>_btod_ediv</STRONG> (ARM, 52 bytes, Stack size 24 bytes, btod.o(CL$$btod_ediv))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _btod_ediv -> __btod_div_common</UL>
<BR>[Calls]<UL><LI><a href="#[119b784]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_div_common
<LI><a href="#[119b8f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
<LI><a href="#[119caec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
</UL>

<P><STRONG><a name="[119bb54]"></a>_btod_emul</STRONG> (ARM, 52 bytes, Stack size 24 bytes, btod.o(CL$$btod_emul))
<BR><BR>[Stack]<UL><LI>Max Depth = 48<LI>Call Chain = _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[119b804]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__btod_mult_common
<LI><a href="#[119b8f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_e2e
</UL>
<BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
<LI><a href="#[119caec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (via Veneer)
</UL>

<P><STRONG><a name="[119b804]"></a>__btod_mult_common</STRONG> (ARM, 616 bytes, Stack size 16 bytes, btod.o(CL$$btod_mult_common))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __btod_mult_common</UL>
<BR>[Called By]<UL><LI><a href="#[119bb54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_emul
</UL>

<P><STRONG><a name="[1190458]"></a>copysign</STRONG> (ARM, 16 bytes, Stack size 0 bytes, pow.o(i.copysign))
<BR><BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[117c904]"></a>__aeabi_d2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, d2f.o(x$fpl$d2f))
<BR><BR>[Called By]<UL><LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[108905c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[117c890]"></a>_d2f</STRONG> (ARM, 168 bytes, Stack size 0 bytes, d2f.o(x$fpl$d2f), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11856fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>

<P><STRONG><a name="[117c954]"></a>__fpl_inf_d2f</STRONG> (ARM, 0 bytes, Stack size unknown bytes, d2f.o(x$fpl$d2f), UNUSED)

<P><STRONG><a name="[117be00]"></a>__aeabi_dadd</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dadd))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_dadd</UL>
<BR>[Called By]<UL><LI><a href="#[1181844]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
<LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[117bd8c]"></a>_dadd</STRONG> (ARM, 452 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1185c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[117bef8]"></a>__fpl_inf_dadd</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)

<P><STRONG><a name="[1185c14]"></a>__fpl_dcheck_NaN2</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dcheck.o(x$fpl$dcheck), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b021c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[117910c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dmul
<LI><a href="#[117a99c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv
<LI><a href="#[117bbd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[117bd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd
<LI><a href="#[118525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[11856fc]"></a>__fpl_dcheck_NaN1</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dcheck1.o(x$fpl$dcheck1))
<BR><BR>[Calls]<UL><LI><a href="#[11b021c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[117c890]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2f
<LI><a href="#[1182d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;scalbn
<LI><a href="#[11b08d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsqrt
</UL>

<P><STRONG><a name="[118525c]"></a>__fpl_dcmp_InfNaN</STRONG> (ARM, 128 bytes, Stack size 4 bytes, dcmpin.o(x$fpl$dcmpinfnan), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1185c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
<LI><a href="#[11afd20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[11734d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drcmple
<LI><a href="#[1173a8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dcmple
</UL>

<P><STRONG><a name="[1185164]"></a>__fpl_inf_dcmp</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dcmpin.o(x$fpl$dcmpinfnan), UNUSED)

<P><STRONG><a name="[1183d18]"></a>__fpl_fcmp_InfNaN</STRONG> (ARM, 100 bytes, Stack size 0 bytes, fcmpin.o(x$fpl$dcmpinfnan), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
<LI><a href="#[11afd20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[117236c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_frcmple
<LI><a href="#[1172904]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fcmple
<LI><a href="#[1172e90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fcmpeq
</UL>

<P><STRONG><a name="[1183c9c]"></a>__fpl_inf_fcmp</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fcmpin.o(x$fpl$dcmpinfnan), UNUSED)

<P><STRONG><a name="[117aa10]"></a>__aeabi_ddiv</STRONG> (ARM, 0 bytes, Stack size 16 bytes, ddiv.o(x$fpl$ddiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_ddiv</UL>
<BR>[Called By]<UL><LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[117a99c]"></a>_ddiv</STRONG> (ARM, 464 bytes, Stack size 16 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117a920]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ddiv_mantissas
<LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1185c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[117aad4]"></a>__fpl_inf_ddiv</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ddiv.o(x$fpl$ddiv), UNUSED)

<P><STRONG><a name="[117a920]"></a>_ddiv_mantissas</STRONG> (ARM, 608 bytes, Stack size 28 bytes, ddiv.o(x$fpl$ddiv), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[117a99c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv
</UL>

<P><STRONG><a name="[11799ac]"></a>__aeabi_i2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dflt))
<BR><BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[1179938]"></a>_dflt</STRONG> (ARM, 88 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dflt), UNUSED)

<P><STRONG><a name="[1179ae8]"></a>__dflt_normalise</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dflt_noclz.o(x$fpl$dflt), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1179a24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dfltu
</UL>

<P><STRONG><a name="[1179a98]"></a>__aeabi_ui2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dfltu))
<BR><BR>[Called By]<UL><LI><a href="#[f678e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[f67960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
</UL>

<P><STRONG><a name="[1179a24]"></a>_dfltu</STRONG> (ARM, 12 bytes, Stack size 0 bytes, dflt_noclz.o(x$fpl$dfltu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1179ae8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__dflt_normalise
</UL>

<P><STRONG><a name="[1173b00]"></a>__aeabi_cdcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, dleqf.o(x$fpl$dleqf))
<BR><BR>[Called By]<UL><LI><a href="#[b11404]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[b146f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[b15354]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[f678e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[f67960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
<LI><a href="#[11a0de0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[1173a8c]"></a>_dcmple</STRONG> (ARM, 132 bytes, Stack size 0 bytes, dleqf.o(x$fpl$dleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[118525c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[1179180]"></a>__aeabi_dmul</STRONG> (ARM, 0 bytes, Stack size 16 bytes, dmul.o(x$fpl$dmul))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = __aeabi_dmul</UL>
<BR>[Called By]<UL><LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[1181844]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__kernel_poly
<LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[117910c]"></a>_dmul</STRONG> (ARM, 460 bytes, Stack size 16 bytes, dmul.o(x$fpl$dmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1185c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[11791d0]"></a>__fpl_inf_dmul</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dmul.o(x$fpl$dmul), UNUSED)

<P><STRONG><a name="[1173550]"></a>__aeabi_cdrcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, drleqf.o(x$fpl$drleqf))
<BR><BR>[Called By]<UL><LI><a href="#[b11404]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[b15354]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[f678e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir_core_philips (via Veneer)
<LI><a href="#[f67960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ir2_core_philips (via Veneer)
<LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[11734d8]"></a>_drcmple</STRONG> (ARM, 156 bytes, Stack size 0 bytes, drleqf.o(x$fpl$drleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[118525c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
</UL>

<P><STRONG><a name="[117bd10]"></a>__aeabi_drsub</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$drsb))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_drsub</UL>
<BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[117bc9c]"></a>_drsb</STRONG> (ARM, 24 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$drsb), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dsub1
<LI><a href="#[117c2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
</UL>

<P><STRONG><a name="[11b08d0]"></a>_dsqrt</STRONG> (ARM, 384 bytes, Stack size 16 bytes, dsqrt.o(x$fpl$dsqrt))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _dsqrt</UL>
<BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11856fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>
<BR>[Called By]<UL><LI><a href="#[11a0de0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;sqrt
</UL>

<P><STRONG><a name="[11b0920]"></a>__fpl_inf_dsqrt</STRONG> (ARM, 0 bytes, Stack size unknown bytes, dsqrt.o(x$fpl$dsqrt), UNUSED)

<P><STRONG><a name="[117bc4c]"></a>__aeabi_dsub</STRONG> (ARM, 0 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dsub))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = __aeabi_dsub</UL>
<BR>[Called By]<UL><LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
</UL>

<P><STRONG><a name="[117bbd8]"></a>_dsub</STRONG> (ARM, 572 bytes, Stack size 8 bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c2c0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_dadd1
<LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1185c14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[117be7c]"></a>__fpl_inf_dsub</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)

<P><STRONG><a name="[1184c30]"></a>__dunder</STRONG> (ARM, 272 bytes, Stack size 4 bytes, dunder.o(x$fpl$dunder), UNUSED)

<P><STRONG><a name="[1184be0]"></a>__dunder_d</STRONG> (ARM, 4 bytes, Stack size 0 bytes, dunder.o(x$fpl$dunder), UNUSED)

<P><STRONG><a name="[11788c0]"></a>__aeabi_f2d</STRONG> (ARM, 0 bytes, Stack size 0 bytes, f2d.o(x$fpl$f2d))
<BR><BR>[Called By]<UL><LI><a href="#[b11404]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsAnalogLevelValid (via Veneer)
<LI><a href="#[b11964]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VS_ (via Veneer)
<LI><a href="#[b119e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBR_ (via Veneer)
<LI><a href="#[b11a5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VBL_ (via Veneer)
<LI><a href="#[b11ad8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSR_ (via Veneer)
<LI><a href="#[b11b54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VSL_ (via Veneer)
<LI><a href="#[b11bd0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VC_ (via Veneer)
<LI><a href="#[b11c4c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFR_ (via Veneer)
<LI><a href="#[b11cc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VFL_ (via Veneer)
<LI><a href="#[b146f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[b15354]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsBalanceValid (via Veneer)
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[ff30c4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetDistance (via Veneer)
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
<LI><a href="#[108905c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[117884c]"></a>_f2d</STRONG> (ARM, 96 bytes, Stack size 0 bytes, f2d.o(x$fpl$f2d), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[1178910]"></a>__fpl_inf_f2d</STRONG> (ARM, 0 bytes, Stack size unknown bytes, f2d.o(x$fpl$f2d), UNUSED)

<P><STRONG><a name="[1177ea8]"></a>__aeabi_fadd</STRONG> (ARM, 0 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fadd))
<BR><BR>[Called By]<UL><LI><a href="#[b0e648]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetBalanceVolume (via Veneer)
<LI><a href="#[b15fd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f46e20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
</UL>

<P><STRONG><a name="[1177e34]"></a>_fadd</STRONG> (ARM, 260 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11780e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fsub1
<LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[1177f74]"></a>__fpl_inf_fadd</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)

<P><STRONG><a name="[1184618]"></a>__fpl_fcheck_NaN2</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fcheck.o(x$fpl$fcheck), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b021c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[117418c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fmul
<LI><a href="#[1176c24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fdiv
<LI><a href="#[1177c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub
<LI><a href="#[1177e34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd
<LI><a href="#[1183d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[1184184]"></a>__fpl_fcheck_NaN1</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fcheck1.o(x$fpl$fcheck1), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11b021c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>
<BR>[Called By]<UL><LI><a href="#[1175500]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffixu
<LI><a href="#[117603c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffix
<LI><a href="#[117884c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_f2d
</UL>

<P><STRONG><a name="[1176c98]"></a>__aeabi_fdiv</STRONG> (ARM, 0 bytes, Stack size 4 bytes, fdiv.o(x$fpl$fdiv))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = __aeabi_fdiv</UL>
<BR>[Called By]<UL><LI><a href="#[b0f3d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[b15fd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[ff2cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[ff2ecc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetRoomEQ (via Veneer)
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[ff54ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[108905c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[1176c24]"></a>_fdiv</STRONG> (ARM, 476 bytes, Stack size 4 bytes, fdiv.o(x$fpl$fdiv), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[1176d5c]"></a>__fpl_inf_fdiv</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fdiv.o(x$fpl$fdiv), UNUSED)

<P><STRONG><a name="[1172f04]"></a>__aeabi_cfcmpeq</STRONG> (ARM, 0 bytes, Stack size 0 bytes, feqf.o(x$fpl$feqf))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
</UL>

<P><STRONG><a name="[1172e90]"></a>_fcmpeq</STRONG> (ARM, 116 bytes, Stack size 0 bytes, feqf.o(x$fpl$feqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1183d18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[11760b0]"></a>__aeabi_f2iz</STRONG> (ARM, 0 bytes, Stack size 0 bytes, ffix.o(x$fpl$ffix))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[b14d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ2V (via Veneer)
<LI><a href="#[b1554c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdZ1VM (via Veneer)
<LI><a href="#[ff2cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
</UL>

<P><STRONG><a name="[117603c]"></a>_ffix</STRONG> (ARM, 112 bytes, Stack size 0 bytes, ffix.o(x$fpl$ffix), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[1176180]"></a>__fpl_inf_ffix</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ffix.o(x$fpl$ffix), UNUSED)

<P><STRONG><a name="[1175574]"></a>__aeabi_f2uiz</STRONG> (ARM, 0 bytes, Stack size 0 bytes, ffixu.o(x$fpl$ffixu))
<BR><BR>[Called By]<UL><LI><a href="#[b10234]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdASAVD (via Veneer)
<LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[b10510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDS (via Veneer)
<LI><a href="#[b1058c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAS (via Veneer)
<LI><a href="#[b106fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDP (via Veneer)
<LI><a href="#[b10778]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFP (via Veneer)
<LI><a href="#[b107f0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDP (via Veneer)
<LI><a href="#[b1086c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAP (via Veneer)
<LI><a href="#[b108e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT (via Veneer)
<LI><a href="#[b10960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT (via Veneer)
<LI><a href="#[b109d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDT (via Veneer)
<LI><a href="#[b10a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAT (via Veneer)
<LI><a href="#[b126f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX (via Veneer)
<LI><a href="#[b1276c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL (via Veneer)
<LI><a href="#[b127e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL (via Veneer)
<LI><a href="#[b12864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR (via Veneer)
<LI><a href="#[b128e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR (via Veneer)
<LI><a href="#[b1295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR (via Veneer)
<LI><a href="#[b129d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC (via Veneer)
<LI><a href="#[b12a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL (via Veneer)
<LI><a href="#[b12ea4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPs (via Veneer)
<LI><a href="#[b12f1c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBL (via Veneer)
<LI><a href="#[b12f98]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPBR (via Veneer)
<LI><a href="#[b13014]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSL (via Veneer)
<LI><a href="#[b13090]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPSR (via Veneer)
<LI><a href="#[b1310c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPR (via Veneer)
<LI><a href="#[b13184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPC (via Veneer)
<LI><a href="#[b131fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSPL (via Veneer)
<LI><a href="#[b13a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX (via Veneer)
<LI><a href="#[b13b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL (via Veneer)
<LI><a href="#[b13b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR (via Veneer)
<LI><a href="#[b13c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL (via Veneer)
<LI><a href="#[b13c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR (via Veneer)
<LI><a href="#[b13cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR (via Veneer)
<LI><a href="#[b13d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC (via Veneer)
<LI><a href="#[b13df4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL (via Veneer)
<LI><a href="#[b13ef0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsCrossoverValid (via Veneer)
<LI><a href="#[b14338]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPs (via Veneer)
<LI><a href="#[b143b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBL (via Veneer)
<LI><a href="#[b14428]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPBR (via Veneer)
<LI><a href="#[b144a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSL (via Veneer)
<LI><a href="#[b14518]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPSR (via Veneer)
<LI><a href="#[b14590]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPR (via Veneer)
<LI><a href="#[b14608]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPC (via Veneer)
<LI><a href="#[b14680]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSPL (via Veneer)
<LI><a href="#[f46e20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase (via Veneer)
<LI><a href="#[ff54ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
<LI><a href="#[1052eac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value (via Veneer)
<LI><a href="#[105b81c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
<LI><a href="#[105b894]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q (via Veneer)
<LI><a href="#[105b90c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC (via Veneer)
<LI><a href="#[108905c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[1175500]"></a>_ffixu</STRONG> (ARM, 92 bytes, Stack size 0 bytes, ffixu.o(x$fpl$ffixu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184184]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
</UL>

<P><STRONG><a name="[1175644]"></a>__fpl_inf_ffixu</STRONG> (ARM, 0 bytes, Stack size unknown bytes, ffixu.o(x$fpl$ffixu), UNUSED)

<P><STRONG><a name="[1174a2c]"></a>__aeabi_i2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$fflt))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[b0f4c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;EqModuleconfig (via Veneer)
<LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[b15fd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f21610]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2VolumeSetup (via Veneer)
<LI><a href="#[f43070]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;AutoSoundSetVolume (via Veneer)
<LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage (via Veneer)
<LI><a href="#[fbaff8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Set7Ch1MainVolume (via Veneer)
<LI><a href="#[fbb558]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetZ2MasterVolumeLevel (via Veneer)
<LI><a href="#[fbb6dc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SetAnalogInLevel (via Veneer)
<LI><a href="#[fd0e84]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SeekSelect (via Veneer)
<LI><a href="#[fd135c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SelectSource (via Veneer)
<LI><a href="#[ff2a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ReConvert_8_24_Value (via Veneer)
<LI><a href="#[ff2cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[105b3b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DSP_Power_on_config (via Veneer)
</UL>

<P><STRONG><a name="[11749b8]"></a>_fflt</STRONG> (ARM, 92 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$fflt), UNUSED)

<P><STRONG><a name="[1174b40]"></a>__fflt_normalise</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fflt_noclz.o(x$fpl$fflt), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1174a7c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffltu
</UL>

<P><STRONG><a name="[1174af0]"></a>__aeabi_ui2f</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$ffltu))
<BR><BR>[Called By]<UL><LI><a href="#[b126f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZX (via Veneer)
<LI><a href="#[b1276c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSL (via Veneer)
<LI><a href="#[b127e8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBL (via Veneer)
<LI><a href="#[b12864]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSBR (via Veneer)
<LI><a href="#[b128e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXSR (via Veneer)
<LI><a href="#[b1295c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFR (via Veneer)
<LI><a href="#[b129d8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFC (via Veneer)
<LI><a href="#[b12a54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdMSZXFL (via Veneer)
<LI><a href="#[b13a94]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZX (via Veneer)
<LI><a href="#[b13b0c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBL (via Veneer)
<LI><a href="#[b13b88]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSBR (via Veneer)
<LI><a href="#[b13c04]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSL (via Veneer)
<LI><a href="#[b13c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXSR (via Veneer)
<LI><a href="#[b13cfc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFR (via Veneer)
<LI><a href="#[b13d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFC (via Veneer)
<LI><a href="#[b13df4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdSZXFL (via Veneer)
<LI><a href="#[fb67cc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;MenuItemShow (via Veneer)
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[ff54ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
</UL>

<P><STRONG><a name="[1174a7c]"></a>_ffltu</STRONG> (ARM, 8 bytes, Stack size 0 bytes, fflt_noclz.o(x$fpl$ffltu), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1174b40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fflt_normalise
</UL>

<P><STRONG><a name="[1172978]"></a>__aeabi_cfcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fleqf.o(x$fpl$fleqf))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[ff3244]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetIrc2EqValue (via Veneer)
</UL>

<P><STRONG><a name="[1172904]"></a>_fcmple</STRONG> (ARM, 116 bytes, Stack size 0 bytes, fleqf.o(x$fpl$fleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1183d18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[1174200]"></a>__aeabi_fmul</STRONG> (ARM, 0 bytes, Stack size 0 bytes, fmul.o(x$fpl$fmul))
<BR><BR>[Called By]<UL><LI><a href="#[b0f3d4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindBalancePosition (via Veneer)
<LI><a href="#[b1041c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAHDF (via Veneer)
<LI><a href="#[b10498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTAF (via Veneer)
<LI><a href="#[b108e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFHDT (via Veneer)
<LI><a href="#[b10960]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ProcCmdTFT (via Veneer)
<LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[b15fd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetProtocolFloatValue (via Veneer)
<LI><a href="#[f46e20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[ff2cc4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertBalanceValue (via Veneer)
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[1052eac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Convert_8_24_Value (via Veneer)
<LI><a href="#[105b81c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
<LI><a href="#[105b894]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_Q (via Veneer)
<LI><a href="#[105b90c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_FC (via Veneer)
<LI><a href="#[108905c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ConvertDbValue (via Veneer)
</UL>

<P><STRONG><a name="[117418c]"></a>_fmul</STRONG> (ARM, 260 bytes, Stack size 0 bytes, fmul.o(x$fpl$fmul), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[1174250]"></a>__fpl_inf_fmul</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fmul.o(x$fpl$fmul), UNUSED)

<P><STRONG><a name="[11837b4]"></a>__fpl_normalise2</STRONG> (ARM, 148 bytes, Stack size 0 bytes, fnorm2_noclz.o(x$fpl$fnorm2), UNUSED)

<P><STRONG><a name="[11ab63c]"></a>_fp_init</STRONG> (ARM, 24 bytes, Stack size 8 bytes, fpinit.o(x$fpl$fpinit))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = _fp_init</UL>
<BR>[Calls]<UL><LI><a href="#[11a9dd0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__rt_fp_status_addr
</UL>
<BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (via Veneer)
</UL>

<P><STRONG><a name="[11ab530]"></a>__fplib_config_pureend_doubles</STRONG> (ARM, 0 bytes, Stack size unknown bytes, fpinit.o(x$fpl$fpinit), UNUSED)

<P><STRONG><a name="[11723e4]"></a>__aeabi_cfrcmple</STRONG> (ARM, 0 bytes, Stack size 0 bytes, frleqf.o(x$fpl$frleqf))
<BR><BR>[Called By]<UL><LI><a href="#[b11384]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FindLevelPosition (via Veneer)
<LI><a href="#[b146f8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IsDistanceValid (via Veneer)
<LI><a href="#[f46e20]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CalcMas9116Volume (via Veneer)
<LI><a href="#[ff3044]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetBalance (via Veneer)
<LI><a href="#[ff3144]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSpeakerCheck (via Veneer)
<LI><a href="#[105b81c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CALC_EQ_G (via Veneer)
</UL>

<P><STRONG><a name="[117236c]"></a>_frcmple</STRONG> (ARM, 128 bytes, Stack size 0 bytes, frleqf.o(x$fpl$frleqf), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[1183d18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
</UL>

<P><STRONG><a name="[1177cf4]"></a>__aeabi_fsub</STRONG> (ARM, 0 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fsub))
<BR><BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase (via Veneer)
<LI><a href="#[ff54ec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetCrossoverPoint (via Veneer)
</UL>

<P><STRONG><a name="[1177c80]"></a>_fsub</STRONG> (ARM, 356 bytes, Stack size 0 bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)
<BR><BR>[Calls]<UL><LI><a href="#[11782c4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_fadd1
<LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[1184618]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
</UL>

<P><STRONG><a name="[1177ef8]"></a>__fpl_inf_fsub</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)

<P><STRONG><a name="[11832b8]"></a>__funder</STRONG> (ARM, 140 bytes, Stack size 0 bytes, funder.o(x$fpl$funder), UNUSED)

<P><STRONG><a name="[1183268]"></a>__funder_d</STRONG> (ARM, 4 bytes, Stack size 0 bytes, funder.o(x$fpl$funder), UNUSED)

<P><STRONG><a name="[11af86c]"></a>__ieee_status</STRONG> (ARM, 8 bytes, Stack size 0 bytes, istatus.o(x$fpl$ieeestatus))
<BR><BR>[Called By]<UL><LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (via Veneer)
</UL>

<P><STRONG><a name="[1171e38]"></a>_printf_fp_dec</STRONG> (ARM, 4 bytes, Stack size 0 bytes, printf1.o(x$fpl$printf1))
<BR><BR>[Stack]<UL><LI>Max Depth = 336 + Unknown Stack Size
<LI>Call Chain = _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[1188350]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (via Veneer)
</UL>

<P><STRONG><a name="[11825ac]"></a>_printf_fp_hex</STRONG> (ARM, 4 bytes, Stack size 0 bytes, printf2.o(x$fpl$printf2))
<BR><BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (via Veneer)
</UL>

<P><STRONG><a name="[11b021c]"></a>__fpl_return_NaN</STRONG> (ARM, 116 bytes, Stack size 0 bytes, retnan.o(x$fpl$retnan))
<BR><BR>[Calls]<UL><LI><a href="#[11afd20]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_cmpreturn
</UL>
<BR>[Called By]<UL><LI><a href="#[1184184]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN1
<LI><a href="#[1184618]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcheck_NaN2
<LI><a href="#[11856fc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
<LI><a href="#[1185c14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN2
</UL>

<P><STRONG><a name="[1182ad0]"></a>__ARM_scalbn</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[1182b4c]"></a>scalbln</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[1182bc0]"></a>scalblnl</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[1182d2c]"></a>scalbn</STRONG> (ARM, 108 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn))
<BR><BR>[Calls]<UL><LI><a href="#[117c9d0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_infinity (Weak Reference)
<LI><a href="#[11856fc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcheck_NaN1
</UL>
<BR>[Called By]<UL><LI><a href="#[119054c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;pow
<LI><a href="#[11aef5c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__support_dtoi
</UL>

<P><STRONG><a name="[1182c38]"></a>scalbnl</STRONG> (ARM, 0 bytes, Stack size 0 bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[1182cac]"></a>__fpl_inf_scalbn</STRONG> (ARM, 0 bytes, Stack size unknown bytes, scalbn_noclz.o(x$fpl$scalbn), UNUSED)

<P><STRONG><a name="[11afd20]"></a>__fpl_cmpreturn</STRONG> (ARM, 60 bytes, Stack size 0 bytes, trapv.o(x$fpl$trapveneer))
<BR><BR>[Called By]<UL><LI><a href="#[1183d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN
<LI><a href="#[118525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN
<LI><a href="#[11b021c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_return_NaN
</UL>

<P><STRONG><a name="[a66c54]"></a>Undef_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66c54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66c54]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Undef_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66bdc]"></a>SWI_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66bdc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SWI_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66bdc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SWI_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66b60]"></a>PAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66b60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66b60]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66ae4]"></a>DAbt_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66ae4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66ae4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DAbt_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a66a6c]"></a>IRQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a66a6c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a66a6c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;IRQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[a669f4]"></a>FIQ_Handler</STRONG> (ARM, 4 bytes, Stack size unknown bytes, lpc2300.o(RESET))
<BR><BR>[Calls]<UL><LI><a href="#[a669f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Called By]<UL><LI><a href="#[a669f4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;FIQ_Handler
</UL>
<BR>[Address Reference Count : 1]<UL><LI> lpc2300.o(RESET)
</UL>
<P><STRONG><a name="[f2ed64]"></a>panel_convert_key_value</STRONG> (Thumb, 42 bytes, Stack size 0 bytes, key_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f2ecec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>

<P><STRONG><a name="[f2ecec]"></a>read_key</STRONG> (Thumb, 166 bytes, Stack size 24 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 80<LI>Call Chain = read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f2d778]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read165
<LI><a href="#[f2da68]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HeadphoneDetect
<LI><a href="#[f2ed64]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;panel_convert_key_value
</UL>
<BR>[Called By]<UL><LI><a href="#[f2eb74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[f2ec70]"></a>proc_key_press</STRONG> (Thumb, 24 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = proc_key_press -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f2d8f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[f2eb74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[f2ebf4]"></a>proc_key_hold</STRONG> (Thumb, 30 bytes, Stack size 16 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 64<LI>Call Chain = proc_key_hold -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f2d8f4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetKey
</UL>
<BR>[Called By]<UL><LI><a href="#[f2eb74]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetPanelKeyThread
</UL>

<P><STRONG><a name="[f2eb74]"></a>GetPanelKeyThread</STRONG> (Thumb, 94 bytes, Stack size 8 bytes, key_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 88<LI>Call Chain = GetPanelKeyThread -> read_key -> HeadphoneDetect -> MsgSetKey -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[f2ebf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;proc_key_hold
<LI><a href="#[f2ec70]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;proc_key_press
<LI><a href="#[f2ecec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;read_key
</UL>
<BR>[Called By]<UL><LI><a href="#[f2d96c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;key_task
</UL>

<P><STRONG><a name="[b228c4]"></a>IsMsgQueueEmpty</STRONG> (Thumb, 24 bytes, Stack size 0 bytes, message.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[a60228]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;GetMessage
</UL>

<P><STRONG><a name="[b22848]"></a>IsMsgQueueFull</STRONG> (Thumb, 38 bytes, Stack size 8 bytes, message.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8<LI>Call Chain = IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b22094]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SendMessage
<LI><a href="#[b2210c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PostMessage
</UL>

<P><STRONG><a name="[fd3b28]"></a>Zone1ProcessKey</STRONG> (Thumb, 1282 bytes, Stack size 8 bytes, zone1_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 760 + Unknown Stack Size
<LI>Call Chain = Zone1ProcessKey -> SetupInit -> SetupMenuInit -> MenuDisplay -> MenuItemShow -> VfdShowMenuOption -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b03f98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplayBlank
<LI><a href="#[b0dfec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDispBlank
<LI><a href="#[b0e06c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdTempDisp
<LI><a href="#[b0e254]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupLoadDefault
<LI><a href="#[b0e558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetLate
<LI><a href="#[b0e838]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;RadioInit
<LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0ec14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0ed84]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetDimer
<LI><a href="#[b0f454]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EqOn
<LI><a href="#[b0f544]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;EepromWriteByte
<LI><a href="#[f1e52c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;debug_printf
<LI><a href="#[f89dc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetVfdOwner
<LI><a href="#[fb65e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetupInit
<LI><a href="#[fbac88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;VfdDisplay
<LI><a href="#[fcfbd4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetDh2On
<LI><a href="#[fd0098]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HDMI_Software_Update
<LI><a href="#[fd062c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AutoSoundInit
<LI><a href="#[fd07b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsHidenKey
<LI><a href="#[fd082c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcSurKey
<LI><a href="#[fd08a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsProcPliiKey
<LI><a href="#[fd0924]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcPliiKey
<LI><a href="#[fd09a0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcSurKey
<LI><a href="#[fd0a1c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcPliiKey
<LI><a href="#[fd0a98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcNeoKey
<LI><a href="#[fd0b14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DtsProcCesKey
<LI><a href="#[fd0b90]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Ac3ProcCesKey
<LI><a href="#[fd0c0c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;PcmProcCesKey
<LI><a href="#[fd0e08]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ProcAutoSeekSur
<LI><a href="#[fd0ff4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetAutoseekFlag
<LI><a href="#[fd1070]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone1Mute
<LI><a href="#[fd1558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;ShowVersion
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
<LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[b03f50]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone1ProcMessage
</UL>

<P><STRONG><a name="[fdce94]"></a>Zone2ProcessKey</STRONG> (Thumb, 774 bytes, Stack size 16 bytes, zone2_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = Zone2ProcessKey -> Zone2RadioMode -> VfdTempDisp -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[b0dd80]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2RadioMode
<LI><a href="#[b0ddfc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Zone2AnalogInOff
<LI><a href="#[b0e0e4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateMax335
<LI><a href="#[b0e4dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetMax335Switch
<LI><a href="#[b0e99c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVolume
<LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[b0eb14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetRadioLoadPreset
<LI><a href="#[b0ec14]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetPower
<LI><a href="#[b0ec8c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetMute
<LI><a href="#[b0ed04]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetInputSource
<LI><a href="#[b0f0f0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;IsCurFocusTid
<LI><a href="#[b0f16c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;HdmiReadByte
<LI><a href="#[b0f264]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;GetSrcName
<LI><a href="#[b0f8ac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigiSendByte
<LI><a href="#[fdbcac]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CalcRadioPosition
<LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[f8d2b0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Zone2ProcMessage
</UL>

<P><STRONG><a name="[ff54ec]"></a>GetCrossoverPoint</STRONG> (Thumb, 48 bytes, Stack size 16 bytes, auto_sound.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = GetCrossoverPoint -> __aeabi_fdiv</UL>
<BR>[Calls]<UL><LI><a href="#[1174af0]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_ui2f (via Veneer)
<LI><a href="#[1175574]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_f2uiz (via Veneer)
<LI><a href="#[1176c98]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fdiv (via Veneer)
<LI><a href="#[1177cf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_fsub (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[ff2dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;ASProcSetSpeakerphase
</UL>

<P><STRONG><a name="[1002abc]"></a>get_freq</STRONG> (Thumb, 26 bytes, Stack size 0 bytes, radio_task.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[f8d330]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioProcMessage
</UL>

<P><STRONG><a name="[1002950]"></a>PreProcDigitKey</STRONG> (Thumb, 144 bytes, Stack size 4 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 4<LI>Call Chain = PreProcDigitKey</UL>
<BR>[Calls]<UL><LI><a href="#[1171970]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_switch8 (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[10028d8]"></a>SaveExit</STRONG> (Thumb, 22 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 56<LI>Call Chain = SaveExit -> MsgSetVfdShow -> SendMessage -> IsMsgQueueFull</UL>
<BR>[Calls]<UL><LI><a href="#[b0ea18]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;MsgSetVfdShow
<LI><a href="#[10002b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[fffac8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;PreProcSaveKey
</UL>

<P><STRONG><a name="[1002860]"></a>SaveInit</STRONG> (Thumb, 30 bytes, Stack size 8 bytes, radio_task.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 616 + Unknown Stack Size
<LI>Call Chain = SaveInit -> UpdateSaveVfd -> VfdDisplay -> vsprintf -> _printf_char_common -> __printf -> _printf_fp_dec -> _printf_fp_dec_real -> _fp_display -> _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[fffcc8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;UpdateSaveVfd
<LI><a href="#[10002b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetRadioStatus
</UL>
<BR>[Called By]<UL><LI><a href="#[fff9c8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;RadioKeyService
</UL>

<P><STRONG><a name="[f75e40]"></a>i2c_ack</STRONG> (Thumb, 286 bytes, Stack size 24 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 24 + Unknown Stack Size
<LI>Call Chain = i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[11714e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[f7588c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[f75cd4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;i2c_writebyte
<LI><a href="#[1006d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
</UL>

<P><STRONG><a name="[f75dc8]"></a>i2c_start</STRONG> (Thumb, 102 bytes, Stack size 8 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = i2c_start</UL>
<BR>[Calls]<UL><LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[f7588c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[f75908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[1006d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[1006d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
</UL>

<P><STRONG><a name="[f75d50]"></a>i2c_stop</STRONG> (Thumb, 72 bytes, Stack size 8 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 8 + Unknown Stack Size
<LI>Call Chain = i2c_stop</UL>
<BR>[Calls]<UL><LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[f7588c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[f75908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[1006d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[1006d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
</UL>

<P><STRONG><a name="[f75cd4]"></a>i2c_writebyte</STRONG> (Thumb, 158 bytes, Stack size 16 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 40 + Unknown Stack Size
<LI>Call Chain = i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f75e40]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;i2c_ack
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
</UL>
<BR>[Called By]<UL><LI><a href="#[f7588c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[f75908]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CWriteNByte
<LI><a href="#[1006d14]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_bytewrite
<LI><a href="#[1006d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
</UL>

<P><STRONG><a name="[f75c58]"></a>i2c_readbyte</STRONG> (Thumb, 132 bytes, Stack size 16 bytes, i2cdrv.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16 + Unknown Stack Size
<LI>Call Chain = i2c_readbyte</UL>
<BR>[Calls]<UL><LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[117141c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r1
<LI><a href="#[11714e8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_call_via_r0
</UL>
<BR>[Called By]<UL><LI><a href="#[f7588c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2CReadNByte
<LI><a href="#[1006d90]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;I2C_byteread
</UL>

<P><STRONG><a name="[f6f58c]"></a>Iec4094Sendbyte</STRONG> (Thumb, 68 bytes, Stack size 16 bytes, ic4094.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Iec4094Sendbyte</UL>
<BR>[Calls]<UL><LI><a href="#[f6e8f8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetData4094
<LI><a href="#[f6ea60]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set4094Clk
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
</UL>
<BR>[Called By]<UL><LI><a href="#[f6f05c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Ext4094Sendbyte
</UL>

<P><STRONG><a name="[f475b0]"></a>Mas9116WriteWord</STRONG> (Thumb, 84 bytes, Stack size 16 bytes, mas9116.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Mas9116WriteWord</UL>
<BR>[Calls]<UL><LI><a href="#[fbaefc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport0
<LI><a href="#[10204b4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;wait_timer
<LI><a href="#[102061c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SetIoport1
</UL>
<BR>[Called By]<UL><LI><a href="#[f46cac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116Reset
<LI><a href="#[f46da4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;Mas9116SetGain
</UL>

<P><STRONG><a name="[f3a4a8]"></a>CheckInputChannel</STRONG> (Thumb, 382 bytes, Stack size 16 bytes, channel.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 200 + Unknown Stack Size
<LI>Call Chain = CheckInputChannel -> DigitalInSelectChannel -> DigiSendByte -> I2C_bytewrite -> i2c_writebyte -> i2c_ack</UL>
<BR>[Calls]<UL><LI><a href="#[f39524]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckAnalogIn
<LI><a href="#[f39624]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelectChannel
<LI><a href="#[fd0394]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;DigitalInSelect71Channel
<LI><a href="#[fd06a8]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInputTypeSelect
<LI><a href="#[fd072c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Analog7CH1OutSelectChannel
<LI><a href="#[fff944]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;AnalogInSelectChannel
<LI><a href="#[1006e88]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;CheckCs8416Unlock
</UL>
<BR>[Called By]<UL><LI><a href="#[f39424]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSelectInputChannel
<LI><a href="#[fcf8e4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;SystemSearchInputChannel
<LI><a href="#[fd05b4]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;CheckInput
</UL>

<P><STRONG><a name="[1091f28]"></a>Write_Byte</STRONG> (Thumb, 56 bytes, Stack size 16 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = Write_Byte</UL>
<BR>[Calls]<UL><LI><a href="#[f68558]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_MOSI
<LI><a href="#[f685d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
</UL>
<BR>[Called By]<UL><LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
<LI><a href="#[10915e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiWriteNByte
</UL>

<P><STRONG><a name="[1091eb0]"></a>ReadByteDsp</STRONG> (Thumb, 82 bytes, Stack size 16 bytes, dsp_spi.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 20<LI>Call Chain = ReadByteDsp -> SenseDspIrq</UL>
<BR>[Calls]<UL><LI><a href="#[f684dc]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Sense_Spi_MISO
<LI><a href="#[f685d4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;Set_Spi_Clk
<LI><a href="#[f68740]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;SenseDspIrq
</UL>
<BR>[Called By]<UL><LI><a href="#[1091564]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;DspSpiReadNByte
</UL>

<P><STRONG><a name="[11807e8]"></a>__arm_div4</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1180440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[1180770]"></a>__arm_div8</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1180440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[11806f4]"></a>__arm_div_large</STRONG> (ARM, 0 bytes, Stack size unknown bytes, aeabi_sdiv.o(.text))
<BR><BR>[Called By]<UL><LI><a href="#[1180440]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__aeabi_uidivmod
</UL>

<P><STRONG><a name="[117c2c0]"></a>_dadd1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[117bbd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub
<LI><a href="#[117bc9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drsb
</UL>

<P><STRONG><a name="[117c0e4]"></a>_dsub1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, daddsub_noclz.o(x$fpl$dsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[117bc9c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_drsb
<LI><a href="#[117bd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd
</UL>

<P><STRONG><a name="[11782c4]"></a>_fadd1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fadd), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1177c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub
</UL>

<P><STRONG><a name="[11780e8]"></a>_fsub1</STRONG> (ARM, 0 bytes, Stack size unknown bytes, faddsub_noclz.o(x$fpl$fsub), UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[1177e34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd
</UL>

<P><STRONG><a name="[1188510]"></a>_fp_digits</STRONG> (Thumb, 492 bytes, Stack size 96 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 216<LI>Call Chain = _fp_digits -> _btod_etento -> _btod_emul -> _e2e</UL>
<BR>[Calls]<UL><LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
<LI><a href="#[119bb54]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_emul (via Veneer)
<LI><a href="#[119bba4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_ediv (via Veneer)
<LI><a href="#[119bbf4]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_d2e (via Veneer)
<LI><a href="#[119caec]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_btod_etento
<LI><a href="#[119d10c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;_ll_udiv10 (via Veneer)
<LI><a href="#[11aef5c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__support_dtoi (via Veneer)
<LI><a href="#[11af86c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ieee_status (via Veneer)
</UL>
<BR>[Called By]<UL><LI><a href="#[11883a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>

<P><STRONG><a name="[1188498]"></a>_fp_addexp</STRONG> (Thumb, 72 bytes, Stack size 16 bytes, _printf_fp_dec.o(.text))
<BR><BR>[Stack]<UL><LI>Max Depth = 16<LI>Call Chain = _fp_addexp</UL>
<BR>[Calls]<UL><LI><a href="#[118050c]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__aeabi_idivmod (via Veneer)
<LI><a href="#[118b300]">&gt;&gt;</a>&nbsp;&nbsp;&nbsp;__ARM_stackcheck (Weak Reference)
</UL>
<BR>[Called By]<UL><LI><a href="#[11883a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display
</UL>

<P><STRONG><a name="[1192c7c]"></a>__ARM_exceptions_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[118b300]"></a>__ARM_stackcheck</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1188350]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_printf_fp_dec_real (Weak Reference)
<LI><a href="#[11883a0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_display (Weak Reference)
<LI><a href="#[1188498]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_addexp (Weak Reference)
<LI><a href="#[1188510]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fp_digits (Weak Reference)
<LI><a href="#[118b400]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__set_errno (Weak Reference)
<LI><a href="#[118b450]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__read_errno (Weak Reference)
<LI><a href="#[1192d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
<LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
<LI><a href="#[1196490]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
<LI><a href="#[1196a78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_numeric (Weak Reference)
<LI><a href="#[11973e0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_wcrtomb (Weak Reference)
<LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
<LI><a href="#[119caec]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_btod_etento (Weak Reference)
<LI><a href="#[11a89a8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_get_lc_ctype (Weak Reference)
</UL>

<P><STRONG><a name="[1192c00]"></a>__Heap_DescSize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192b80]"></a>__alloca_initialize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192af8]"></a>__cpp_initialize__aeabi_</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192a7c]"></a>__cxa_finalize</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>

<P><STRONG><a name="[117c9d0]"></a>__fpl_infinity</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[117418c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fmul (Weak Reference)
<LI><a href="#[1175500]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffixu (Weak Reference)
<LI><a href="#[117603c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ffix (Weak Reference)
<LI><a href="#[1176c24]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fdiv (Weak Reference)
<LI><a href="#[1177c80]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fsub (Weak Reference)
<LI><a href="#[1177e34]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_fadd (Weak Reference)
<LI><a href="#[117884c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_f2d (Weak Reference)
<LI><a href="#[117910c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dmul (Weak Reference)
<LI><a href="#[117a99c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_ddiv (Weak Reference)
<LI><a href="#[117bbd8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsub (Weak Reference)
<LI><a href="#[117bd8c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dadd (Weak Reference)
<LI><a href="#[117c890]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_d2f (Weak Reference)
<LI><a href="#[1182d2c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;scalbn (Weak Reference)
<LI><a href="#[1183d18]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_fcmp_InfNaN (Weak Reference)
<LI><a href="#[118525c]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__fpl_dcmp_InfNaN (Weak Reference)
<LI><a href="#[11b08d0]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;_dsqrt (Weak Reference)
</UL>

<P><STRONG><a name="[117d890]"></a>__user_heap_extend</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED, UNUSED)
<BR><BR>[Called By]<UL><LI><a href="#[117d6ac]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_heap_extend (Weak Reference)
</UL>

<P><STRONG><a name="[1192a00]"></a>_atexit_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11963c0]"></a>_call_atexit_fns</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1196490]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;exit (Weak Reference)
</UL>

<P><STRONG><a name="[1192988]"></a>_clock_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[119290c]"></a>_fp_trap_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192890]"></a>_get_lc_collate</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192794]"></a>_get_lc_monetary</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192718]"></a>_get_lc_time</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[119269c]"></a>_getenv_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192624]"></a>_init_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11925a4]"></a>_init_user_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1192530]"></a>_initio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[1198f40]"></a>_printf_mbtowc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
</UL>

<P><STRONG><a name="[1198ec8]"></a>_printf_wc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1198fbc]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__printf (Weak Reference)
</UL>

<P><STRONG><a name="[11924b8]"></a>_rand_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[119243c]"></a>_signal_init</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192dc8]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_init (Weak Reference)
</UL>

<P><STRONG><a name="[11923b8]"></a>_terminate_user_alloc</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>

<P><STRONG><a name="[119233c]"></a>_terminateio</STRONG> (Unknown, 0 bytes, Stack size 0 bytes, UNDEFINED)
<BR><BR>[Called By]<UL><LI><a href="#[1192d78]">&lt;&lt;</a>&nbsp;&nbsp;&nbsp;__rt_lib_shutdown (Weak Reference)
</UL>
<HR></body></html>
